
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MeetingRoom
 * 
 */
export type MeetingRoom = $Result.DefaultSelection<Prisma.$MeetingRoomPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingRequiredPosition
 * 
 */
export type BookingRequiredPosition = $Result.DefaultSelection<Prisma.$BookingRequiredPositionPayload>
/**
 * Model BookingInvite
 * 
 */
export type BookingInvite = $Result.DefaultSelection<Prisma.$BookingInvitePayload>
/**
 * Model BookingNoteTaker
 * 
 */
export type BookingNoteTaker = $Result.DefaultSelection<Prisma.$BookingNoteTakerPayload>
/**
 * Model NoteTakerQueue
 * 
 */
export type NoteTakerQueue = $Result.DefaultSelection<Prisma.$NoteTakerQueuePayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model BookingService
 * 
 */
export type BookingService = $Result.DefaultSelection<Prisma.$BookingServicePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NoteTakerLeave
 * 
 */
export type NoteTakerLeave = $Result.DefaultSelection<Prisma.$NoteTakerLeavePayload>
/**
 * Model HousekeepingTask
 * * ✅ ใหม่: งานแม่บ้าน สร้างจากบริการของการจอง
 */
export type HousekeepingTask = $Result.DefaultSelection<Prisma.$HousekeepingTaskPayload>
/**
 * Model Issue
 * 
 */
export type Issue = $Result.DefaultSelection<Prisma.$IssuePayload>
/**
 * Model IssueComment
 * 
 */
export type IssueComment = $Result.DefaultSelection<Prisma.$IssueCommentPayload>
/**
 * Model IssueAttachment
 * 
 */
export type IssueAttachment = $Result.DefaultSelection<Prisma.$IssueAttachmentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoomStatus: {
  AVAILABLE: 'AVAILABLE',
  UNAVAILABLE: 'UNAVAILABLE'
};

export type RoomStatus = (typeof RoomStatus)[keyof typeof RoomStatus]


export const BookingStatus: {
  AWAITING_ATTENDEE_CONFIRM: 'AWAITING_ATTENDEE_CONFIRM',
  AWAITING_ADMIN_APPROVAL: 'AWAITING_ADMIN_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const InviteStatus: {
  INVITED: 'INVITED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const NoteQueueStatus: {
  INVITED: 'INVITED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  REPLACED: 'REPLACED'
};

export type NoteQueueStatus = (typeof NoteQueueStatus)[keyof typeof NoteQueueStatus]


export const ServiceCategory: {
  IT: 'IT',
  HOUSEKEEPING: 'HOUSEKEEPING',
  NOTETAKING: 'NOTETAKING'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const ServiceStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]


export const NotifType: {
  INVITE: 'INVITE',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELED: 'CANCELED',
  RESCHEDULED: 'RESCHEDULED',
  ISSUE_CREATED: 'ISSUE_CREATED'
};

export type NotifType = (typeof NotifType)[keyof typeof NotifType]


export const RefType: {
  BOOKING: 'BOOKING',
  INVITE: 'INVITE',
  ISSUE: 'ISSUE'
};

export type RefType = (typeof RefType)[keyof typeof RefType]


export const HousekeepingTaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE',
  CANCELLED: 'CANCELLED'
};

export type HousekeepingTaskStatus = (typeof HousekeepingTaskStatus)[keyof typeof HousekeepingTaskStatus]


export const IssuePriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type IssuePriority = (typeof IssuePriority)[keyof typeof IssuePriority]


export const IssueStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type IssueStatus = (typeof IssueStatus)[keyof typeof IssueStatus]


export const IssueType: {
  BOOKING_EQUIPMENT: 'BOOKING_EQUIPMENT',
  BOOKING_CONFIRMATION: 'BOOKING_CONFIRMATION',
  BOOKING_DOCUMENT: 'BOOKING_DOCUMENT',
  BOOKING_APPROVAL: 'BOOKING_APPROVAL',
  BOOKING_SUPPORT: 'BOOKING_SUPPORT',
  SYSTEM_ERROR: 'SYSTEM_ERROR',
  OTHER: 'OTHER'
};

export type IssueType = (typeof IssueType)[keyof typeof IssueType]

}

export type RoomStatus = $Enums.RoomStatus

export const RoomStatus: typeof $Enums.RoomStatus

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type NoteQueueStatus = $Enums.NoteQueueStatus

export const NoteQueueStatus: typeof $Enums.NoteQueueStatus

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

export type NotifType = $Enums.NotifType

export const NotifType: typeof $Enums.NotifType

export type RefType = $Enums.RefType

export const RefType: typeof $Enums.RefType

export type HousekeepingTaskStatus = $Enums.HousekeepingTaskStatus

export const HousekeepingTaskStatus: typeof $Enums.HousekeepingTaskStatus

export type IssuePriority = $Enums.IssuePriority

export const IssuePriority: typeof $Enums.IssuePriority

export type IssueStatus = $Enums.IssueStatus

export const IssueStatus: typeof $Enums.IssueStatus

export type IssueType = $Enums.IssueType

export const IssueType: typeof $Enums.IssueType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Departments
 * const departments = await prisma.department.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Departments
   * const departments = await prisma.department.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meetingRoom`: Exposes CRUD operations for the **MeetingRoom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingRooms
    * const meetingRooms = await prisma.meetingRoom.findMany()
    * ```
    */
  get meetingRoom(): Prisma.MeetingRoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingRequiredPosition`: Exposes CRUD operations for the **BookingRequiredPosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingRequiredPositions
    * const bookingRequiredPositions = await prisma.bookingRequiredPosition.findMany()
    * ```
    */
  get bookingRequiredPosition(): Prisma.BookingRequiredPositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingInvite`: Exposes CRUD operations for the **BookingInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingInvites
    * const bookingInvites = await prisma.bookingInvite.findMany()
    * ```
    */
  get bookingInvite(): Prisma.BookingInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingNoteTaker`: Exposes CRUD operations for the **BookingNoteTaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingNoteTakers
    * const bookingNoteTakers = await prisma.bookingNoteTaker.findMany()
    * ```
    */
  get bookingNoteTaker(): Prisma.BookingNoteTakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteTakerQueue`: Exposes CRUD operations for the **NoteTakerQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteTakerQueues
    * const noteTakerQueues = await prisma.noteTakerQueue.findMany()
    * ```
    */
  get noteTakerQueue(): Prisma.NoteTakerQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingService`: Exposes CRUD operations for the **BookingService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingServices
    * const bookingServices = await prisma.bookingService.findMany()
    * ```
    */
  get bookingService(): Prisma.BookingServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.noteTakerLeave`: Exposes CRUD operations for the **NoteTakerLeave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoteTakerLeaves
    * const noteTakerLeaves = await prisma.noteTakerLeave.findMany()
    * ```
    */
  get noteTakerLeave(): Prisma.NoteTakerLeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.housekeepingTask`: Exposes CRUD operations for the **HousekeepingTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HousekeepingTasks
    * const housekeepingTasks = await prisma.housekeepingTask.findMany()
    * ```
    */
  get housekeepingTask(): Prisma.HousekeepingTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issueComment`: Exposes CRUD operations for the **IssueComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueComments
    * const issueComments = await prisma.issueComment.findMany()
    * ```
    */
  get issueComment(): Prisma.IssueCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.issueAttachment`: Exposes CRUD operations for the **IssueAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueAttachments
    * const issueAttachments = await prisma.issueAttachment.findMany()
    * ```
    */
  get issueAttachment(): Prisma.IssueAttachmentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Department: 'Department',
    Position: 'Position',
    User: 'User',
    MeetingRoom: 'MeetingRoom',
    Booking: 'Booking',
    BookingRequiredPosition: 'BookingRequiredPosition',
    BookingInvite: 'BookingInvite',
    BookingNoteTaker: 'BookingNoteTaker',
    NoteTakerQueue: 'NoteTakerQueue',
    Service: 'Service',
    BookingService: 'BookingService',
    Notification: 'Notification',
    NoteTakerLeave: 'NoteTakerLeave',
    HousekeepingTask: 'HousekeepingTask',
    Issue: 'Issue',
    IssueComment: 'IssueComment',
    IssueAttachment: 'IssueAttachment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "department" | "position" | "user" | "meetingRoom" | "booking" | "bookingRequiredPosition" | "bookingInvite" | "bookingNoteTaker" | "noteTakerQueue" | "service" | "bookingService" | "notification" | "noteTakerLeave" | "housekeepingTask" | "issue" | "issueComment" | "issueAttachment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MeetingRoom: {
        payload: Prisma.$MeetingRoomPayload<ExtArgs>
        fields: Prisma.MeetingRoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingRoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingRoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          findFirst: {
            args: Prisma.MeetingRoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingRoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          findMany: {
            args: Prisma.MeetingRoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>[]
          }
          create: {
            args: Prisma.MeetingRoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          createMany: {
            args: Prisma.MeetingRoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingRoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>[]
          }
          delete: {
            args: Prisma.MeetingRoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          update: {
            args: Prisma.MeetingRoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          deleteMany: {
            args: Prisma.MeetingRoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingRoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingRoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>[]
          }
          upsert: {
            args: Prisma.MeetingRoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRoomPayload>
          }
          aggregate: {
            args: Prisma.MeetingRoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingRoom>
          }
          groupBy: {
            args: Prisma.MeetingRoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingRoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingRoomCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingRoomCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingRequiredPosition: {
        payload: Prisma.$BookingRequiredPositionPayload<ExtArgs>
        fields: Prisma.BookingRequiredPositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingRequiredPositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingRequiredPositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          findFirst: {
            args: Prisma.BookingRequiredPositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingRequiredPositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          findMany: {
            args: Prisma.BookingRequiredPositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>[]
          }
          create: {
            args: Prisma.BookingRequiredPositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          createMany: {
            args: Prisma.BookingRequiredPositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingRequiredPositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>[]
          }
          delete: {
            args: Prisma.BookingRequiredPositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          update: {
            args: Prisma.BookingRequiredPositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          deleteMany: {
            args: Prisma.BookingRequiredPositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingRequiredPositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingRequiredPositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>[]
          }
          upsert: {
            args: Prisma.BookingRequiredPositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingRequiredPositionPayload>
          }
          aggregate: {
            args: Prisma.BookingRequiredPositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingRequiredPosition>
          }
          groupBy: {
            args: Prisma.BookingRequiredPositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingRequiredPositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingRequiredPositionCountArgs<ExtArgs>
            result: $Utils.Optional<BookingRequiredPositionCountAggregateOutputType> | number
          }
        }
      }
      BookingInvite: {
        payload: Prisma.$BookingInvitePayload<ExtArgs>
        fields: Prisma.BookingInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          findFirst: {
            args: Prisma.BookingInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          findMany: {
            args: Prisma.BookingInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>[]
          }
          create: {
            args: Prisma.BookingInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          createMany: {
            args: Prisma.BookingInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>[]
          }
          delete: {
            args: Prisma.BookingInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          update: {
            args: Prisma.BookingInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          deleteMany: {
            args: Prisma.BookingInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>[]
          }
          upsert: {
            args: Prisma.BookingInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingInvitePayload>
          }
          aggregate: {
            args: Prisma.BookingInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingInvite>
          }
          groupBy: {
            args: Prisma.BookingInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingInviteCountArgs<ExtArgs>
            result: $Utils.Optional<BookingInviteCountAggregateOutputType> | number
          }
        }
      }
      BookingNoteTaker: {
        payload: Prisma.$BookingNoteTakerPayload<ExtArgs>
        fields: Prisma.BookingNoteTakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingNoteTakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingNoteTakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          findFirst: {
            args: Prisma.BookingNoteTakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingNoteTakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          findMany: {
            args: Prisma.BookingNoteTakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>[]
          }
          create: {
            args: Prisma.BookingNoteTakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          createMany: {
            args: Prisma.BookingNoteTakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingNoteTakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>[]
          }
          delete: {
            args: Prisma.BookingNoteTakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          update: {
            args: Prisma.BookingNoteTakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          deleteMany: {
            args: Prisma.BookingNoteTakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingNoteTakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingNoteTakerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>[]
          }
          upsert: {
            args: Prisma.BookingNoteTakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingNoteTakerPayload>
          }
          aggregate: {
            args: Prisma.BookingNoteTakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingNoteTaker>
          }
          groupBy: {
            args: Prisma.BookingNoteTakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingNoteTakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingNoteTakerCountArgs<ExtArgs>
            result: $Utils.Optional<BookingNoteTakerCountAggregateOutputType> | number
          }
        }
      }
      NoteTakerQueue: {
        payload: Prisma.$NoteTakerQueuePayload<ExtArgs>
        fields: Prisma.NoteTakerQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteTakerQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteTakerQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          findFirst: {
            args: Prisma.NoteTakerQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteTakerQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          findMany: {
            args: Prisma.NoteTakerQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>[]
          }
          create: {
            args: Prisma.NoteTakerQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          createMany: {
            args: Prisma.NoteTakerQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteTakerQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>[]
          }
          delete: {
            args: Prisma.NoteTakerQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          update: {
            args: Prisma.NoteTakerQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          deleteMany: {
            args: Prisma.NoteTakerQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteTakerQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteTakerQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>[]
          }
          upsert: {
            args: Prisma.NoteTakerQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerQueuePayload>
          }
          aggregate: {
            args: Prisma.NoteTakerQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteTakerQueue>
          }
          groupBy: {
            args: Prisma.NoteTakerQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteTakerQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteTakerQueueCountArgs<ExtArgs>
            result: $Utils.Optional<NoteTakerQueueCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      BookingService: {
        payload: Prisma.$BookingServicePayload<ExtArgs>
        fields: Prisma.BookingServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findFirst: {
            args: Prisma.BookingServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          findMany: {
            args: Prisma.BookingServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          create: {
            args: Prisma.BookingServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          createMany: {
            args: Prisma.BookingServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          delete: {
            args: Prisma.BookingServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          update: {
            args: Prisma.BookingServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          deleteMany: {
            args: Prisma.BookingServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>[]
          }
          upsert: {
            args: Prisma.BookingServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingServicePayload>
          }
          aggregate: {
            args: Prisma.BookingServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingService>
          }
          groupBy: {
            args: Prisma.BookingServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingServiceCountArgs<ExtArgs>
            result: $Utils.Optional<BookingServiceCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NoteTakerLeave: {
        payload: Prisma.$NoteTakerLeavePayload<ExtArgs>
        fields: Prisma.NoteTakerLeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteTakerLeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteTakerLeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          findFirst: {
            args: Prisma.NoteTakerLeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteTakerLeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          findMany: {
            args: Prisma.NoteTakerLeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>[]
          }
          create: {
            args: Prisma.NoteTakerLeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          createMany: {
            args: Prisma.NoteTakerLeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NoteTakerLeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>[]
          }
          delete: {
            args: Prisma.NoteTakerLeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          update: {
            args: Prisma.NoteTakerLeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          deleteMany: {
            args: Prisma.NoteTakerLeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoteTakerLeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NoteTakerLeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>[]
          }
          upsert: {
            args: Prisma.NoteTakerLeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoteTakerLeavePayload>
          }
          aggregate: {
            args: Prisma.NoteTakerLeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoteTakerLeave>
          }
          groupBy: {
            args: Prisma.NoteTakerLeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteTakerLeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoteTakerLeaveCountArgs<ExtArgs>
            result: $Utils.Optional<NoteTakerLeaveCountAggregateOutputType> | number
          }
        }
      }
      HousekeepingTask: {
        payload: Prisma.$HousekeepingTaskPayload<ExtArgs>
        fields: Prisma.HousekeepingTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HousekeepingTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HousekeepingTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          findFirst: {
            args: Prisma.HousekeepingTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HousekeepingTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          findMany: {
            args: Prisma.HousekeepingTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>[]
          }
          create: {
            args: Prisma.HousekeepingTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          createMany: {
            args: Prisma.HousekeepingTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HousekeepingTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>[]
          }
          delete: {
            args: Prisma.HousekeepingTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          update: {
            args: Prisma.HousekeepingTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          deleteMany: {
            args: Prisma.HousekeepingTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HousekeepingTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HousekeepingTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>[]
          }
          upsert: {
            args: Prisma.HousekeepingTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HousekeepingTaskPayload>
          }
          aggregate: {
            args: Prisma.HousekeepingTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHousekeepingTask>
          }
          groupBy: {
            args: Prisma.HousekeepingTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.HousekeepingTaskCountArgs<ExtArgs>
            result: $Utils.Optional<HousekeepingTaskCountAggregateOutputType> | number
          }
        }
      }
      Issue: {
        payload: Prisma.$IssuePayload<ExtArgs>
        fields: Prisma.IssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findFirst: {
            args: Prisma.IssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          findMany: {
            args: Prisma.IssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          create: {
            args: Prisma.IssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          createMany: {
            args: Prisma.IssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          delete: {
            args: Prisma.IssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          update: {
            args: Prisma.IssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          deleteMany: {
            args: Prisma.IssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>[]
          }
          upsert: {
            args: Prisma.IssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssuePayload>
          }
          aggregate: {
            args: Prisma.IssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssue>
          }
          groupBy: {
            args: Prisma.IssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueCountArgs<ExtArgs>
            result: $Utils.Optional<IssueCountAggregateOutputType> | number
          }
        }
      }
      IssueComment: {
        payload: Prisma.$IssueCommentPayload<ExtArgs>
        fields: Prisma.IssueCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          findFirst: {
            args: Prisma.IssueCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          findMany: {
            args: Prisma.IssueCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>[]
          }
          create: {
            args: Prisma.IssueCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          createMany: {
            args: Prisma.IssueCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssueCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>[]
          }
          delete: {
            args: Prisma.IssueCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          update: {
            args: Prisma.IssueCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          deleteMany: {
            args: Prisma.IssueCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssueCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssueCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>[]
          }
          upsert: {
            args: Prisma.IssueCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueCommentPayload>
          }
          aggregate: {
            args: Prisma.IssueCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssueComment>
          }
          groupBy: {
            args: Prisma.IssueCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueCommentCountArgs<ExtArgs>
            result: $Utils.Optional<IssueCommentCountAggregateOutputType> | number
          }
        }
      }
      IssueAttachment: {
        payload: Prisma.$IssueAttachmentPayload<ExtArgs>
        fields: Prisma.IssueAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IssueAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IssueAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          findFirst: {
            args: Prisma.IssueAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IssueAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          findMany: {
            args: Prisma.IssueAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>[]
          }
          create: {
            args: Prisma.IssueAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          createMany: {
            args: Prisma.IssueAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IssueAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>[]
          }
          delete: {
            args: Prisma.IssueAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          update: {
            args: Prisma.IssueAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.IssueAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IssueAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IssueAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.IssueAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IssueAttachmentPayload>
          }
          aggregate: {
            args: Prisma.IssueAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIssueAttachment>
          }
          groupBy: {
            args: Prisma.IssueAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<IssueAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.IssueAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<IssueAttachmentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    department?: DepartmentOmit
    position?: PositionOmit
    user?: UserOmit
    meetingRoom?: MeetingRoomOmit
    booking?: BookingOmit
    bookingRequiredPosition?: BookingRequiredPositionOmit
    bookingInvite?: BookingInviteOmit
    bookingNoteTaker?: BookingNoteTakerOmit
    noteTakerQueue?: NoteTakerQueueOmit
    service?: ServiceOmit
    bookingService?: BookingServiceOmit
    notification?: NotificationOmit
    noteTakerLeave?: NoteTakerLeaveOmit
    housekeepingTask?: HousekeepingTaskOmit
    issue?: IssueOmit
    issueComment?: IssueCommentOmit
    issueAttachment?: IssueAttachmentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    positions: number
    services: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | DepartmentCountOutputTypeCountPositionsArgs
    services?: boolean | DepartmentCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    users: number
    neededBy: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | PositionCountOutputTypeCountUsersArgs
    neededBy?: boolean | PositionCountOutputTypeCountNeededByArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountNeededByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequiredPositionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookingsBooked: number
    bookingInvites: number
    noteTakerAssigns: number
    notifications: number
    noteTakerLeaves: number
    housekeepingTasks: number
    reportedIssues: number
    issueComments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingsBooked?: boolean | UserCountOutputTypeCountBookingsBookedArgs
    bookingInvites?: boolean | UserCountOutputTypeCountBookingInvitesArgs
    noteTakerAssigns?: boolean | UserCountOutputTypeCountNoteTakerAssignsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    noteTakerLeaves?: boolean | UserCountOutputTypeCountNoteTakerLeavesArgs
    housekeepingTasks?: boolean | UserCountOutputTypeCountHousekeepingTasksArgs
    reportedIssues?: boolean | UserCountOutputTypeCountReportedIssuesArgs
    issueComments?: boolean | UserCountOutputTypeCountIssueCommentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsBookedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteTakerAssignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingNoteTakerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNoteTakerLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteTakerLeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHousekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportedIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIssueCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueCommentWhereInput
  }


  /**
   * Count Type MeetingRoomCountOutputType
   */

  export type MeetingRoomCountOutputType = {
    bookings: number
    issues: number
  }

  export type MeetingRoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | MeetingRoomCountOutputTypeCountBookingsArgs
    issues?: boolean | MeetingRoomCountOutputTypeCountIssuesArgs
  }

  // Custom InputTypes
  /**
   * MeetingRoomCountOutputType without action
   */
  export type MeetingRoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoomCountOutputType
     */
    select?: MeetingRoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingRoomCountOutputType without action
   */
  export type MeetingRoomCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * MeetingRoomCountOutputType without action
   */
  export type MeetingRoomCountOutputTypeCountIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    requiredPositions: number
    invites: number
    noteTakers: number
    services: number
    housekeepingTasks: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requiredPositions?: boolean | BookingCountOutputTypeCountRequiredPositionsArgs
    invites?: boolean | BookingCountOutputTypeCountInvitesArgs
    noteTakers?: boolean | BookingCountOutputTypeCountNoteTakersArgs
    services?: boolean | BookingCountOutputTypeCountServicesArgs
    housekeepingTasks?: boolean | BookingCountOutputTypeCountHousekeepingTasksArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountRequiredPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequiredPositionWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInviteWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountNoteTakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingNoteTakerWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountHousekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingTaskWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    bookingUsages: number
    housekeepingTasks: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingUsages?: boolean | ServiceCountOutputTypeCountBookingUsagesArgs
    housekeepingTasks?: boolean | ServiceCountOutputTypeCountHousekeepingTasksArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBookingUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountHousekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingTaskWhereInput
  }


  /**
   * Count Type IssueCountOutputType
   */

  export type IssueCountOutputType = {
    comments: number
    attachments: number
  }

  export type IssueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | IssueCountOutputTypeCountCommentsArgs
    attachments?: boolean | IssueCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueCountOutputType
     */
    select?: IssueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueCommentWhereInput
  }

  /**
   * IssueCountOutputType without action
   */
  export type IssueCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueAttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    positions?: boolean | Department$positionsArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    positions?: boolean | Department$positionsArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      positions: Prisma.$PositionPayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    positions<T extends Department$positionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Department$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Department$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.positions
   */
  export type Department$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Department.services
   */
  export type Department$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type PositionSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: number | null
    name: string | null
    isAdmin: boolean | null
    isNoteManager: boolean | null
    isNoteTaker: boolean | null
    isHousekeeper: boolean | null
    isHousekeepingLead: boolean | null
    description: string | null
    departmentId: number | null
  }

  export type PositionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    isAdmin: boolean | null
    isNoteManager: boolean | null
    isNoteTaker: boolean | null
    isHousekeeper: boolean | null
    isHousekeepingLead: boolean | null
    description: string | null
    departmentId: number | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    name: number
    isAdmin: number
    isNoteManager: number
    isNoteTaker: number
    isHousekeeper: number
    isHousekeepingLead: number
    description: number
    departmentId: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type PositionSumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    name?: true
    isAdmin?: true
    isNoteManager?: true
    isNoteTaker?: true
    isHousekeeper?: true
    isHousekeepingLead?: true
    description?: true
    departmentId?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    name?: true
    isAdmin?: true
    isNoteManager?: true
    isNoteTaker?: true
    isHousekeeper?: true
    isHousekeepingLead?: true
    description?: true
    departmentId?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    name?: true
    isAdmin?: true
    isNoteManager?: true
    isNoteTaker?: true
    isHousekeeper?: true
    isHousekeepingLead?: true
    description?: true
    departmentId?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: number
    name: string
    isAdmin: boolean
    isNoteManager: boolean
    isNoteTaker: boolean
    isHousekeeper: boolean
    isHousekeepingLead: boolean
    description: string | null
    departmentId: number | null
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: boolean
    departmentId?: boolean
    department?: boolean | Position$departmentArgs<ExtArgs>
    users?: boolean | Position$usersArgs<ExtArgs>
    neededBy?: boolean | Position$neededByArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: boolean
    departmentId?: boolean
    department?: boolean | Position$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: boolean
    departmentId?: boolean
    department?: boolean | Position$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    name?: boolean
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: boolean
    departmentId?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isAdmin" | "isNoteManager" | "isNoteTaker" | "isHousekeeper" | "isHousekeepingLead" | "description" | "departmentId", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Position$departmentArgs<ExtArgs>
    users?: boolean | Position$usersArgs<ExtArgs>
    neededBy?: boolean | Position$neededByArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Position$departmentArgs<ExtArgs>
  }
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Position$departmentArgs<ExtArgs>
  }

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
      neededBy: Prisma.$BookingRequiredPositionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      isAdmin: boolean
      isNoteManager: boolean
      isNoteTaker: boolean
      isHousekeeper: boolean
      isHousekeepingLead: boolean
      description: string | null
      departmentId: number | null
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Position$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Position$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Position$usersArgs<ExtArgs> = {}>(args?: Subset<T, Position$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    neededBy<T extends Position$neededByArgs<ExtArgs> = {}>(args?: Subset<T, Position$neededByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'Int'>
    readonly name: FieldRef<"Position", 'String'>
    readonly isAdmin: FieldRef<"Position", 'Boolean'>
    readonly isNoteManager: FieldRef<"Position", 'Boolean'>
    readonly isNoteTaker: FieldRef<"Position", 'Boolean'>
    readonly isHousekeeper: FieldRef<"Position", 'Boolean'>
    readonly isHousekeepingLead: FieldRef<"Position", 'Boolean'>
    readonly description: FieldRef<"Position", 'String'>
    readonly departmentId: FieldRef<"Position", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.department
   */
  export type Position$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Position.users
   */
  export type Position$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Position.neededBy
   */
  export type Position$neededByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    where?: BookingRequiredPositionWhereInput
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    cursor?: BookingRequiredPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequiredPositionScalarFieldEnum | BookingRequiredPositionScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    positionId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    positionId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    passwordHash: string | null
    fullName: string | null
    email: string | null
    positionId: number | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    passwordHash: string | null
    fullName: string | null
    email: string | null
    positionId: number | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    passwordHash: number
    fullName: number
    email: number
    positionId: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    positionId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    positionId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    fullName?: true
    email?: true
    positionId?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    fullName?: true
    email?: true
    positionId?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    passwordHash?: true
    fullName?: true
    email?: true
    positionId?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    passwordHash: string
    fullName: string
    email: string | null
    positionId: number
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    fullName?: boolean
    email?: boolean
    positionId?: boolean
    createdAt?: boolean
    position?: boolean | PositionDefaultArgs<ExtArgs>
    bookingsBooked?: boolean | User$bookingsBookedArgs<ExtArgs>
    bookingInvites?: boolean | User$bookingInvitesArgs<ExtArgs>
    noteTakerAssigns?: boolean | User$noteTakerAssignsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    noteTakerQueue?: boolean | User$noteTakerQueueArgs<ExtArgs>
    noteTakerLeaves?: boolean | User$noteTakerLeavesArgs<ExtArgs>
    housekeepingTasks?: boolean | User$housekeepingTasksArgs<ExtArgs>
    reportedIssues?: boolean | User$reportedIssuesArgs<ExtArgs>
    issueComments?: boolean | User$issueCommentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    fullName?: boolean
    email?: boolean
    positionId?: boolean
    createdAt?: boolean
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    fullName?: boolean
    email?: boolean
    positionId?: boolean
    createdAt?: boolean
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    passwordHash?: boolean
    fullName?: boolean
    email?: boolean
    positionId?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "passwordHash" | "fullName" | "email" | "positionId" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    position?: boolean | PositionDefaultArgs<ExtArgs>
    bookingsBooked?: boolean | User$bookingsBookedArgs<ExtArgs>
    bookingInvites?: boolean | User$bookingInvitesArgs<ExtArgs>
    noteTakerAssigns?: boolean | User$noteTakerAssignsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    noteTakerQueue?: boolean | User$noteTakerQueueArgs<ExtArgs>
    noteTakerLeaves?: boolean | User$noteTakerLeavesArgs<ExtArgs>
    housekeepingTasks?: boolean | User$housekeepingTasksArgs<ExtArgs>
    reportedIssues?: boolean | User$reportedIssuesArgs<ExtArgs>
    issueComments?: boolean | User$issueCommentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      position: Prisma.$PositionPayload<ExtArgs>
      bookingsBooked: Prisma.$BookingPayload<ExtArgs>[]
      bookingInvites: Prisma.$BookingInvitePayload<ExtArgs>[]
      noteTakerAssigns: Prisma.$BookingNoteTakerPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      noteTakerQueue: Prisma.$NoteTakerQueuePayload<ExtArgs> | null
      noteTakerLeaves: Prisma.$NoteTakerLeavePayload<ExtArgs>[]
      housekeepingTasks: Prisma.$HousekeepingTaskPayload<ExtArgs>[]
      reportedIssues: Prisma.$IssuePayload<ExtArgs>[]
      issueComments: Prisma.$IssueCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      passwordHash: string
      fullName: string
      email: string | null
      positionId: number
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    position<T extends PositionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PositionDefaultArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookingsBooked<T extends User$bookingsBookedArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsBookedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingInvites<T extends User$bookingInvitesArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingInvitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    noteTakerAssigns<T extends User$noteTakerAssignsArgs<ExtArgs> = {}>(args?: Subset<T, User$noteTakerAssignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    noteTakerQueue<T extends User$noteTakerQueueArgs<ExtArgs> = {}>(args?: Subset<T, User$noteTakerQueueArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    noteTakerLeaves<T extends User$noteTakerLeavesArgs<ExtArgs> = {}>(args?: Subset<T, User$noteTakerLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    housekeepingTasks<T extends User$housekeepingTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$housekeepingTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedIssues<T extends User$reportedIssuesArgs<ExtArgs> = {}>(args?: Subset<T, User$reportedIssuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    issueComments<T extends User$issueCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$issueCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly positionId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookingsBooked
   */
  export type User$bookingsBookedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.bookingInvites
   */
  export type User$bookingInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    where?: BookingInviteWhereInput
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    cursor?: BookingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingInviteScalarFieldEnum | BookingInviteScalarFieldEnum[]
  }

  /**
   * User.noteTakerAssigns
   */
  export type User$noteTakerAssignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    where?: BookingNoteTakerWhereInput
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    cursor?: BookingNoteTakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingNoteTakerScalarFieldEnum | BookingNoteTakerScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.noteTakerQueue
   */
  export type User$noteTakerQueueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    where?: NoteTakerQueueWhereInput
  }

  /**
   * User.noteTakerLeaves
   */
  export type User$noteTakerLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    where?: NoteTakerLeaveWhereInput
    orderBy?: NoteTakerLeaveOrderByWithRelationInput | NoteTakerLeaveOrderByWithRelationInput[]
    cursor?: NoteTakerLeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteTakerLeaveScalarFieldEnum | NoteTakerLeaveScalarFieldEnum[]
  }

  /**
   * User.housekeepingTasks
   */
  export type User$housekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    where?: HousekeepingTaskWhereInput
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    cursor?: HousekeepingTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * User.reportedIssues
   */
  export type User$reportedIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * User.issueComments
   */
  export type User$issueCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    where?: IssueCommentWhereInput
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    cursor?: IssueCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueCommentScalarFieldEnum | IssueCommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MeetingRoom
   */

  export type AggregateMeetingRoom = {
    _count: MeetingRoomCountAggregateOutputType | null
    _avg: MeetingRoomAvgAggregateOutputType | null
    _sum: MeetingRoomSumAggregateOutputType | null
    _min: MeetingRoomMinAggregateOutputType | null
    _max: MeetingRoomMaxAggregateOutputType | null
  }

  export type MeetingRoomAvgAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type MeetingRoomSumAggregateOutputType = {
    id: number | null
    capacity: number | null
  }

  export type MeetingRoomMinAggregateOutputType = {
    id: number | null
    roomName: string | null
    capacity: number | null
    status: $Enums.RoomStatus | null
  }

  export type MeetingRoomMaxAggregateOutputType = {
    id: number | null
    roomName: string | null
    capacity: number | null
    status: $Enums.RoomStatus | null
  }

  export type MeetingRoomCountAggregateOutputType = {
    id: number
    roomName: number
    capacity: number
    status: number
    _all: number
  }


  export type MeetingRoomAvgAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type MeetingRoomSumAggregateInputType = {
    id?: true
    capacity?: true
  }

  export type MeetingRoomMinAggregateInputType = {
    id?: true
    roomName?: true
    capacity?: true
    status?: true
  }

  export type MeetingRoomMaxAggregateInputType = {
    id?: true
    roomName?: true
    capacity?: true
    status?: true
  }

  export type MeetingRoomCountAggregateInputType = {
    id?: true
    roomName?: true
    capacity?: true
    status?: true
    _all?: true
  }

  export type MeetingRoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRoom to aggregate.
     */
    where?: MeetingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRooms to fetch.
     */
    orderBy?: MeetingRoomOrderByWithRelationInput | MeetingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingRooms
    **/
    _count?: true | MeetingRoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingRoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingRoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingRoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingRoomMaxAggregateInputType
  }

  export type GetMeetingRoomAggregateType<T extends MeetingRoomAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingRoom[P]>
      : GetScalarType<T[P], AggregateMeetingRoom[P]>
  }




  export type MeetingRoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRoomWhereInput
    orderBy?: MeetingRoomOrderByWithAggregationInput | MeetingRoomOrderByWithAggregationInput[]
    by: MeetingRoomScalarFieldEnum[] | MeetingRoomScalarFieldEnum
    having?: MeetingRoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingRoomCountAggregateInputType | true
    _avg?: MeetingRoomAvgAggregateInputType
    _sum?: MeetingRoomSumAggregateInputType
    _min?: MeetingRoomMinAggregateInputType
    _max?: MeetingRoomMaxAggregateInputType
  }

  export type MeetingRoomGroupByOutputType = {
    id: number
    roomName: string
    capacity: number
    status: $Enums.RoomStatus
    _count: MeetingRoomCountAggregateOutputType | null
    _avg: MeetingRoomAvgAggregateOutputType | null
    _sum: MeetingRoomSumAggregateOutputType | null
    _min: MeetingRoomMinAggregateOutputType | null
    _max: MeetingRoomMaxAggregateOutputType | null
  }

  type GetMeetingRoomGroupByPayload<T extends MeetingRoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingRoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingRoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingRoomGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingRoomGroupByOutputType[P]>
        }
      >
    >


  export type MeetingRoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    capacity?: boolean
    status?: boolean
    bookings?: boolean | MeetingRoom$bookingsArgs<ExtArgs>
    issues?: boolean | MeetingRoom$issuesArgs<ExtArgs>
    _count?: boolean | MeetingRoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRoom"]>

  export type MeetingRoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    capacity?: boolean
    status?: boolean
  }, ExtArgs["result"]["meetingRoom"]>

  export type MeetingRoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomName?: boolean
    capacity?: boolean
    status?: boolean
  }, ExtArgs["result"]["meetingRoom"]>

  export type MeetingRoomSelectScalar = {
    id?: boolean
    roomName?: boolean
    capacity?: boolean
    status?: boolean
  }

  export type MeetingRoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomName" | "capacity" | "status", ExtArgs["result"]["meetingRoom"]>
  export type MeetingRoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | MeetingRoom$bookingsArgs<ExtArgs>
    issues?: boolean | MeetingRoom$issuesArgs<ExtArgs>
    _count?: boolean | MeetingRoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingRoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MeetingRoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MeetingRoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingRoom"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      issues: Prisma.$IssuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomName: string
      capacity: number
      status: $Enums.RoomStatus
    }, ExtArgs["result"]["meetingRoom"]>
    composites: {}
  }

  type MeetingRoomGetPayload<S extends boolean | null | undefined | MeetingRoomDefaultArgs> = $Result.GetResult<Prisma.$MeetingRoomPayload, S>

  type MeetingRoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingRoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingRoomCountAggregateInputType | true
    }

  export interface MeetingRoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingRoom'], meta: { name: 'MeetingRoom' } }
    /**
     * Find zero or one MeetingRoom that matches the filter.
     * @param {MeetingRoomFindUniqueArgs} args - Arguments to find a MeetingRoom
     * @example
     * // Get one MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingRoomFindUniqueArgs>(args: SelectSubset<T, MeetingRoomFindUniqueArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeetingRoom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingRoomFindUniqueOrThrowArgs} args - Arguments to find a MeetingRoom
     * @example
     * // Get one MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingRoomFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingRoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRoom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomFindFirstArgs} args - Arguments to find a MeetingRoom
     * @example
     * // Get one MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingRoomFindFirstArgs>(args?: SelectSubset<T, MeetingRoomFindFirstArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRoom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomFindFirstOrThrowArgs} args - Arguments to find a MeetingRoom
     * @example
     * // Get one MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingRoomFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingRoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeetingRooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingRooms
     * const meetingRooms = await prisma.meetingRoom.findMany()
     * 
     * // Get first 10 MeetingRooms
     * const meetingRooms = await prisma.meetingRoom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingRoomWithIdOnly = await prisma.meetingRoom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingRoomFindManyArgs>(args?: SelectSubset<T, MeetingRoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeetingRoom.
     * @param {MeetingRoomCreateArgs} args - Arguments to create a MeetingRoom.
     * @example
     * // Create one MeetingRoom
     * const MeetingRoom = await prisma.meetingRoom.create({
     *   data: {
     *     // ... data to create a MeetingRoom
     *   }
     * })
     * 
     */
    create<T extends MeetingRoomCreateArgs>(args: SelectSubset<T, MeetingRoomCreateArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeetingRooms.
     * @param {MeetingRoomCreateManyArgs} args - Arguments to create many MeetingRooms.
     * @example
     * // Create many MeetingRooms
     * const meetingRoom = await prisma.meetingRoom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingRoomCreateManyArgs>(args?: SelectSubset<T, MeetingRoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingRooms and returns the data saved in the database.
     * @param {MeetingRoomCreateManyAndReturnArgs} args - Arguments to create many MeetingRooms.
     * @example
     * // Create many MeetingRooms
     * const meetingRoom = await prisma.meetingRoom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingRooms and only return the `id`
     * const meetingRoomWithIdOnly = await prisma.meetingRoom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingRoomCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingRoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeetingRoom.
     * @param {MeetingRoomDeleteArgs} args - Arguments to delete one MeetingRoom.
     * @example
     * // Delete one MeetingRoom
     * const MeetingRoom = await prisma.meetingRoom.delete({
     *   where: {
     *     // ... filter to delete one MeetingRoom
     *   }
     * })
     * 
     */
    delete<T extends MeetingRoomDeleteArgs>(args: SelectSubset<T, MeetingRoomDeleteArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeetingRoom.
     * @param {MeetingRoomUpdateArgs} args - Arguments to update one MeetingRoom.
     * @example
     * // Update one MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingRoomUpdateArgs>(args: SelectSubset<T, MeetingRoomUpdateArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeetingRooms.
     * @param {MeetingRoomDeleteManyArgs} args - Arguments to filter MeetingRooms to delete.
     * @example
     * // Delete a few MeetingRooms
     * const { count } = await prisma.meetingRoom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingRoomDeleteManyArgs>(args?: SelectSubset<T, MeetingRoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingRooms
     * const meetingRoom = await prisma.meetingRoom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingRoomUpdateManyArgs>(args: SelectSubset<T, MeetingRoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRooms and returns the data updated in the database.
     * @param {MeetingRoomUpdateManyAndReturnArgs} args - Arguments to update many MeetingRooms.
     * @example
     * // Update many MeetingRooms
     * const meetingRoom = await prisma.meetingRoom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeetingRooms and only return the `id`
     * const meetingRoomWithIdOnly = await prisma.meetingRoom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingRoomUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingRoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeetingRoom.
     * @param {MeetingRoomUpsertArgs} args - Arguments to update or create a MeetingRoom.
     * @example
     * // Update or create a MeetingRoom
     * const meetingRoom = await prisma.meetingRoom.upsert({
     *   create: {
     *     // ... data to create a MeetingRoom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingRoom we want to update
     *   }
     * })
     */
    upsert<T extends MeetingRoomUpsertArgs>(args: SelectSubset<T, MeetingRoomUpsertArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeetingRooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomCountArgs} args - Arguments to filter MeetingRooms to count.
     * @example
     * // Count the number of MeetingRooms
     * const count = await prisma.meetingRoom.count({
     *   where: {
     *     // ... the filter for the MeetingRooms we want to count
     *   }
     * })
    **/
    count<T extends MeetingRoomCountArgs>(
      args?: Subset<T, MeetingRoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingRoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingRoomAggregateArgs>(args: Subset<T, MeetingRoomAggregateArgs>): Prisma.PrismaPromise<GetMeetingRoomAggregateType<T>>

    /**
     * Group by MeetingRoom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingRoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingRoomGroupByArgs['orderBy'] }
        : { orderBy?: MeetingRoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingRoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingRoom model
   */
  readonly fields: MeetingRoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingRoom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingRoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends MeetingRoom$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, MeetingRoom$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    issues<T extends MeetingRoom$issuesArgs<ExtArgs> = {}>(args?: Subset<T, MeetingRoom$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingRoom model
   */
  interface MeetingRoomFieldRefs {
    readonly id: FieldRef<"MeetingRoom", 'Int'>
    readonly roomName: FieldRef<"MeetingRoom", 'String'>
    readonly capacity: FieldRef<"MeetingRoom", 'Int'>
    readonly status: FieldRef<"MeetingRoom", 'RoomStatus'>
  }
    

  // Custom InputTypes
  /**
   * MeetingRoom findUnique
   */
  export type MeetingRoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRoom to fetch.
     */
    where: MeetingRoomWhereUniqueInput
  }

  /**
   * MeetingRoom findUniqueOrThrow
   */
  export type MeetingRoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRoom to fetch.
     */
    where: MeetingRoomWhereUniqueInput
  }

  /**
   * MeetingRoom findFirst
   */
  export type MeetingRoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRoom to fetch.
     */
    where?: MeetingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRooms to fetch.
     */
    orderBy?: MeetingRoomOrderByWithRelationInput | MeetingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRooms.
     */
    cursor?: MeetingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRooms.
     */
    distinct?: MeetingRoomScalarFieldEnum | MeetingRoomScalarFieldEnum[]
  }

  /**
   * MeetingRoom findFirstOrThrow
   */
  export type MeetingRoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRoom to fetch.
     */
    where?: MeetingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRooms to fetch.
     */
    orderBy?: MeetingRoomOrderByWithRelationInput | MeetingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRooms.
     */
    cursor?: MeetingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRooms.
     */
    distinct?: MeetingRoomScalarFieldEnum | MeetingRoomScalarFieldEnum[]
  }

  /**
   * MeetingRoom findMany
   */
  export type MeetingRoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRooms to fetch.
     */
    where?: MeetingRoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRooms to fetch.
     */
    orderBy?: MeetingRoomOrderByWithRelationInput | MeetingRoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingRooms.
     */
    cursor?: MeetingRoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRooms.
     */
    skip?: number
    distinct?: MeetingRoomScalarFieldEnum | MeetingRoomScalarFieldEnum[]
  }

  /**
   * MeetingRoom create
   */
  export type MeetingRoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingRoom.
     */
    data: XOR<MeetingRoomCreateInput, MeetingRoomUncheckedCreateInput>
  }

  /**
   * MeetingRoom createMany
   */
  export type MeetingRoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingRooms.
     */
    data: MeetingRoomCreateManyInput | MeetingRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingRoom createManyAndReturn
   */
  export type MeetingRoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * The data used to create many MeetingRooms.
     */
    data: MeetingRoomCreateManyInput | MeetingRoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingRoom update
   */
  export type MeetingRoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingRoom.
     */
    data: XOR<MeetingRoomUpdateInput, MeetingRoomUncheckedUpdateInput>
    /**
     * Choose, which MeetingRoom to update.
     */
    where: MeetingRoomWhereUniqueInput
  }

  /**
   * MeetingRoom updateMany
   */
  export type MeetingRoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingRooms.
     */
    data: XOR<MeetingRoomUpdateManyMutationInput, MeetingRoomUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRooms to update
     */
    where?: MeetingRoomWhereInput
    /**
     * Limit how many MeetingRooms to update.
     */
    limit?: number
  }

  /**
   * MeetingRoom updateManyAndReturn
   */
  export type MeetingRoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * The data used to update MeetingRooms.
     */
    data: XOR<MeetingRoomUpdateManyMutationInput, MeetingRoomUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRooms to update
     */
    where?: MeetingRoomWhereInput
    /**
     * Limit how many MeetingRooms to update.
     */
    limit?: number
  }

  /**
   * MeetingRoom upsert
   */
  export type MeetingRoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingRoom to update in case it exists.
     */
    where: MeetingRoomWhereUniqueInput
    /**
     * In case the MeetingRoom found by the `where` argument doesn't exist, create a new MeetingRoom with this data.
     */
    create: XOR<MeetingRoomCreateInput, MeetingRoomUncheckedCreateInput>
    /**
     * In case the MeetingRoom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingRoomUpdateInput, MeetingRoomUncheckedUpdateInput>
  }

  /**
   * MeetingRoom delete
   */
  export type MeetingRoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    /**
     * Filter which MeetingRoom to delete.
     */
    where: MeetingRoomWhereUniqueInput
  }

  /**
   * MeetingRoom deleteMany
   */
  export type MeetingRoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRooms to delete
     */
    where?: MeetingRoomWhereInput
    /**
     * Limit how many MeetingRooms to delete.
     */
    limit?: number
  }

  /**
   * MeetingRoom.bookings
   */
  export type MeetingRoom$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * MeetingRoom.issues
   */
  export type MeetingRoom$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    cursor?: IssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * MeetingRoom without action
   */
  export type MeetingRoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    roomId: number | null
    bookedById: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    roomId: number | null
    bookedById: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    roomId: number | null
    bookedById: number | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.BookingStatus | null
    purpose: string | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    roomId: number | null
    bookedById: number | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.BookingStatus | null
    purpose: string | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    roomId: number
    bookedById: number
    startTime: number
    endTime: number
    status: number
    purpose: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    roomId?: true
    bookedById?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    roomId?: true
    bookedById?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    roomId?: true
    bookedById?: true
    startTime?: true
    endTime?: true
    status?: true
    purpose?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    roomId?: true
    bookedById?: true
    startTime?: true
    endTime?: true
    status?: true
    purpose?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    roomId?: true
    bookedById?: true
    startTime?: true
    endTime?: true
    status?: true
    purpose?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    roomId: number
    bookedById: number
    startTime: Date
    endTime: Date
    status: $Enums.BookingStatus
    purpose: string | null
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    bookedById?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    purpose?: boolean
    createdAt?: boolean
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
    requiredPositions?: boolean | Booking$requiredPositionsArgs<ExtArgs>
    invites?: boolean | Booking$invitesArgs<ExtArgs>
    noteTakers?: boolean | Booking$noteTakersArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    housekeepingTasks?: boolean | Booking$housekeepingTasksArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    bookedById?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    purpose?: boolean
    createdAt?: boolean
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    bookedById?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    purpose?: boolean
    createdAt?: boolean
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    roomId?: boolean
    bookedById?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    purpose?: boolean
    createdAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "bookedById" | "startTime" | "endTime" | "status" | "purpose" | "createdAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
    requiredPositions?: boolean | Booking$requiredPositionsArgs<ExtArgs>
    invites?: boolean | Booking$invitesArgs<ExtArgs>
    noteTakers?: boolean | Booking$noteTakersArgs<ExtArgs>
    services?: boolean | Booking$servicesArgs<ExtArgs>
    housekeepingTasks?: boolean | Booking$housekeepingTasksArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | MeetingRoomDefaultArgs<ExtArgs>
    bookedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      room: Prisma.$MeetingRoomPayload<ExtArgs>
      bookedBy: Prisma.$UserPayload<ExtArgs>
      requiredPositions: Prisma.$BookingRequiredPositionPayload<ExtArgs>[]
      invites: Prisma.$BookingInvitePayload<ExtArgs>[]
      noteTakers: Prisma.$BookingNoteTakerPayload<ExtArgs>[]
      services: Prisma.$BookingServicePayload<ExtArgs>[]
      housekeepingTasks: Prisma.$HousekeepingTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomId: number
      bookedById: number
      startTime: Date
      endTime: Date
      status: $Enums.BookingStatus
      purpose: string | null
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends MeetingRoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingRoomDefaultArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requiredPositions<T extends Booking$requiredPositionsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$requiredPositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends Booking$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    noteTakers<T extends Booking$noteTakersArgs<ExtArgs> = {}>(args?: Subset<T, Booking$noteTakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Booking$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    housekeepingTasks<T extends Booking$housekeepingTasksArgs<ExtArgs> = {}>(args?: Subset<T, Booking$housekeepingTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly roomId: FieldRef<"Booking", 'Int'>
    readonly bookedById: FieldRef<"Booking", 'Int'>
    readonly startTime: FieldRef<"Booking", 'DateTime'>
    readonly endTime: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly purpose: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.requiredPositions
   */
  export type Booking$requiredPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    where?: BookingRequiredPositionWhereInput
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    cursor?: BookingRequiredPositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingRequiredPositionScalarFieldEnum | BookingRequiredPositionScalarFieldEnum[]
  }

  /**
   * Booking.invites
   */
  export type Booking$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    where?: BookingInviteWhereInput
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    cursor?: BookingInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingInviteScalarFieldEnum | BookingInviteScalarFieldEnum[]
  }

  /**
   * Booking.noteTakers
   */
  export type Booking$noteTakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    where?: BookingNoteTakerWhereInput
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    cursor?: BookingNoteTakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingNoteTakerScalarFieldEnum | BookingNoteTakerScalarFieldEnum[]
  }

  /**
   * Booking.services
   */
  export type Booking$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Booking.housekeepingTasks
   */
  export type Booking$housekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    where?: HousekeepingTaskWhereInput
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    cursor?: HousekeepingTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingRequiredPosition
   */

  export type AggregateBookingRequiredPosition = {
    _count: BookingRequiredPositionCountAggregateOutputType | null
    _avg: BookingRequiredPositionAvgAggregateOutputType | null
    _sum: BookingRequiredPositionSumAggregateOutputType | null
    _min: BookingRequiredPositionMinAggregateOutputType | null
    _max: BookingRequiredPositionMaxAggregateOutputType | null
  }

  export type BookingRequiredPositionAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    positionId: number | null
  }

  export type BookingRequiredPositionSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    positionId: number | null
  }

  export type BookingRequiredPositionMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    positionId: number | null
  }

  export type BookingRequiredPositionMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    positionId: number | null
  }

  export type BookingRequiredPositionCountAggregateOutputType = {
    id: number
    bookingId: number
    positionId: number
    _all: number
  }


  export type BookingRequiredPositionAvgAggregateInputType = {
    id?: true
    bookingId?: true
    positionId?: true
  }

  export type BookingRequiredPositionSumAggregateInputType = {
    id?: true
    bookingId?: true
    positionId?: true
  }

  export type BookingRequiredPositionMinAggregateInputType = {
    id?: true
    bookingId?: true
    positionId?: true
  }

  export type BookingRequiredPositionMaxAggregateInputType = {
    id?: true
    bookingId?: true
    positionId?: true
  }

  export type BookingRequiredPositionCountAggregateInputType = {
    id?: true
    bookingId?: true
    positionId?: true
    _all?: true
  }

  export type BookingRequiredPositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequiredPosition to aggregate.
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequiredPositions to fetch.
     */
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingRequiredPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequiredPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequiredPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingRequiredPositions
    **/
    _count?: true | BookingRequiredPositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingRequiredPositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingRequiredPositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingRequiredPositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingRequiredPositionMaxAggregateInputType
  }

  export type GetBookingRequiredPositionAggregateType<T extends BookingRequiredPositionAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingRequiredPosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingRequiredPosition[P]>
      : GetScalarType<T[P], AggregateBookingRequiredPosition[P]>
  }




  export type BookingRequiredPositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingRequiredPositionWhereInput
    orderBy?: BookingRequiredPositionOrderByWithAggregationInput | BookingRequiredPositionOrderByWithAggregationInput[]
    by: BookingRequiredPositionScalarFieldEnum[] | BookingRequiredPositionScalarFieldEnum
    having?: BookingRequiredPositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingRequiredPositionCountAggregateInputType | true
    _avg?: BookingRequiredPositionAvgAggregateInputType
    _sum?: BookingRequiredPositionSumAggregateInputType
    _min?: BookingRequiredPositionMinAggregateInputType
    _max?: BookingRequiredPositionMaxAggregateInputType
  }

  export type BookingRequiredPositionGroupByOutputType = {
    id: number
    bookingId: number
    positionId: number
    _count: BookingRequiredPositionCountAggregateOutputType | null
    _avg: BookingRequiredPositionAvgAggregateOutputType | null
    _sum: BookingRequiredPositionSumAggregateOutputType | null
    _min: BookingRequiredPositionMinAggregateOutputType | null
    _max: BookingRequiredPositionMaxAggregateOutputType | null
  }

  type GetBookingRequiredPositionGroupByPayload<T extends BookingRequiredPositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingRequiredPositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingRequiredPositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingRequiredPositionGroupByOutputType[P]>
            : GetScalarType<T[P], BookingRequiredPositionGroupByOutputType[P]>
        }
      >
    >


  export type BookingRequiredPositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    positionId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequiredPosition"]>

  export type BookingRequiredPositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    positionId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequiredPosition"]>

  export type BookingRequiredPositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    positionId?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingRequiredPosition"]>

  export type BookingRequiredPositionSelectScalar = {
    id?: boolean
    bookingId?: boolean
    positionId?: boolean
  }

  export type BookingRequiredPositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "positionId", ExtArgs["result"]["bookingRequiredPosition"]>
  export type BookingRequiredPositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }
  export type BookingRequiredPositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }
  export type BookingRequiredPositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
  }

  export type $BookingRequiredPositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingRequiredPosition"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      position: Prisma.$PositionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      positionId: number
    }, ExtArgs["result"]["bookingRequiredPosition"]>
    composites: {}
  }

  type BookingRequiredPositionGetPayload<S extends boolean | null | undefined | BookingRequiredPositionDefaultArgs> = $Result.GetResult<Prisma.$BookingRequiredPositionPayload, S>

  type BookingRequiredPositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingRequiredPositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingRequiredPositionCountAggregateInputType | true
    }

  export interface BookingRequiredPositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingRequiredPosition'], meta: { name: 'BookingRequiredPosition' } }
    /**
     * Find zero or one BookingRequiredPosition that matches the filter.
     * @param {BookingRequiredPositionFindUniqueArgs} args - Arguments to find a BookingRequiredPosition
     * @example
     * // Get one BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingRequiredPositionFindUniqueArgs>(args: SelectSubset<T, BookingRequiredPositionFindUniqueArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingRequiredPosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingRequiredPositionFindUniqueOrThrowArgs} args - Arguments to find a BookingRequiredPosition
     * @example
     * // Get one BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingRequiredPositionFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingRequiredPositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRequiredPosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionFindFirstArgs} args - Arguments to find a BookingRequiredPosition
     * @example
     * // Get one BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingRequiredPositionFindFirstArgs>(args?: SelectSubset<T, BookingRequiredPositionFindFirstArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingRequiredPosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionFindFirstOrThrowArgs} args - Arguments to find a BookingRequiredPosition
     * @example
     * // Get one BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingRequiredPositionFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingRequiredPositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingRequiredPositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingRequiredPositions
     * const bookingRequiredPositions = await prisma.bookingRequiredPosition.findMany()
     * 
     * // Get first 10 BookingRequiredPositions
     * const bookingRequiredPositions = await prisma.bookingRequiredPosition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingRequiredPositionWithIdOnly = await prisma.bookingRequiredPosition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingRequiredPositionFindManyArgs>(args?: SelectSubset<T, BookingRequiredPositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingRequiredPosition.
     * @param {BookingRequiredPositionCreateArgs} args - Arguments to create a BookingRequiredPosition.
     * @example
     * // Create one BookingRequiredPosition
     * const BookingRequiredPosition = await prisma.bookingRequiredPosition.create({
     *   data: {
     *     // ... data to create a BookingRequiredPosition
     *   }
     * })
     * 
     */
    create<T extends BookingRequiredPositionCreateArgs>(args: SelectSubset<T, BookingRequiredPositionCreateArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingRequiredPositions.
     * @param {BookingRequiredPositionCreateManyArgs} args - Arguments to create many BookingRequiredPositions.
     * @example
     * // Create many BookingRequiredPositions
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingRequiredPositionCreateManyArgs>(args?: SelectSubset<T, BookingRequiredPositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingRequiredPositions and returns the data saved in the database.
     * @param {BookingRequiredPositionCreateManyAndReturnArgs} args - Arguments to create many BookingRequiredPositions.
     * @example
     * // Create many BookingRequiredPositions
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingRequiredPositions and only return the `id`
     * const bookingRequiredPositionWithIdOnly = await prisma.bookingRequiredPosition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingRequiredPositionCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingRequiredPositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingRequiredPosition.
     * @param {BookingRequiredPositionDeleteArgs} args - Arguments to delete one BookingRequiredPosition.
     * @example
     * // Delete one BookingRequiredPosition
     * const BookingRequiredPosition = await prisma.bookingRequiredPosition.delete({
     *   where: {
     *     // ... filter to delete one BookingRequiredPosition
     *   }
     * })
     * 
     */
    delete<T extends BookingRequiredPositionDeleteArgs>(args: SelectSubset<T, BookingRequiredPositionDeleteArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingRequiredPosition.
     * @param {BookingRequiredPositionUpdateArgs} args - Arguments to update one BookingRequiredPosition.
     * @example
     * // Update one BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingRequiredPositionUpdateArgs>(args: SelectSubset<T, BookingRequiredPositionUpdateArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingRequiredPositions.
     * @param {BookingRequiredPositionDeleteManyArgs} args - Arguments to filter BookingRequiredPositions to delete.
     * @example
     * // Delete a few BookingRequiredPositions
     * const { count } = await prisma.bookingRequiredPosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingRequiredPositionDeleteManyArgs>(args?: SelectSubset<T, BookingRequiredPositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRequiredPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingRequiredPositions
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingRequiredPositionUpdateManyArgs>(args: SelectSubset<T, BookingRequiredPositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingRequiredPositions and returns the data updated in the database.
     * @param {BookingRequiredPositionUpdateManyAndReturnArgs} args - Arguments to update many BookingRequiredPositions.
     * @example
     * // Update many BookingRequiredPositions
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingRequiredPositions and only return the `id`
     * const bookingRequiredPositionWithIdOnly = await prisma.bookingRequiredPosition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingRequiredPositionUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingRequiredPositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingRequiredPosition.
     * @param {BookingRequiredPositionUpsertArgs} args - Arguments to update or create a BookingRequiredPosition.
     * @example
     * // Update or create a BookingRequiredPosition
     * const bookingRequiredPosition = await prisma.bookingRequiredPosition.upsert({
     *   create: {
     *     // ... data to create a BookingRequiredPosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingRequiredPosition we want to update
     *   }
     * })
     */
    upsert<T extends BookingRequiredPositionUpsertArgs>(args: SelectSubset<T, BookingRequiredPositionUpsertArgs<ExtArgs>>): Prisma__BookingRequiredPositionClient<$Result.GetResult<Prisma.$BookingRequiredPositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingRequiredPositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionCountArgs} args - Arguments to filter BookingRequiredPositions to count.
     * @example
     * // Count the number of BookingRequiredPositions
     * const count = await prisma.bookingRequiredPosition.count({
     *   where: {
     *     // ... the filter for the BookingRequiredPositions we want to count
     *   }
     * })
    **/
    count<T extends BookingRequiredPositionCountArgs>(
      args?: Subset<T, BookingRequiredPositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingRequiredPositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingRequiredPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingRequiredPositionAggregateArgs>(args: Subset<T, BookingRequiredPositionAggregateArgs>): Prisma.PrismaPromise<GetBookingRequiredPositionAggregateType<T>>

    /**
     * Group by BookingRequiredPosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingRequiredPositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingRequiredPositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingRequiredPositionGroupByArgs['orderBy'] }
        : { orderBy?: BookingRequiredPositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingRequiredPositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingRequiredPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingRequiredPosition model
   */
  readonly fields: BookingRequiredPositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingRequiredPosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingRequiredPositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends PositionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PositionDefaultArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingRequiredPosition model
   */
  interface BookingRequiredPositionFieldRefs {
    readonly id: FieldRef<"BookingRequiredPosition", 'Int'>
    readonly bookingId: FieldRef<"BookingRequiredPosition", 'Int'>
    readonly positionId: FieldRef<"BookingRequiredPosition", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BookingRequiredPosition findUnique
   */
  export type BookingRequiredPositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequiredPosition to fetch.
     */
    where: BookingRequiredPositionWhereUniqueInput
  }

  /**
   * BookingRequiredPosition findUniqueOrThrow
   */
  export type BookingRequiredPositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequiredPosition to fetch.
     */
    where: BookingRequiredPositionWhereUniqueInput
  }

  /**
   * BookingRequiredPosition findFirst
   */
  export type BookingRequiredPositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequiredPosition to fetch.
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequiredPositions to fetch.
     */
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequiredPositions.
     */
    cursor?: BookingRequiredPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequiredPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequiredPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequiredPositions.
     */
    distinct?: BookingRequiredPositionScalarFieldEnum | BookingRequiredPositionScalarFieldEnum[]
  }

  /**
   * BookingRequiredPosition findFirstOrThrow
   */
  export type BookingRequiredPositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequiredPosition to fetch.
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequiredPositions to fetch.
     */
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingRequiredPositions.
     */
    cursor?: BookingRequiredPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequiredPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequiredPositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingRequiredPositions.
     */
    distinct?: BookingRequiredPositionScalarFieldEnum | BookingRequiredPositionScalarFieldEnum[]
  }

  /**
   * BookingRequiredPosition findMany
   */
  export type BookingRequiredPositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter, which BookingRequiredPositions to fetch.
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingRequiredPositions to fetch.
     */
    orderBy?: BookingRequiredPositionOrderByWithRelationInput | BookingRequiredPositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingRequiredPositions.
     */
    cursor?: BookingRequiredPositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingRequiredPositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingRequiredPositions.
     */
    skip?: number
    distinct?: BookingRequiredPositionScalarFieldEnum | BookingRequiredPositionScalarFieldEnum[]
  }

  /**
   * BookingRequiredPosition create
   */
  export type BookingRequiredPositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingRequiredPosition.
     */
    data: XOR<BookingRequiredPositionCreateInput, BookingRequiredPositionUncheckedCreateInput>
  }

  /**
   * BookingRequiredPosition createMany
   */
  export type BookingRequiredPositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingRequiredPositions.
     */
    data: BookingRequiredPositionCreateManyInput | BookingRequiredPositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingRequiredPosition createManyAndReturn
   */
  export type BookingRequiredPositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * The data used to create many BookingRequiredPositions.
     */
    data: BookingRequiredPositionCreateManyInput | BookingRequiredPositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRequiredPosition update
   */
  export type BookingRequiredPositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingRequiredPosition.
     */
    data: XOR<BookingRequiredPositionUpdateInput, BookingRequiredPositionUncheckedUpdateInput>
    /**
     * Choose, which BookingRequiredPosition to update.
     */
    where: BookingRequiredPositionWhereUniqueInput
  }

  /**
   * BookingRequiredPosition updateMany
   */
  export type BookingRequiredPositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingRequiredPositions.
     */
    data: XOR<BookingRequiredPositionUpdateManyMutationInput, BookingRequiredPositionUncheckedUpdateManyInput>
    /**
     * Filter which BookingRequiredPositions to update
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * Limit how many BookingRequiredPositions to update.
     */
    limit?: number
  }

  /**
   * BookingRequiredPosition updateManyAndReturn
   */
  export type BookingRequiredPositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * The data used to update BookingRequiredPositions.
     */
    data: XOR<BookingRequiredPositionUpdateManyMutationInput, BookingRequiredPositionUncheckedUpdateManyInput>
    /**
     * Filter which BookingRequiredPositions to update
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * Limit how many BookingRequiredPositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingRequiredPosition upsert
   */
  export type BookingRequiredPositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingRequiredPosition to update in case it exists.
     */
    where: BookingRequiredPositionWhereUniqueInput
    /**
     * In case the BookingRequiredPosition found by the `where` argument doesn't exist, create a new BookingRequiredPosition with this data.
     */
    create: XOR<BookingRequiredPositionCreateInput, BookingRequiredPositionUncheckedCreateInput>
    /**
     * In case the BookingRequiredPosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingRequiredPositionUpdateInput, BookingRequiredPositionUncheckedUpdateInput>
  }

  /**
   * BookingRequiredPosition delete
   */
  export type BookingRequiredPositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
    /**
     * Filter which BookingRequiredPosition to delete.
     */
    where: BookingRequiredPositionWhereUniqueInput
  }

  /**
   * BookingRequiredPosition deleteMany
   */
  export type BookingRequiredPositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingRequiredPositions to delete
     */
    where?: BookingRequiredPositionWhereInput
    /**
     * Limit how many BookingRequiredPositions to delete.
     */
    limit?: number
  }

  /**
   * BookingRequiredPosition without action
   */
  export type BookingRequiredPositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingRequiredPosition
     */
    select?: BookingRequiredPositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingRequiredPosition
     */
    omit?: BookingRequiredPositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingRequiredPositionInclude<ExtArgs> | null
  }


  /**
   * Model BookingInvite
   */

  export type AggregateBookingInvite = {
    _count: BookingInviteCountAggregateOutputType | null
    _avg: BookingInviteAvgAggregateOutputType | null
    _sum: BookingInviteSumAggregateOutputType | null
    _min: BookingInviteMinAggregateOutputType | null
    _max: BookingInviteMaxAggregateOutputType | null
  }

  export type BookingInviteAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
  }

  export type BookingInviteSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
  }

  export type BookingInviteMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    status: $Enums.InviteStatus | null
    respondedAt: Date | null
  }

  export type BookingInviteMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    status: $Enums.InviteStatus | null
    respondedAt: Date | null
  }

  export type BookingInviteCountAggregateOutputType = {
    id: number
    bookingId: number
    userId: number
    status: number
    respondedAt: number
    _all: number
  }


  export type BookingInviteAvgAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
  }

  export type BookingInviteSumAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
  }

  export type BookingInviteMinAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    status?: true
    respondedAt?: true
  }

  export type BookingInviteMaxAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    status?: true
    respondedAt?: true
  }

  export type BookingInviteCountAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    status?: true
    respondedAt?: true
    _all?: true
  }

  export type BookingInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingInvite to aggregate.
     */
    where?: BookingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInvites to fetch.
     */
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingInvites
    **/
    _count?: true | BookingInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingInviteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingInviteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingInviteMaxAggregateInputType
  }

  export type GetBookingInviteAggregateType<T extends BookingInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingInvite[P]>
      : GetScalarType<T[P], AggregateBookingInvite[P]>
  }




  export type BookingInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingInviteWhereInput
    orderBy?: BookingInviteOrderByWithAggregationInput | BookingInviteOrderByWithAggregationInput[]
    by: BookingInviteScalarFieldEnum[] | BookingInviteScalarFieldEnum
    having?: BookingInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingInviteCountAggregateInputType | true
    _avg?: BookingInviteAvgAggregateInputType
    _sum?: BookingInviteSumAggregateInputType
    _min?: BookingInviteMinAggregateInputType
    _max?: BookingInviteMaxAggregateInputType
  }

  export type BookingInviteGroupByOutputType = {
    id: number
    bookingId: number
    userId: number
    status: $Enums.InviteStatus
    respondedAt: Date | null
    _count: BookingInviteCountAggregateOutputType | null
    _avg: BookingInviteAvgAggregateOutputType | null
    _sum: BookingInviteSumAggregateOutputType | null
    _min: BookingInviteMinAggregateOutputType | null
    _max: BookingInviteMaxAggregateOutputType | null
  }

  type GetBookingInviteGroupByPayload<T extends BookingInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingInviteGroupByOutputType[P]>
            : GetScalarType<T[P], BookingInviteGroupByOutputType[P]>
        }
      >
    >


  export type BookingInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    status?: boolean
    respondedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInvite"]>

  export type BookingInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    status?: boolean
    respondedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInvite"]>

  export type BookingInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    status?: boolean
    respondedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingInvite"]>

  export type BookingInviteSelectScalar = {
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    status?: boolean
    respondedAt?: boolean
  }

  export type BookingInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "userId" | "status" | "respondedAt", ExtArgs["result"]["bookingInvite"]>
  export type BookingInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingInviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingInvite"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      userId: number
      status: $Enums.InviteStatus
      respondedAt: Date | null
    }, ExtArgs["result"]["bookingInvite"]>
    composites: {}
  }

  type BookingInviteGetPayload<S extends boolean | null | undefined | BookingInviteDefaultArgs> = $Result.GetResult<Prisma.$BookingInvitePayload, S>

  type BookingInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingInviteCountAggregateInputType | true
    }

  export interface BookingInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingInvite'], meta: { name: 'BookingInvite' } }
    /**
     * Find zero or one BookingInvite that matches the filter.
     * @param {BookingInviteFindUniqueArgs} args - Arguments to find a BookingInvite
     * @example
     * // Get one BookingInvite
     * const bookingInvite = await prisma.bookingInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingInviteFindUniqueArgs>(args: SelectSubset<T, BookingInviteFindUniqueArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingInviteFindUniqueOrThrowArgs} args - Arguments to find a BookingInvite
     * @example
     * // Get one BookingInvite
     * const bookingInvite = await prisma.bookingInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteFindFirstArgs} args - Arguments to find a BookingInvite
     * @example
     * // Get one BookingInvite
     * const bookingInvite = await prisma.bookingInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingInviteFindFirstArgs>(args?: SelectSubset<T, BookingInviteFindFirstArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteFindFirstOrThrowArgs} args - Arguments to find a BookingInvite
     * @example
     * // Get one BookingInvite
     * const bookingInvite = await prisma.bookingInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingInvites
     * const bookingInvites = await prisma.bookingInvite.findMany()
     * 
     * // Get first 10 BookingInvites
     * const bookingInvites = await prisma.bookingInvite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingInviteWithIdOnly = await prisma.bookingInvite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingInviteFindManyArgs>(args?: SelectSubset<T, BookingInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingInvite.
     * @param {BookingInviteCreateArgs} args - Arguments to create a BookingInvite.
     * @example
     * // Create one BookingInvite
     * const BookingInvite = await prisma.bookingInvite.create({
     *   data: {
     *     // ... data to create a BookingInvite
     *   }
     * })
     * 
     */
    create<T extends BookingInviteCreateArgs>(args: SelectSubset<T, BookingInviteCreateArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingInvites.
     * @param {BookingInviteCreateManyArgs} args - Arguments to create many BookingInvites.
     * @example
     * // Create many BookingInvites
     * const bookingInvite = await prisma.bookingInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingInviteCreateManyArgs>(args?: SelectSubset<T, BookingInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingInvites and returns the data saved in the database.
     * @param {BookingInviteCreateManyAndReturnArgs} args - Arguments to create many BookingInvites.
     * @example
     * // Create many BookingInvites
     * const bookingInvite = await prisma.bookingInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingInvites and only return the `id`
     * const bookingInviteWithIdOnly = await prisma.bookingInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingInvite.
     * @param {BookingInviteDeleteArgs} args - Arguments to delete one BookingInvite.
     * @example
     * // Delete one BookingInvite
     * const BookingInvite = await prisma.bookingInvite.delete({
     *   where: {
     *     // ... filter to delete one BookingInvite
     *   }
     * })
     * 
     */
    delete<T extends BookingInviteDeleteArgs>(args: SelectSubset<T, BookingInviteDeleteArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingInvite.
     * @param {BookingInviteUpdateArgs} args - Arguments to update one BookingInvite.
     * @example
     * // Update one BookingInvite
     * const bookingInvite = await prisma.bookingInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingInviteUpdateArgs>(args: SelectSubset<T, BookingInviteUpdateArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingInvites.
     * @param {BookingInviteDeleteManyArgs} args - Arguments to filter BookingInvites to delete.
     * @example
     * // Delete a few BookingInvites
     * const { count } = await prisma.bookingInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingInviteDeleteManyArgs>(args?: SelectSubset<T, BookingInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingInvites
     * const bookingInvite = await prisma.bookingInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingInviteUpdateManyArgs>(args: SelectSubset<T, BookingInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingInvites and returns the data updated in the database.
     * @param {BookingInviteUpdateManyAndReturnArgs} args - Arguments to update many BookingInvites.
     * @example
     * // Update many BookingInvites
     * const bookingInvite = await prisma.bookingInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingInvites and only return the `id`
     * const bookingInviteWithIdOnly = await prisma.bookingInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingInvite.
     * @param {BookingInviteUpsertArgs} args - Arguments to update or create a BookingInvite.
     * @example
     * // Update or create a BookingInvite
     * const bookingInvite = await prisma.bookingInvite.upsert({
     *   create: {
     *     // ... data to create a BookingInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingInvite we want to update
     *   }
     * })
     */
    upsert<T extends BookingInviteUpsertArgs>(args: SelectSubset<T, BookingInviteUpsertArgs<ExtArgs>>): Prisma__BookingInviteClient<$Result.GetResult<Prisma.$BookingInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteCountArgs} args - Arguments to filter BookingInvites to count.
     * @example
     * // Count the number of BookingInvites
     * const count = await prisma.bookingInvite.count({
     *   where: {
     *     // ... the filter for the BookingInvites we want to count
     *   }
     * })
    **/
    count<T extends BookingInviteCountArgs>(
      args?: Subset<T, BookingInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingInviteAggregateArgs>(args: Subset<T, BookingInviteAggregateArgs>): Prisma.PrismaPromise<GetBookingInviteAggregateType<T>>

    /**
     * Group by BookingInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingInviteGroupByArgs['orderBy'] }
        : { orderBy?: BookingInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingInvite model
   */
  readonly fields: BookingInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingInvite model
   */
  interface BookingInviteFieldRefs {
    readonly id: FieldRef<"BookingInvite", 'Int'>
    readonly bookingId: FieldRef<"BookingInvite", 'Int'>
    readonly userId: FieldRef<"BookingInvite", 'Int'>
    readonly status: FieldRef<"BookingInvite", 'InviteStatus'>
    readonly respondedAt: FieldRef<"BookingInvite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingInvite findUnique
   */
  export type BookingInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter, which BookingInvite to fetch.
     */
    where: BookingInviteWhereUniqueInput
  }

  /**
   * BookingInvite findUniqueOrThrow
   */
  export type BookingInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter, which BookingInvite to fetch.
     */
    where: BookingInviteWhereUniqueInput
  }

  /**
   * BookingInvite findFirst
   */
  export type BookingInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter, which BookingInvite to fetch.
     */
    where?: BookingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInvites to fetch.
     */
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingInvites.
     */
    cursor?: BookingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingInvites.
     */
    distinct?: BookingInviteScalarFieldEnum | BookingInviteScalarFieldEnum[]
  }

  /**
   * BookingInvite findFirstOrThrow
   */
  export type BookingInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter, which BookingInvite to fetch.
     */
    where?: BookingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInvites to fetch.
     */
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingInvites.
     */
    cursor?: BookingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingInvites.
     */
    distinct?: BookingInviteScalarFieldEnum | BookingInviteScalarFieldEnum[]
  }

  /**
   * BookingInvite findMany
   */
  export type BookingInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter, which BookingInvites to fetch.
     */
    where?: BookingInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingInvites to fetch.
     */
    orderBy?: BookingInviteOrderByWithRelationInput | BookingInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingInvites.
     */
    cursor?: BookingInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingInvites.
     */
    skip?: number
    distinct?: BookingInviteScalarFieldEnum | BookingInviteScalarFieldEnum[]
  }

  /**
   * BookingInvite create
   */
  export type BookingInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingInvite.
     */
    data: XOR<BookingInviteCreateInput, BookingInviteUncheckedCreateInput>
  }

  /**
   * BookingInvite createMany
   */
  export type BookingInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingInvites.
     */
    data: BookingInviteCreateManyInput | BookingInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingInvite createManyAndReturn
   */
  export type BookingInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * The data used to create many BookingInvites.
     */
    data: BookingInviteCreateManyInput | BookingInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingInvite update
   */
  export type BookingInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingInvite.
     */
    data: XOR<BookingInviteUpdateInput, BookingInviteUncheckedUpdateInput>
    /**
     * Choose, which BookingInvite to update.
     */
    where: BookingInviteWhereUniqueInput
  }

  /**
   * BookingInvite updateMany
   */
  export type BookingInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingInvites.
     */
    data: XOR<BookingInviteUpdateManyMutationInput, BookingInviteUncheckedUpdateManyInput>
    /**
     * Filter which BookingInvites to update
     */
    where?: BookingInviteWhereInput
    /**
     * Limit how many BookingInvites to update.
     */
    limit?: number
  }

  /**
   * BookingInvite updateManyAndReturn
   */
  export type BookingInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * The data used to update BookingInvites.
     */
    data: XOR<BookingInviteUpdateManyMutationInput, BookingInviteUncheckedUpdateManyInput>
    /**
     * Filter which BookingInvites to update
     */
    where?: BookingInviteWhereInput
    /**
     * Limit how many BookingInvites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingInvite upsert
   */
  export type BookingInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingInvite to update in case it exists.
     */
    where: BookingInviteWhereUniqueInput
    /**
     * In case the BookingInvite found by the `where` argument doesn't exist, create a new BookingInvite with this data.
     */
    create: XOR<BookingInviteCreateInput, BookingInviteUncheckedCreateInput>
    /**
     * In case the BookingInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingInviteUpdateInput, BookingInviteUncheckedUpdateInput>
  }

  /**
   * BookingInvite delete
   */
  export type BookingInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
    /**
     * Filter which BookingInvite to delete.
     */
    where: BookingInviteWhereUniqueInput
  }

  /**
   * BookingInvite deleteMany
   */
  export type BookingInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingInvites to delete
     */
    where?: BookingInviteWhereInput
    /**
     * Limit how many BookingInvites to delete.
     */
    limit?: number
  }

  /**
   * BookingInvite without action
   */
  export type BookingInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingInvite
     */
    select?: BookingInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingInvite
     */
    omit?: BookingInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInviteInclude<ExtArgs> | null
  }


  /**
   * Model BookingNoteTaker
   */

  export type AggregateBookingNoteTaker = {
    _count: BookingNoteTakerCountAggregateOutputType | null
    _avg: BookingNoteTakerAvgAggregateOutputType | null
    _sum: BookingNoteTakerSumAggregateOutputType | null
    _min: BookingNoteTakerMinAggregateOutputType | null
    _max: BookingNoteTakerMaxAggregateOutputType | null
  }

  export type BookingNoteTakerAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    roleIndex: number | null
  }

  export type BookingNoteTakerSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    roleIndex: number | null
  }

  export type BookingNoteTakerMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    roleIndex: number | null
    status: $Enums.NoteQueueStatus | null
  }

  export type BookingNoteTakerMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    roleIndex: number | null
    status: $Enums.NoteQueueStatus | null
  }

  export type BookingNoteTakerCountAggregateOutputType = {
    id: number
    bookingId: number
    userId: number
    roleIndex: number
    status: number
    _all: number
  }


  export type BookingNoteTakerAvgAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    roleIndex?: true
  }

  export type BookingNoteTakerSumAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    roleIndex?: true
  }

  export type BookingNoteTakerMinAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    roleIndex?: true
    status?: true
  }

  export type BookingNoteTakerMaxAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    roleIndex?: true
    status?: true
  }

  export type BookingNoteTakerCountAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    roleIndex?: true
    status?: true
    _all?: true
  }

  export type BookingNoteTakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingNoteTaker to aggregate.
     */
    where?: BookingNoteTakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingNoteTakers to fetch.
     */
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingNoteTakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingNoteTakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingNoteTakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingNoteTakers
    **/
    _count?: true | BookingNoteTakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingNoteTakerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingNoteTakerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingNoteTakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingNoteTakerMaxAggregateInputType
  }

  export type GetBookingNoteTakerAggregateType<T extends BookingNoteTakerAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingNoteTaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingNoteTaker[P]>
      : GetScalarType<T[P], AggregateBookingNoteTaker[P]>
  }




  export type BookingNoteTakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingNoteTakerWhereInput
    orderBy?: BookingNoteTakerOrderByWithAggregationInput | BookingNoteTakerOrderByWithAggregationInput[]
    by: BookingNoteTakerScalarFieldEnum[] | BookingNoteTakerScalarFieldEnum
    having?: BookingNoteTakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingNoteTakerCountAggregateInputType | true
    _avg?: BookingNoteTakerAvgAggregateInputType
    _sum?: BookingNoteTakerSumAggregateInputType
    _min?: BookingNoteTakerMinAggregateInputType
    _max?: BookingNoteTakerMaxAggregateInputType
  }

  export type BookingNoteTakerGroupByOutputType = {
    id: number
    bookingId: number
    userId: number
    roleIndex: number
    status: $Enums.NoteQueueStatus
    _count: BookingNoteTakerCountAggregateOutputType | null
    _avg: BookingNoteTakerAvgAggregateOutputType | null
    _sum: BookingNoteTakerSumAggregateOutputType | null
    _min: BookingNoteTakerMinAggregateOutputType | null
    _max: BookingNoteTakerMaxAggregateOutputType | null
  }

  type GetBookingNoteTakerGroupByPayload<T extends BookingNoteTakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingNoteTakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingNoteTakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingNoteTakerGroupByOutputType[P]>
            : GetScalarType<T[P], BookingNoteTakerGroupByOutputType[P]>
        }
      >
    >


  export type BookingNoteTakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    roleIndex?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingNoteTaker"]>

  export type BookingNoteTakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    roleIndex?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingNoteTaker"]>

  export type BookingNoteTakerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    roleIndex?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingNoteTaker"]>

  export type BookingNoteTakerSelectScalar = {
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    roleIndex?: boolean
    status?: boolean
  }

  export type BookingNoteTakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "userId" | "roleIndex" | "status", ExtArgs["result"]["bookingNoteTaker"]>
  export type BookingNoteTakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingNoteTakerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingNoteTakerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingNoteTakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingNoteTaker"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      userId: number
      roleIndex: number
      status: $Enums.NoteQueueStatus
    }, ExtArgs["result"]["bookingNoteTaker"]>
    composites: {}
  }

  type BookingNoteTakerGetPayload<S extends boolean | null | undefined | BookingNoteTakerDefaultArgs> = $Result.GetResult<Prisma.$BookingNoteTakerPayload, S>

  type BookingNoteTakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingNoteTakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingNoteTakerCountAggregateInputType | true
    }

  export interface BookingNoteTakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingNoteTaker'], meta: { name: 'BookingNoteTaker' } }
    /**
     * Find zero or one BookingNoteTaker that matches the filter.
     * @param {BookingNoteTakerFindUniqueArgs} args - Arguments to find a BookingNoteTaker
     * @example
     * // Get one BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingNoteTakerFindUniqueArgs>(args: SelectSubset<T, BookingNoteTakerFindUniqueArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingNoteTaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingNoteTakerFindUniqueOrThrowArgs} args - Arguments to find a BookingNoteTaker
     * @example
     * // Get one BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingNoteTakerFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingNoteTakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingNoteTaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerFindFirstArgs} args - Arguments to find a BookingNoteTaker
     * @example
     * // Get one BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingNoteTakerFindFirstArgs>(args?: SelectSubset<T, BookingNoteTakerFindFirstArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingNoteTaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerFindFirstOrThrowArgs} args - Arguments to find a BookingNoteTaker
     * @example
     * // Get one BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingNoteTakerFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingNoteTakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingNoteTakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingNoteTakers
     * const bookingNoteTakers = await prisma.bookingNoteTaker.findMany()
     * 
     * // Get first 10 BookingNoteTakers
     * const bookingNoteTakers = await prisma.bookingNoteTaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingNoteTakerWithIdOnly = await prisma.bookingNoteTaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingNoteTakerFindManyArgs>(args?: SelectSubset<T, BookingNoteTakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingNoteTaker.
     * @param {BookingNoteTakerCreateArgs} args - Arguments to create a BookingNoteTaker.
     * @example
     * // Create one BookingNoteTaker
     * const BookingNoteTaker = await prisma.bookingNoteTaker.create({
     *   data: {
     *     // ... data to create a BookingNoteTaker
     *   }
     * })
     * 
     */
    create<T extends BookingNoteTakerCreateArgs>(args: SelectSubset<T, BookingNoteTakerCreateArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingNoteTakers.
     * @param {BookingNoteTakerCreateManyArgs} args - Arguments to create many BookingNoteTakers.
     * @example
     * // Create many BookingNoteTakers
     * const bookingNoteTaker = await prisma.bookingNoteTaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingNoteTakerCreateManyArgs>(args?: SelectSubset<T, BookingNoteTakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingNoteTakers and returns the data saved in the database.
     * @param {BookingNoteTakerCreateManyAndReturnArgs} args - Arguments to create many BookingNoteTakers.
     * @example
     * // Create many BookingNoteTakers
     * const bookingNoteTaker = await prisma.bookingNoteTaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingNoteTakers and only return the `id`
     * const bookingNoteTakerWithIdOnly = await prisma.bookingNoteTaker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingNoteTakerCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingNoteTakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingNoteTaker.
     * @param {BookingNoteTakerDeleteArgs} args - Arguments to delete one BookingNoteTaker.
     * @example
     * // Delete one BookingNoteTaker
     * const BookingNoteTaker = await prisma.bookingNoteTaker.delete({
     *   where: {
     *     // ... filter to delete one BookingNoteTaker
     *   }
     * })
     * 
     */
    delete<T extends BookingNoteTakerDeleteArgs>(args: SelectSubset<T, BookingNoteTakerDeleteArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingNoteTaker.
     * @param {BookingNoteTakerUpdateArgs} args - Arguments to update one BookingNoteTaker.
     * @example
     * // Update one BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingNoteTakerUpdateArgs>(args: SelectSubset<T, BookingNoteTakerUpdateArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingNoteTakers.
     * @param {BookingNoteTakerDeleteManyArgs} args - Arguments to filter BookingNoteTakers to delete.
     * @example
     * // Delete a few BookingNoteTakers
     * const { count } = await prisma.bookingNoteTaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingNoteTakerDeleteManyArgs>(args?: SelectSubset<T, BookingNoteTakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingNoteTakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingNoteTakers
     * const bookingNoteTaker = await prisma.bookingNoteTaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingNoteTakerUpdateManyArgs>(args: SelectSubset<T, BookingNoteTakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingNoteTakers and returns the data updated in the database.
     * @param {BookingNoteTakerUpdateManyAndReturnArgs} args - Arguments to update many BookingNoteTakers.
     * @example
     * // Update many BookingNoteTakers
     * const bookingNoteTaker = await prisma.bookingNoteTaker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingNoteTakers and only return the `id`
     * const bookingNoteTakerWithIdOnly = await prisma.bookingNoteTaker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingNoteTakerUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingNoteTakerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingNoteTaker.
     * @param {BookingNoteTakerUpsertArgs} args - Arguments to update or create a BookingNoteTaker.
     * @example
     * // Update or create a BookingNoteTaker
     * const bookingNoteTaker = await prisma.bookingNoteTaker.upsert({
     *   create: {
     *     // ... data to create a BookingNoteTaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingNoteTaker we want to update
     *   }
     * })
     */
    upsert<T extends BookingNoteTakerUpsertArgs>(args: SelectSubset<T, BookingNoteTakerUpsertArgs<ExtArgs>>): Prisma__BookingNoteTakerClient<$Result.GetResult<Prisma.$BookingNoteTakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingNoteTakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerCountArgs} args - Arguments to filter BookingNoteTakers to count.
     * @example
     * // Count the number of BookingNoteTakers
     * const count = await prisma.bookingNoteTaker.count({
     *   where: {
     *     // ... the filter for the BookingNoteTakers we want to count
     *   }
     * })
    **/
    count<T extends BookingNoteTakerCountArgs>(
      args?: Subset<T, BookingNoteTakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingNoteTakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingNoteTaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingNoteTakerAggregateArgs>(args: Subset<T, BookingNoteTakerAggregateArgs>): Prisma.PrismaPromise<GetBookingNoteTakerAggregateType<T>>

    /**
     * Group by BookingNoteTaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingNoteTakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingNoteTakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingNoteTakerGroupByArgs['orderBy'] }
        : { orderBy?: BookingNoteTakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingNoteTakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingNoteTakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingNoteTaker model
   */
  readonly fields: BookingNoteTakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingNoteTaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingNoteTakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingNoteTaker model
   */
  interface BookingNoteTakerFieldRefs {
    readonly id: FieldRef<"BookingNoteTaker", 'Int'>
    readonly bookingId: FieldRef<"BookingNoteTaker", 'Int'>
    readonly userId: FieldRef<"BookingNoteTaker", 'Int'>
    readonly roleIndex: FieldRef<"BookingNoteTaker", 'Int'>
    readonly status: FieldRef<"BookingNoteTaker", 'NoteQueueStatus'>
  }
    

  // Custom InputTypes
  /**
   * BookingNoteTaker findUnique
   */
  export type BookingNoteTakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter, which BookingNoteTaker to fetch.
     */
    where: BookingNoteTakerWhereUniqueInput
  }

  /**
   * BookingNoteTaker findUniqueOrThrow
   */
  export type BookingNoteTakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter, which BookingNoteTaker to fetch.
     */
    where: BookingNoteTakerWhereUniqueInput
  }

  /**
   * BookingNoteTaker findFirst
   */
  export type BookingNoteTakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter, which BookingNoteTaker to fetch.
     */
    where?: BookingNoteTakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingNoteTakers to fetch.
     */
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingNoteTakers.
     */
    cursor?: BookingNoteTakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingNoteTakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingNoteTakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingNoteTakers.
     */
    distinct?: BookingNoteTakerScalarFieldEnum | BookingNoteTakerScalarFieldEnum[]
  }

  /**
   * BookingNoteTaker findFirstOrThrow
   */
  export type BookingNoteTakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter, which BookingNoteTaker to fetch.
     */
    where?: BookingNoteTakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingNoteTakers to fetch.
     */
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingNoteTakers.
     */
    cursor?: BookingNoteTakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingNoteTakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingNoteTakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingNoteTakers.
     */
    distinct?: BookingNoteTakerScalarFieldEnum | BookingNoteTakerScalarFieldEnum[]
  }

  /**
   * BookingNoteTaker findMany
   */
  export type BookingNoteTakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter, which BookingNoteTakers to fetch.
     */
    where?: BookingNoteTakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingNoteTakers to fetch.
     */
    orderBy?: BookingNoteTakerOrderByWithRelationInput | BookingNoteTakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingNoteTakers.
     */
    cursor?: BookingNoteTakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingNoteTakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingNoteTakers.
     */
    skip?: number
    distinct?: BookingNoteTakerScalarFieldEnum | BookingNoteTakerScalarFieldEnum[]
  }

  /**
   * BookingNoteTaker create
   */
  export type BookingNoteTakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingNoteTaker.
     */
    data: XOR<BookingNoteTakerCreateInput, BookingNoteTakerUncheckedCreateInput>
  }

  /**
   * BookingNoteTaker createMany
   */
  export type BookingNoteTakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingNoteTakers.
     */
    data: BookingNoteTakerCreateManyInput | BookingNoteTakerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingNoteTaker createManyAndReturn
   */
  export type BookingNoteTakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * The data used to create many BookingNoteTakers.
     */
    data: BookingNoteTakerCreateManyInput | BookingNoteTakerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingNoteTaker update
   */
  export type BookingNoteTakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingNoteTaker.
     */
    data: XOR<BookingNoteTakerUpdateInput, BookingNoteTakerUncheckedUpdateInput>
    /**
     * Choose, which BookingNoteTaker to update.
     */
    where: BookingNoteTakerWhereUniqueInput
  }

  /**
   * BookingNoteTaker updateMany
   */
  export type BookingNoteTakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingNoteTakers.
     */
    data: XOR<BookingNoteTakerUpdateManyMutationInput, BookingNoteTakerUncheckedUpdateManyInput>
    /**
     * Filter which BookingNoteTakers to update
     */
    where?: BookingNoteTakerWhereInput
    /**
     * Limit how many BookingNoteTakers to update.
     */
    limit?: number
  }

  /**
   * BookingNoteTaker updateManyAndReturn
   */
  export type BookingNoteTakerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * The data used to update BookingNoteTakers.
     */
    data: XOR<BookingNoteTakerUpdateManyMutationInput, BookingNoteTakerUncheckedUpdateManyInput>
    /**
     * Filter which BookingNoteTakers to update
     */
    where?: BookingNoteTakerWhereInput
    /**
     * Limit how many BookingNoteTakers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingNoteTaker upsert
   */
  export type BookingNoteTakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingNoteTaker to update in case it exists.
     */
    where: BookingNoteTakerWhereUniqueInput
    /**
     * In case the BookingNoteTaker found by the `where` argument doesn't exist, create a new BookingNoteTaker with this data.
     */
    create: XOR<BookingNoteTakerCreateInput, BookingNoteTakerUncheckedCreateInput>
    /**
     * In case the BookingNoteTaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingNoteTakerUpdateInput, BookingNoteTakerUncheckedUpdateInput>
  }

  /**
   * BookingNoteTaker delete
   */
  export type BookingNoteTakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
    /**
     * Filter which BookingNoteTaker to delete.
     */
    where: BookingNoteTakerWhereUniqueInput
  }

  /**
   * BookingNoteTaker deleteMany
   */
  export type BookingNoteTakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingNoteTakers to delete
     */
    where?: BookingNoteTakerWhereInput
    /**
     * Limit how many BookingNoteTakers to delete.
     */
    limit?: number
  }

  /**
   * BookingNoteTaker without action
   */
  export type BookingNoteTakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingNoteTaker
     */
    select?: BookingNoteTakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingNoteTaker
     */
    omit?: BookingNoteTakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingNoteTakerInclude<ExtArgs> | null
  }


  /**
   * Model NoteTakerQueue
   */

  export type AggregateNoteTakerQueue = {
    _count: NoteTakerQueueCountAggregateOutputType | null
    _avg: NoteTakerQueueAvgAggregateOutputType | null
    _sum: NoteTakerQueueSumAggregateOutputType | null
    _min: NoteTakerQueueMinAggregateOutputType | null
    _max: NoteTakerQueueMaxAggregateOutputType | null
  }

  export type NoteTakerQueueAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    orderNo: number | null
  }

  export type NoteTakerQueueSumAggregateOutputType = {
    id: number | null
    userId: number | null
    orderNo: number | null
  }

  export type NoteTakerQueueMinAggregateOutputType = {
    id: number | null
    userId: number | null
    orderNo: number | null
    isActive: boolean | null
  }

  export type NoteTakerQueueMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    orderNo: number | null
    isActive: boolean | null
  }

  export type NoteTakerQueueCountAggregateOutputType = {
    id: number
    userId: number
    orderNo: number
    isActive: number
    _all: number
  }


  export type NoteTakerQueueAvgAggregateInputType = {
    id?: true
    userId?: true
    orderNo?: true
  }

  export type NoteTakerQueueSumAggregateInputType = {
    id?: true
    userId?: true
    orderNo?: true
  }

  export type NoteTakerQueueMinAggregateInputType = {
    id?: true
    userId?: true
    orderNo?: true
    isActive?: true
  }

  export type NoteTakerQueueMaxAggregateInputType = {
    id?: true
    userId?: true
    orderNo?: true
    isActive?: true
  }

  export type NoteTakerQueueCountAggregateInputType = {
    id?: true
    userId?: true
    orderNo?: true
    isActive?: true
    _all?: true
  }

  export type NoteTakerQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteTakerQueue to aggregate.
     */
    where?: NoteTakerQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerQueues to fetch.
     */
    orderBy?: NoteTakerQueueOrderByWithRelationInput | NoteTakerQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteTakerQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteTakerQueues
    **/
    _count?: true | NoteTakerQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteTakerQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteTakerQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteTakerQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteTakerQueueMaxAggregateInputType
  }

  export type GetNoteTakerQueueAggregateType<T extends NoteTakerQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteTakerQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteTakerQueue[P]>
      : GetScalarType<T[P], AggregateNoteTakerQueue[P]>
  }




  export type NoteTakerQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteTakerQueueWhereInput
    orderBy?: NoteTakerQueueOrderByWithAggregationInput | NoteTakerQueueOrderByWithAggregationInput[]
    by: NoteTakerQueueScalarFieldEnum[] | NoteTakerQueueScalarFieldEnum
    having?: NoteTakerQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteTakerQueueCountAggregateInputType | true
    _avg?: NoteTakerQueueAvgAggregateInputType
    _sum?: NoteTakerQueueSumAggregateInputType
    _min?: NoteTakerQueueMinAggregateInputType
    _max?: NoteTakerQueueMaxAggregateInputType
  }

  export type NoteTakerQueueGroupByOutputType = {
    id: number
    userId: number
    orderNo: number
    isActive: boolean
    _count: NoteTakerQueueCountAggregateOutputType | null
    _avg: NoteTakerQueueAvgAggregateOutputType | null
    _sum: NoteTakerQueueSumAggregateOutputType | null
    _min: NoteTakerQueueMinAggregateOutputType | null
    _max: NoteTakerQueueMaxAggregateOutputType | null
  }

  type GetNoteTakerQueueGroupByPayload<T extends NoteTakerQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteTakerQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteTakerQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteTakerQueueGroupByOutputType[P]>
            : GetScalarType<T[P], NoteTakerQueueGroupByOutputType[P]>
        }
      >
    >


  export type NoteTakerQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderNo?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerQueue"]>

  export type NoteTakerQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderNo?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerQueue"]>

  export type NoteTakerQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    orderNo?: boolean
    isActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerQueue"]>

  export type NoteTakerQueueSelectScalar = {
    id?: boolean
    userId?: boolean
    orderNo?: boolean
    isActive?: boolean
  }

  export type NoteTakerQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "orderNo" | "isActive", ExtArgs["result"]["noteTakerQueue"]>
  export type NoteTakerQueueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteTakerQueueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteTakerQueueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NoteTakerQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteTakerQueue"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      orderNo: number
      isActive: boolean
    }, ExtArgs["result"]["noteTakerQueue"]>
    composites: {}
  }

  type NoteTakerQueueGetPayload<S extends boolean | null | undefined | NoteTakerQueueDefaultArgs> = $Result.GetResult<Prisma.$NoteTakerQueuePayload, S>

  type NoteTakerQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteTakerQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteTakerQueueCountAggregateInputType | true
    }

  export interface NoteTakerQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteTakerQueue'], meta: { name: 'NoteTakerQueue' } }
    /**
     * Find zero or one NoteTakerQueue that matches the filter.
     * @param {NoteTakerQueueFindUniqueArgs} args - Arguments to find a NoteTakerQueue
     * @example
     * // Get one NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteTakerQueueFindUniqueArgs>(args: SelectSubset<T, NoteTakerQueueFindUniqueArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteTakerQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteTakerQueueFindUniqueOrThrowArgs} args - Arguments to find a NoteTakerQueue
     * @example
     * // Get one NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteTakerQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteTakerQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteTakerQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueFindFirstArgs} args - Arguments to find a NoteTakerQueue
     * @example
     * // Get one NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteTakerQueueFindFirstArgs>(args?: SelectSubset<T, NoteTakerQueueFindFirstArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteTakerQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueFindFirstOrThrowArgs} args - Arguments to find a NoteTakerQueue
     * @example
     * // Get one NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteTakerQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteTakerQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteTakerQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteTakerQueues
     * const noteTakerQueues = await prisma.noteTakerQueue.findMany()
     * 
     * // Get first 10 NoteTakerQueues
     * const noteTakerQueues = await prisma.noteTakerQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteTakerQueueWithIdOnly = await prisma.noteTakerQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteTakerQueueFindManyArgs>(args?: SelectSubset<T, NoteTakerQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteTakerQueue.
     * @param {NoteTakerQueueCreateArgs} args - Arguments to create a NoteTakerQueue.
     * @example
     * // Create one NoteTakerQueue
     * const NoteTakerQueue = await prisma.noteTakerQueue.create({
     *   data: {
     *     // ... data to create a NoteTakerQueue
     *   }
     * })
     * 
     */
    create<T extends NoteTakerQueueCreateArgs>(args: SelectSubset<T, NoteTakerQueueCreateArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteTakerQueues.
     * @param {NoteTakerQueueCreateManyArgs} args - Arguments to create many NoteTakerQueues.
     * @example
     * // Create many NoteTakerQueues
     * const noteTakerQueue = await prisma.noteTakerQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteTakerQueueCreateManyArgs>(args?: SelectSubset<T, NoteTakerQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteTakerQueues and returns the data saved in the database.
     * @param {NoteTakerQueueCreateManyAndReturnArgs} args - Arguments to create many NoteTakerQueues.
     * @example
     * // Create many NoteTakerQueues
     * const noteTakerQueue = await prisma.noteTakerQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteTakerQueues and only return the `id`
     * const noteTakerQueueWithIdOnly = await prisma.noteTakerQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteTakerQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteTakerQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteTakerQueue.
     * @param {NoteTakerQueueDeleteArgs} args - Arguments to delete one NoteTakerQueue.
     * @example
     * // Delete one NoteTakerQueue
     * const NoteTakerQueue = await prisma.noteTakerQueue.delete({
     *   where: {
     *     // ... filter to delete one NoteTakerQueue
     *   }
     * })
     * 
     */
    delete<T extends NoteTakerQueueDeleteArgs>(args: SelectSubset<T, NoteTakerQueueDeleteArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteTakerQueue.
     * @param {NoteTakerQueueUpdateArgs} args - Arguments to update one NoteTakerQueue.
     * @example
     * // Update one NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteTakerQueueUpdateArgs>(args: SelectSubset<T, NoteTakerQueueUpdateArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteTakerQueues.
     * @param {NoteTakerQueueDeleteManyArgs} args - Arguments to filter NoteTakerQueues to delete.
     * @example
     * // Delete a few NoteTakerQueues
     * const { count } = await prisma.noteTakerQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteTakerQueueDeleteManyArgs>(args?: SelectSubset<T, NoteTakerQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteTakerQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteTakerQueues
     * const noteTakerQueue = await prisma.noteTakerQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteTakerQueueUpdateManyArgs>(args: SelectSubset<T, NoteTakerQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteTakerQueues and returns the data updated in the database.
     * @param {NoteTakerQueueUpdateManyAndReturnArgs} args - Arguments to update many NoteTakerQueues.
     * @example
     * // Update many NoteTakerQueues
     * const noteTakerQueue = await prisma.noteTakerQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteTakerQueues and only return the `id`
     * const noteTakerQueueWithIdOnly = await prisma.noteTakerQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteTakerQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteTakerQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteTakerQueue.
     * @param {NoteTakerQueueUpsertArgs} args - Arguments to update or create a NoteTakerQueue.
     * @example
     * // Update or create a NoteTakerQueue
     * const noteTakerQueue = await prisma.noteTakerQueue.upsert({
     *   create: {
     *     // ... data to create a NoteTakerQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteTakerQueue we want to update
     *   }
     * })
     */
    upsert<T extends NoteTakerQueueUpsertArgs>(args: SelectSubset<T, NoteTakerQueueUpsertArgs<ExtArgs>>): Prisma__NoteTakerQueueClient<$Result.GetResult<Prisma.$NoteTakerQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteTakerQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueCountArgs} args - Arguments to filter NoteTakerQueues to count.
     * @example
     * // Count the number of NoteTakerQueues
     * const count = await prisma.noteTakerQueue.count({
     *   where: {
     *     // ... the filter for the NoteTakerQueues we want to count
     *   }
     * })
    **/
    count<T extends NoteTakerQueueCountArgs>(
      args?: Subset<T, NoteTakerQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteTakerQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteTakerQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteTakerQueueAggregateArgs>(args: Subset<T, NoteTakerQueueAggregateArgs>): Prisma.PrismaPromise<GetNoteTakerQueueAggregateType<T>>

    /**
     * Group by NoteTakerQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteTakerQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteTakerQueueGroupByArgs['orderBy'] }
        : { orderBy?: NoteTakerQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteTakerQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteTakerQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteTakerQueue model
   */
  readonly fields: NoteTakerQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteTakerQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteTakerQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteTakerQueue model
   */
  interface NoteTakerQueueFieldRefs {
    readonly id: FieldRef<"NoteTakerQueue", 'Int'>
    readonly userId: FieldRef<"NoteTakerQueue", 'Int'>
    readonly orderNo: FieldRef<"NoteTakerQueue", 'Int'>
    readonly isActive: FieldRef<"NoteTakerQueue", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NoteTakerQueue findUnique
   */
  export type NoteTakerQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerQueue to fetch.
     */
    where: NoteTakerQueueWhereUniqueInput
  }

  /**
   * NoteTakerQueue findUniqueOrThrow
   */
  export type NoteTakerQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerQueue to fetch.
     */
    where: NoteTakerQueueWhereUniqueInput
  }

  /**
   * NoteTakerQueue findFirst
   */
  export type NoteTakerQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerQueue to fetch.
     */
    where?: NoteTakerQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerQueues to fetch.
     */
    orderBy?: NoteTakerQueueOrderByWithRelationInput | NoteTakerQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTakerQueues.
     */
    cursor?: NoteTakerQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTakerQueues.
     */
    distinct?: NoteTakerQueueScalarFieldEnum | NoteTakerQueueScalarFieldEnum[]
  }

  /**
   * NoteTakerQueue findFirstOrThrow
   */
  export type NoteTakerQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerQueue to fetch.
     */
    where?: NoteTakerQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerQueues to fetch.
     */
    orderBy?: NoteTakerQueueOrderByWithRelationInput | NoteTakerQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTakerQueues.
     */
    cursor?: NoteTakerQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTakerQueues.
     */
    distinct?: NoteTakerQueueScalarFieldEnum | NoteTakerQueueScalarFieldEnum[]
  }

  /**
   * NoteTakerQueue findMany
   */
  export type NoteTakerQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerQueues to fetch.
     */
    where?: NoteTakerQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerQueues to fetch.
     */
    orderBy?: NoteTakerQueueOrderByWithRelationInput | NoteTakerQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteTakerQueues.
     */
    cursor?: NoteTakerQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerQueues.
     */
    skip?: number
    distinct?: NoteTakerQueueScalarFieldEnum | NoteTakerQueueScalarFieldEnum[]
  }

  /**
   * NoteTakerQueue create
   */
  export type NoteTakerQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteTakerQueue.
     */
    data: XOR<NoteTakerQueueCreateInput, NoteTakerQueueUncheckedCreateInput>
  }

  /**
   * NoteTakerQueue createMany
   */
  export type NoteTakerQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteTakerQueues.
     */
    data: NoteTakerQueueCreateManyInput | NoteTakerQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteTakerQueue createManyAndReturn
   */
  export type NoteTakerQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * The data used to create many NoteTakerQueues.
     */
    data: NoteTakerQueueCreateManyInput | NoteTakerQueueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteTakerQueue update
   */
  export type NoteTakerQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteTakerQueue.
     */
    data: XOR<NoteTakerQueueUpdateInput, NoteTakerQueueUncheckedUpdateInput>
    /**
     * Choose, which NoteTakerQueue to update.
     */
    where: NoteTakerQueueWhereUniqueInput
  }

  /**
   * NoteTakerQueue updateMany
   */
  export type NoteTakerQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteTakerQueues.
     */
    data: XOR<NoteTakerQueueUpdateManyMutationInput, NoteTakerQueueUncheckedUpdateManyInput>
    /**
     * Filter which NoteTakerQueues to update
     */
    where?: NoteTakerQueueWhereInput
    /**
     * Limit how many NoteTakerQueues to update.
     */
    limit?: number
  }

  /**
   * NoteTakerQueue updateManyAndReturn
   */
  export type NoteTakerQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * The data used to update NoteTakerQueues.
     */
    data: XOR<NoteTakerQueueUpdateManyMutationInput, NoteTakerQueueUncheckedUpdateManyInput>
    /**
     * Filter which NoteTakerQueues to update
     */
    where?: NoteTakerQueueWhereInput
    /**
     * Limit how many NoteTakerQueues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteTakerQueue upsert
   */
  export type NoteTakerQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteTakerQueue to update in case it exists.
     */
    where: NoteTakerQueueWhereUniqueInput
    /**
     * In case the NoteTakerQueue found by the `where` argument doesn't exist, create a new NoteTakerQueue with this data.
     */
    create: XOR<NoteTakerQueueCreateInput, NoteTakerQueueUncheckedCreateInput>
    /**
     * In case the NoteTakerQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteTakerQueueUpdateInput, NoteTakerQueueUncheckedUpdateInput>
  }

  /**
   * NoteTakerQueue delete
   */
  export type NoteTakerQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
    /**
     * Filter which NoteTakerQueue to delete.
     */
    where: NoteTakerQueueWhereUniqueInput
  }

  /**
   * NoteTakerQueue deleteMany
   */
  export type NoteTakerQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteTakerQueues to delete
     */
    where?: NoteTakerQueueWhereInput
    /**
     * Limit how many NoteTakerQueues to delete.
     */
    limit?: number
  }

  /**
   * NoteTakerQueue without action
   */
  export type NoteTakerQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerQueue
     */
    select?: NoteTakerQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerQueue
     */
    omit?: NoteTakerQueueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerQueueInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
    departmentId: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    category: $Enums.ServiceCategory | null
    departmentId: number | null
    requiresApproval: boolean | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category: $Enums.ServiceCategory | null
    departmentId: number | null
    requiresApproval: boolean | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    departmentId: number
    requiresApproval: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
    departmentId?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    requiresApproval?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    requiresApproval?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    requiresApproval?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    name: string
    category: $Enums.ServiceCategory
    departmentId: number | null
    requiresApproval: boolean
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    requiresApproval?: boolean
    department?: boolean | Service$departmentArgs<ExtArgs>
    bookingUsages?: boolean | Service$bookingUsagesArgs<ExtArgs>
    housekeepingTasks?: boolean | Service$housekeepingTasksArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    requiresApproval?: boolean
    department?: boolean | Service$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    requiresApproval?: boolean
    department?: boolean | Service$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    requiresApproval?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "departmentId" | "requiresApproval", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Service$departmentArgs<ExtArgs>
    bookingUsages?: boolean | Service$bookingUsagesArgs<ExtArgs>
    housekeepingTasks?: boolean | Service$housekeepingTasksArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Service$departmentArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Service$departmentArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      bookingUsages: Prisma.$BookingServicePayload<ExtArgs>[]
      housekeepingTasks: Prisma.$HousekeepingTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category: $Enums.ServiceCategory
      departmentId: number | null
      requiresApproval: boolean
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Service$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Service$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookingUsages<T extends Service$bookingUsagesArgs<ExtArgs> = {}>(args?: Subset<T, Service$bookingUsagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    housekeepingTasks<T extends Service$housekeepingTasksArgs<ExtArgs> = {}>(args?: Subset<T, Service$housekeepingTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly departmentId: FieldRef<"Service", 'Int'>
    readonly requiresApproval: FieldRef<"Service", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.department
   */
  export type Service$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Service.bookingUsages
   */
  export type Service$bookingUsagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    cursor?: BookingServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * Service.housekeepingTasks
   */
  export type Service$housekeepingTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    where?: HousekeepingTaskWhereInput
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    cursor?: HousekeepingTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model BookingService
   */

  export type AggregateBookingService = {
    _count: BookingServiceCountAggregateOutputType | null
    _avg: BookingServiceAvgAggregateOutputType | null
    _sum: BookingServiceSumAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  export type BookingServiceAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
  }

  export type BookingServiceMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
    status: $Enums.ServiceStatus | null
  }

  export type BookingServiceMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    quantity: number | null
    status: $Enums.ServiceStatus | null
  }

  export type BookingServiceCountAggregateOutputType = {
    id: number
    bookingId: number
    serviceId: number
    quantity: number
    status: number
    _all: number
  }


  export type BookingServiceAvgAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceSumAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
  }

  export type BookingServiceMinAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
    status?: true
  }

  export type BookingServiceMaxAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
    status?: true
  }

  export type BookingServiceCountAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    quantity?: true
    status?: true
    _all?: true
  }

  export type BookingServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingService to aggregate.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingServices
    **/
    _count?: true | BookingServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingServiceMaxAggregateInputType
  }

  export type GetBookingServiceAggregateType<T extends BookingServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingService[P]>
      : GetScalarType<T[P], AggregateBookingService[P]>
  }




  export type BookingServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingServiceWhereInput
    orderBy?: BookingServiceOrderByWithAggregationInput | BookingServiceOrderByWithAggregationInput[]
    by: BookingServiceScalarFieldEnum[] | BookingServiceScalarFieldEnum
    having?: BookingServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingServiceCountAggregateInputType | true
    _avg?: BookingServiceAvgAggregateInputType
    _sum?: BookingServiceSumAggregateInputType
    _min?: BookingServiceMinAggregateInputType
    _max?: BookingServiceMaxAggregateInputType
  }

  export type BookingServiceGroupByOutputType = {
    id: number
    bookingId: number
    serviceId: number
    quantity: number | null
    status: $Enums.ServiceStatus
    _count: BookingServiceCountAggregateOutputType | null
    _avg: BookingServiceAvgAggregateOutputType | null
    _sum: BookingServiceSumAggregateOutputType | null
    _min: BookingServiceMinAggregateOutputType | null
    _max: BookingServiceMaxAggregateOutputType | null
  }

  type GetBookingServiceGroupByPayload<T extends BookingServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BookingServiceGroupByOutputType[P]>
        }
      >
    >


  export type BookingServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
    status?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingService"]>

  export type BookingServiceSelectScalar = {
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    quantity?: boolean
    status?: boolean
  }

  export type BookingServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "serviceId" | "quantity" | "status", ExtArgs["result"]["bookingService"]>
  export type BookingServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type BookingServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $BookingServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingService"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      serviceId: number
      quantity: number | null
      status: $Enums.ServiceStatus
    }, ExtArgs["result"]["bookingService"]>
    composites: {}
  }

  type BookingServiceGetPayload<S extends boolean | null | undefined | BookingServiceDefaultArgs> = $Result.GetResult<Prisma.$BookingServicePayload, S>

  type BookingServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingServiceCountAggregateInputType | true
    }

  export interface BookingServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingService'], meta: { name: 'BookingService' } }
    /**
     * Find zero or one BookingService that matches the filter.
     * @param {BookingServiceFindUniqueArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingServiceFindUniqueArgs>(args: SelectSubset<T, BookingServiceFindUniqueArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingServiceFindUniqueOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingServiceFindFirstArgs>(args?: SelectSubset<T, BookingServiceFindFirstArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindFirstOrThrowArgs} args - Arguments to find a BookingService
     * @example
     * // Get one BookingService
     * const bookingService = await prisma.bookingService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingServices
     * const bookingServices = await prisma.bookingService.findMany()
     * 
     * // Get first 10 BookingServices
     * const bookingServices = await prisma.bookingService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingServiceWithIdOnly = await prisma.bookingService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingServiceFindManyArgs>(args?: SelectSubset<T, BookingServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingService.
     * @param {BookingServiceCreateArgs} args - Arguments to create a BookingService.
     * @example
     * // Create one BookingService
     * const BookingService = await prisma.bookingService.create({
     *   data: {
     *     // ... data to create a BookingService
     *   }
     * })
     * 
     */
    create<T extends BookingServiceCreateArgs>(args: SelectSubset<T, BookingServiceCreateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingServices.
     * @param {BookingServiceCreateManyArgs} args - Arguments to create many BookingServices.
     * @example
     * // Create many BookingServices
     * const bookingService = await prisma.bookingService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingServiceCreateManyArgs>(args?: SelectSubset<T, BookingServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingServices and returns the data saved in the database.
     * @param {BookingServiceCreateManyAndReturnArgs} args - Arguments to create many BookingServices.
     * @example
     * // Create many BookingServices
     * const bookingService = await prisma.bookingService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingServices and only return the `id`
     * const bookingServiceWithIdOnly = await prisma.bookingService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingService.
     * @param {BookingServiceDeleteArgs} args - Arguments to delete one BookingService.
     * @example
     * // Delete one BookingService
     * const BookingService = await prisma.bookingService.delete({
     *   where: {
     *     // ... filter to delete one BookingService
     *   }
     * })
     * 
     */
    delete<T extends BookingServiceDeleteArgs>(args: SelectSubset<T, BookingServiceDeleteArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingService.
     * @param {BookingServiceUpdateArgs} args - Arguments to update one BookingService.
     * @example
     * // Update one BookingService
     * const bookingService = await prisma.bookingService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingServiceUpdateArgs>(args: SelectSubset<T, BookingServiceUpdateArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingServices.
     * @param {BookingServiceDeleteManyArgs} args - Arguments to filter BookingServices to delete.
     * @example
     * // Delete a few BookingServices
     * const { count } = await prisma.bookingService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingServiceDeleteManyArgs>(args?: SelectSubset<T, BookingServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingServices
     * const bookingService = await prisma.bookingService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingServiceUpdateManyArgs>(args: SelectSubset<T, BookingServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingServices and returns the data updated in the database.
     * @param {BookingServiceUpdateManyAndReturnArgs} args - Arguments to update many BookingServices.
     * @example
     * // Update many BookingServices
     * const bookingService = await prisma.bookingService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingServices and only return the `id`
     * const bookingServiceWithIdOnly = await prisma.bookingService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingService.
     * @param {BookingServiceUpsertArgs} args - Arguments to update or create a BookingService.
     * @example
     * // Update or create a BookingService
     * const bookingService = await prisma.bookingService.upsert({
     *   create: {
     *     // ... data to create a BookingService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingService we want to update
     *   }
     * })
     */
    upsert<T extends BookingServiceUpsertArgs>(args: SelectSubset<T, BookingServiceUpsertArgs<ExtArgs>>): Prisma__BookingServiceClient<$Result.GetResult<Prisma.$BookingServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceCountArgs} args - Arguments to filter BookingServices to count.
     * @example
     * // Count the number of BookingServices
     * const count = await prisma.bookingService.count({
     *   where: {
     *     // ... the filter for the BookingServices we want to count
     *   }
     * })
    **/
    count<T extends BookingServiceCountArgs>(
      args?: Subset<T, BookingServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingServiceAggregateArgs>(args: Subset<T, BookingServiceAggregateArgs>): Prisma.PrismaPromise<GetBookingServiceAggregateType<T>>

    /**
     * Group by BookingService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingServiceGroupByArgs['orderBy'] }
        : { orderBy?: BookingServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingService model
   */
  readonly fields: BookingServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingService model
   */
  interface BookingServiceFieldRefs {
    readonly id: FieldRef<"BookingService", 'Int'>
    readonly bookingId: FieldRef<"BookingService", 'Int'>
    readonly serviceId: FieldRef<"BookingService", 'Int'>
    readonly quantity: FieldRef<"BookingService", 'Int'>
    readonly status: FieldRef<"BookingService", 'ServiceStatus'>
  }
    

  // Custom InputTypes
  /**
   * BookingService findUnique
   */
  export type BookingServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findUniqueOrThrow
   */
  export type BookingServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService findFirst
   */
  export type BookingServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findFirstOrThrow
   */
  export type BookingServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingService to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingServices.
     */
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService findMany
   */
  export type BookingServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter, which BookingServices to fetch.
     */
    where?: BookingServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingServices to fetch.
     */
    orderBy?: BookingServiceOrderByWithRelationInput | BookingServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingServices.
     */
    cursor?: BookingServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingServices.
     */
    skip?: number
    distinct?: BookingServiceScalarFieldEnum | BookingServiceScalarFieldEnum[]
  }

  /**
   * BookingService create
   */
  export type BookingServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingService.
     */
    data: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
  }

  /**
   * BookingService createMany
   */
  export type BookingServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingServices.
     */
    data: BookingServiceCreateManyInput | BookingServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingService createManyAndReturn
   */
  export type BookingServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * The data used to create many BookingServices.
     */
    data: BookingServiceCreateManyInput | BookingServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingService update
   */
  export type BookingServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingService.
     */
    data: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
    /**
     * Choose, which BookingService to update.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService updateMany
   */
  export type BookingServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingServices.
     */
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyInput>
    /**
     * Filter which BookingServices to update
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to update.
     */
    limit?: number
  }

  /**
   * BookingService updateManyAndReturn
   */
  export type BookingServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * The data used to update BookingServices.
     */
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyInput>
    /**
     * Filter which BookingServices to update
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingService upsert
   */
  export type BookingServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingService to update in case it exists.
     */
    where: BookingServiceWhereUniqueInput
    /**
     * In case the BookingService found by the `where` argument doesn't exist, create a new BookingService with this data.
     */
    create: XOR<BookingServiceCreateInput, BookingServiceUncheckedCreateInput>
    /**
     * In case the BookingService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingServiceUpdateInput, BookingServiceUncheckedUpdateInput>
  }

  /**
   * BookingService delete
   */
  export type BookingServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
    /**
     * Filter which BookingService to delete.
     */
    where: BookingServiceWhereUniqueInput
  }

  /**
   * BookingService deleteMany
   */
  export type BookingServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingServices to delete
     */
    where?: BookingServiceWhereInput
    /**
     * Limit how many BookingServices to delete.
     */
    limit?: number
  }

  /**
   * BookingService without action
   */
  export type BookingServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingService
     */
    select?: BookingServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingService
     */
    omit?: BookingServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingServiceInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    refId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
    refId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotifType | null
    title: string | null
    message: string | null
    refType: $Enums.RefType | null
    refId: number | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: $Enums.NotifType | null
    title: string | null
    message: string | null
    refType: $Enums.RefType | null
    refId: number | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    refType: number
    refId: number
    isRead: number
    createdAt: number
    readAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
    refId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
    refId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    refType?: true
    refId?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    refType?: true
    refId?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    refType?: true
    refId?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: $Enums.NotifType
    title: string
    message: string
    refType: $Enums.RefType | null
    refId: number | null
    isRead: boolean
    createdAt: Date
    readAt: Date | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    refType?: boolean
    refId?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    refType?: boolean
    refId?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    refType?: boolean
    refId?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    refType?: boolean
    refId?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "refType" | "refId" | "isRead" | "createdAt" | "readAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: $Enums.NotifType
      title: string
      message: string
      refType: $Enums.RefType | null
      refId: number | null
      isRead: boolean
      createdAt: Date
      readAt: Date | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'NotifType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly refType: FieldRef<"Notification", 'RefType'>
    readonly refId: FieldRef<"Notification", 'Int'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NoteTakerLeave
   */

  export type AggregateNoteTakerLeave = {
    _count: NoteTakerLeaveCountAggregateOutputType | null
    _avg: NoteTakerLeaveAvgAggregateOutputType | null
    _sum: NoteTakerLeaveSumAggregateOutputType | null
    _min: NoteTakerLeaveMinAggregateOutputType | null
    _max: NoteTakerLeaveMaxAggregateOutputType | null
  }

  export type NoteTakerLeaveAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoteTakerLeaveSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NoteTakerLeaveMinAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type NoteTakerLeaveMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    date: Date | null
    reason: string | null
    createdAt: Date | null
  }

  export type NoteTakerLeaveCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    reason: number
    createdAt: number
    _all: number
  }


  export type NoteTakerLeaveAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoteTakerLeaveSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NoteTakerLeaveMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    reason?: true
    createdAt?: true
  }

  export type NoteTakerLeaveMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    reason?: true
    createdAt?: true
  }

  export type NoteTakerLeaveCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type NoteTakerLeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteTakerLeave to aggregate.
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerLeaves to fetch.
     */
    orderBy?: NoteTakerLeaveOrderByWithRelationInput | NoteTakerLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteTakerLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoteTakerLeaves
    **/
    _count?: true | NoteTakerLeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteTakerLeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteTakerLeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteTakerLeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteTakerLeaveMaxAggregateInputType
  }

  export type GetNoteTakerLeaveAggregateType<T extends NoteTakerLeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateNoteTakerLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoteTakerLeave[P]>
      : GetScalarType<T[P], AggregateNoteTakerLeave[P]>
  }




  export type NoteTakerLeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteTakerLeaveWhereInput
    orderBy?: NoteTakerLeaveOrderByWithAggregationInput | NoteTakerLeaveOrderByWithAggregationInput[]
    by: NoteTakerLeaveScalarFieldEnum[] | NoteTakerLeaveScalarFieldEnum
    having?: NoteTakerLeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteTakerLeaveCountAggregateInputType | true
    _avg?: NoteTakerLeaveAvgAggregateInputType
    _sum?: NoteTakerLeaveSumAggregateInputType
    _min?: NoteTakerLeaveMinAggregateInputType
    _max?: NoteTakerLeaveMaxAggregateInputType
  }

  export type NoteTakerLeaveGroupByOutputType = {
    id: number
    userId: number
    date: Date
    reason: string | null
    createdAt: Date
    _count: NoteTakerLeaveCountAggregateOutputType | null
    _avg: NoteTakerLeaveAvgAggregateOutputType | null
    _sum: NoteTakerLeaveSumAggregateOutputType | null
    _min: NoteTakerLeaveMinAggregateOutputType | null
    _max: NoteTakerLeaveMaxAggregateOutputType | null
  }

  type GetNoteTakerLeaveGroupByPayload<T extends NoteTakerLeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteTakerLeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteTakerLeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteTakerLeaveGroupByOutputType[P]>
            : GetScalarType<T[P], NoteTakerLeaveGroupByOutputType[P]>
        }
      >
    >


  export type NoteTakerLeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerLeave"]>

  export type NoteTakerLeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerLeave"]>

  export type NoteTakerLeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["noteTakerLeave"]>

  export type NoteTakerLeaveSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type NoteTakerLeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "date" | "reason" | "createdAt", ExtArgs["result"]["noteTakerLeave"]>
  export type NoteTakerLeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteTakerLeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NoteTakerLeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NoteTakerLeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoteTakerLeave"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      date: Date
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["noteTakerLeave"]>
    composites: {}
  }

  type NoteTakerLeaveGetPayload<S extends boolean | null | undefined | NoteTakerLeaveDefaultArgs> = $Result.GetResult<Prisma.$NoteTakerLeavePayload, S>

  type NoteTakerLeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NoteTakerLeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteTakerLeaveCountAggregateInputType | true
    }

  export interface NoteTakerLeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoteTakerLeave'], meta: { name: 'NoteTakerLeave' } }
    /**
     * Find zero or one NoteTakerLeave that matches the filter.
     * @param {NoteTakerLeaveFindUniqueArgs} args - Arguments to find a NoteTakerLeave
     * @example
     * // Get one NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoteTakerLeaveFindUniqueArgs>(args: SelectSubset<T, NoteTakerLeaveFindUniqueArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NoteTakerLeave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NoteTakerLeaveFindUniqueOrThrowArgs} args - Arguments to find a NoteTakerLeave
     * @example
     * // Get one NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoteTakerLeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, NoteTakerLeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteTakerLeave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveFindFirstArgs} args - Arguments to find a NoteTakerLeave
     * @example
     * // Get one NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoteTakerLeaveFindFirstArgs>(args?: SelectSubset<T, NoteTakerLeaveFindFirstArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NoteTakerLeave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveFindFirstOrThrowArgs} args - Arguments to find a NoteTakerLeave
     * @example
     * // Get one NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoteTakerLeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, NoteTakerLeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NoteTakerLeaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoteTakerLeaves
     * const noteTakerLeaves = await prisma.noteTakerLeave.findMany()
     * 
     * // Get first 10 NoteTakerLeaves
     * const noteTakerLeaves = await prisma.noteTakerLeave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteTakerLeaveWithIdOnly = await prisma.noteTakerLeave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoteTakerLeaveFindManyArgs>(args?: SelectSubset<T, NoteTakerLeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NoteTakerLeave.
     * @param {NoteTakerLeaveCreateArgs} args - Arguments to create a NoteTakerLeave.
     * @example
     * // Create one NoteTakerLeave
     * const NoteTakerLeave = await prisma.noteTakerLeave.create({
     *   data: {
     *     // ... data to create a NoteTakerLeave
     *   }
     * })
     * 
     */
    create<T extends NoteTakerLeaveCreateArgs>(args: SelectSubset<T, NoteTakerLeaveCreateArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NoteTakerLeaves.
     * @param {NoteTakerLeaveCreateManyArgs} args - Arguments to create many NoteTakerLeaves.
     * @example
     * // Create many NoteTakerLeaves
     * const noteTakerLeave = await prisma.noteTakerLeave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoteTakerLeaveCreateManyArgs>(args?: SelectSubset<T, NoteTakerLeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NoteTakerLeaves and returns the data saved in the database.
     * @param {NoteTakerLeaveCreateManyAndReturnArgs} args - Arguments to create many NoteTakerLeaves.
     * @example
     * // Create many NoteTakerLeaves
     * const noteTakerLeave = await prisma.noteTakerLeave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NoteTakerLeaves and only return the `id`
     * const noteTakerLeaveWithIdOnly = await prisma.noteTakerLeave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NoteTakerLeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, NoteTakerLeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NoteTakerLeave.
     * @param {NoteTakerLeaveDeleteArgs} args - Arguments to delete one NoteTakerLeave.
     * @example
     * // Delete one NoteTakerLeave
     * const NoteTakerLeave = await prisma.noteTakerLeave.delete({
     *   where: {
     *     // ... filter to delete one NoteTakerLeave
     *   }
     * })
     * 
     */
    delete<T extends NoteTakerLeaveDeleteArgs>(args: SelectSubset<T, NoteTakerLeaveDeleteArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NoteTakerLeave.
     * @param {NoteTakerLeaveUpdateArgs} args - Arguments to update one NoteTakerLeave.
     * @example
     * // Update one NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoteTakerLeaveUpdateArgs>(args: SelectSubset<T, NoteTakerLeaveUpdateArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NoteTakerLeaves.
     * @param {NoteTakerLeaveDeleteManyArgs} args - Arguments to filter NoteTakerLeaves to delete.
     * @example
     * // Delete a few NoteTakerLeaves
     * const { count } = await prisma.noteTakerLeave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoteTakerLeaveDeleteManyArgs>(args?: SelectSubset<T, NoteTakerLeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteTakerLeaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoteTakerLeaves
     * const noteTakerLeave = await prisma.noteTakerLeave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoteTakerLeaveUpdateManyArgs>(args: SelectSubset<T, NoteTakerLeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoteTakerLeaves and returns the data updated in the database.
     * @param {NoteTakerLeaveUpdateManyAndReturnArgs} args - Arguments to update many NoteTakerLeaves.
     * @example
     * // Update many NoteTakerLeaves
     * const noteTakerLeave = await prisma.noteTakerLeave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NoteTakerLeaves and only return the `id`
     * const noteTakerLeaveWithIdOnly = await prisma.noteTakerLeave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NoteTakerLeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, NoteTakerLeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NoteTakerLeave.
     * @param {NoteTakerLeaveUpsertArgs} args - Arguments to update or create a NoteTakerLeave.
     * @example
     * // Update or create a NoteTakerLeave
     * const noteTakerLeave = await prisma.noteTakerLeave.upsert({
     *   create: {
     *     // ... data to create a NoteTakerLeave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoteTakerLeave we want to update
     *   }
     * })
     */
    upsert<T extends NoteTakerLeaveUpsertArgs>(args: SelectSubset<T, NoteTakerLeaveUpsertArgs<ExtArgs>>): Prisma__NoteTakerLeaveClient<$Result.GetResult<Prisma.$NoteTakerLeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NoteTakerLeaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveCountArgs} args - Arguments to filter NoteTakerLeaves to count.
     * @example
     * // Count the number of NoteTakerLeaves
     * const count = await prisma.noteTakerLeave.count({
     *   where: {
     *     // ... the filter for the NoteTakerLeaves we want to count
     *   }
     * })
    **/
    count<T extends NoteTakerLeaveCountArgs>(
      args?: Subset<T, NoteTakerLeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteTakerLeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoteTakerLeave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteTakerLeaveAggregateArgs>(args: Subset<T, NoteTakerLeaveAggregateArgs>): Prisma.PrismaPromise<GetNoteTakerLeaveAggregateType<T>>

    /**
     * Group by NoteTakerLeave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteTakerLeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteTakerLeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteTakerLeaveGroupByArgs['orderBy'] }
        : { orderBy?: NoteTakerLeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteTakerLeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteTakerLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoteTakerLeave model
   */
  readonly fields: NoteTakerLeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoteTakerLeave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteTakerLeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoteTakerLeave model
   */
  interface NoteTakerLeaveFieldRefs {
    readonly id: FieldRef<"NoteTakerLeave", 'Int'>
    readonly userId: FieldRef<"NoteTakerLeave", 'Int'>
    readonly date: FieldRef<"NoteTakerLeave", 'DateTime'>
    readonly reason: FieldRef<"NoteTakerLeave", 'String'>
    readonly createdAt: FieldRef<"NoteTakerLeave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NoteTakerLeave findUnique
   */
  export type NoteTakerLeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerLeave to fetch.
     */
    where: NoteTakerLeaveWhereUniqueInput
  }

  /**
   * NoteTakerLeave findUniqueOrThrow
   */
  export type NoteTakerLeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerLeave to fetch.
     */
    where: NoteTakerLeaveWhereUniqueInput
  }

  /**
   * NoteTakerLeave findFirst
   */
  export type NoteTakerLeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerLeave to fetch.
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerLeaves to fetch.
     */
    orderBy?: NoteTakerLeaveOrderByWithRelationInput | NoteTakerLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTakerLeaves.
     */
    cursor?: NoteTakerLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTakerLeaves.
     */
    distinct?: NoteTakerLeaveScalarFieldEnum | NoteTakerLeaveScalarFieldEnum[]
  }

  /**
   * NoteTakerLeave findFirstOrThrow
   */
  export type NoteTakerLeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerLeave to fetch.
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerLeaves to fetch.
     */
    orderBy?: NoteTakerLeaveOrderByWithRelationInput | NoteTakerLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoteTakerLeaves.
     */
    cursor?: NoteTakerLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerLeaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoteTakerLeaves.
     */
    distinct?: NoteTakerLeaveScalarFieldEnum | NoteTakerLeaveScalarFieldEnum[]
  }

  /**
   * NoteTakerLeave findMany
   */
  export type NoteTakerLeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter, which NoteTakerLeaves to fetch.
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoteTakerLeaves to fetch.
     */
    orderBy?: NoteTakerLeaveOrderByWithRelationInput | NoteTakerLeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoteTakerLeaves.
     */
    cursor?: NoteTakerLeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoteTakerLeaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoteTakerLeaves.
     */
    skip?: number
    distinct?: NoteTakerLeaveScalarFieldEnum | NoteTakerLeaveScalarFieldEnum[]
  }

  /**
   * NoteTakerLeave create
   */
  export type NoteTakerLeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a NoteTakerLeave.
     */
    data: XOR<NoteTakerLeaveCreateInput, NoteTakerLeaveUncheckedCreateInput>
  }

  /**
   * NoteTakerLeave createMany
   */
  export type NoteTakerLeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoteTakerLeaves.
     */
    data: NoteTakerLeaveCreateManyInput | NoteTakerLeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoteTakerLeave createManyAndReturn
   */
  export type NoteTakerLeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * The data used to create many NoteTakerLeaves.
     */
    data: NoteTakerLeaveCreateManyInput | NoteTakerLeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteTakerLeave update
   */
  export type NoteTakerLeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a NoteTakerLeave.
     */
    data: XOR<NoteTakerLeaveUpdateInput, NoteTakerLeaveUncheckedUpdateInput>
    /**
     * Choose, which NoteTakerLeave to update.
     */
    where: NoteTakerLeaveWhereUniqueInput
  }

  /**
   * NoteTakerLeave updateMany
   */
  export type NoteTakerLeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoteTakerLeaves.
     */
    data: XOR<NoteTakerLeaveUpdateManyMutationInput, NoteTakerLeaveUncheckedUpdateManyInput>
    /**
     * Filter which NoteTakerLeaves to update
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * Limit how many NoteTakerLeaves to update.
     */
    limit?: number
  }

  /**
   * NoteTakerLeave updateManyAndReturn
   */
  export type NoteTakerLeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * The data used to update NoteTakerLeaves.
     */
    data: XOR<NoteTakerLeaveUpdateManyMutationInput, NoteTakerLeaveUncheckedUpdateManyInput>
    /**
     * Filter which NoteTakerLeaves to update
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * Limit how many NoteTakerLeaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NoteTakerLeave upsert
   */
  export type NoteTakerLeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the NoteTakerLeave to update in case it exists.
     */
    where: NoteTakerLeaveWhereUniqueInput
    /**
     * In case the NoteTakerLeave found by the `where` argument doesn't exist, create a new NoteTakerLeave with this data.
     */
    create: XOR<NoteTakerLeaveCreateInput, NoteTakerLeaveUncheckedCreateInput>
    /**
     * In case the NoteTakerLeave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteTakerLeaveUpdateInput, NoteTakerLeaveUncheckedUpdateInput>
  }

  /**
   * NoteTakerLeave delete
   */
  export type NoteTakerLeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
    /**
     * Filter which NoteTakerLeave to delete.
     */
    where: NoteTakerLeaveWhereUniqueInput
  }

  /**
   * NoteTakerLeave deleteMany
   */
  export type NoteTakerLeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoteTakerLeaves to delete
     */
    where?: NoteTakerLeaveWhereInput
    /**
     * Limit how many NoteTakerLeaves to delete.
     */
    limit?: number
  }

  /**
   * NoteTakerLeave without action
   */
  export type NoteTakerLeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteTakerLeave
     */
    select?: NoteTakerLeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NoteTakerLeave
     */
    omit?: NoteTakerLeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NoteTakerLeaveInclude<ExtArgs> | null
  }


  /**
   * Model HousekeepingTask
   */

  export type AggregateHousekeepingTask = {
    _count: HousekeepingTaskCountAggregateOutputType | null
    _avg: HousekeepingTaskAvgAggregateOutputType | null
    _sum: HousekeepingTaskSumAggregateOutputType | null
    _min: HousekeepingTaskMinAggregateOutputType | null
    _max: HousekeepingTaskMaxAggregateOutputType | null
  }

  export type HousekeepingTaskAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    assignedToId: number | null
  }

  export type HousekeepingTaskSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    assignedToId: number | null
  }

  export type HousekeepingTaskMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    status: $Enums.HousekeepingTaskStatus | null
    assignedToId: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingTaskMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    serviceId: number | null
    status: $Enums.HousekeepingTaskStatus | null
    assignedToId: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HousekeepingTaskCountAggregateOutputType = {
    id: number
    bookingId: number
    serviceId: number
    status: number
    assignedToId: number
    note: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HousekeepingTaskAvgAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    assignedToId?: true
  }

  export type HousekeepingTaskSumAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    assignedToId?: true
  }

  export type HousekeepingTaskMinAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    status?: true
    assignedToId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingTaskMaxAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    status?: true
    assignedToId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HousekeepingTaskCountAggregateInputType = {
    id?: true
    bookingId?: true
    serviceId?: true
    status?: true
    assignedToId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HousekeepingTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingTask to aggregate.
     */
    where?: HousekeepingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingTasks to fetch.
     */
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HousekeepingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HousekeepingTasks
    **/
    _count?: true | HousekeepingTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HousekeepingTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HousekeepingTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HousekeepingTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HousekeepingTaskMaxAggregateInputType
  }

  export type GetHousekeepingTaskAggregateType<T extends HousekeepingTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateHousekeepingTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHousekeepingTask[P]>
      : GetScalarType<T[P], AggregateHousekeepingTask[P]>
  }




  export type HousekeepingTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HousekeepingTaskWhereInput
    orderBy?: HousekeepingTaskOrderByWithAggregationInput | HousekeepingTaskOrderByWithAggregationInput[]
    by: HousekeepingTaskScalarFieldEnum[] | HousekeepingTaskScalarFieldEnum
    having?: HousekeepingTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HousekeepingTaskCountAggregateInputType | true
    _avg?: HousekeepingTaskAvgAggregateInputType
    _sum?: HousekeepingTaskSumAggregateInputType
    _min?: HousekeepingTaskMinAggregateInputType
    _max?: HousekeepingTaskMaxAggregateInputType
  }

  export type HousekeepingTaskGroupByOutputType = {
    id: number
    bookingId: number
    serviceId: number
    status: $Enums.HousekeepingTaskStatus
    assignedToId: number | null
    note: string | null
    createdAt: Date
    updatedAt: Date
    _count: HousekeepingTaskCountAggregateOutputType | null
    _avg: HousekeepingTaskAvgAggregateOutputType | null
    _sum: HousekeepingTaskSumAggregateOutputType | null
    _min: HousekeepingTaskMinAggregateOutputType | null
    _max: HousekeepingTaskMaxAggregateOutputType | null
  }

  type GetHousekeepingTaskGroupByPayload<T extends HousekeepingTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HousekeepingTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HousekeepingTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HousekeepingTaskGroupByOutputType[P]>
            : GetScalarType<T[P], HousekeepingTaskGroupByOutputType[P]>
        }
      >
    >


  export type HousekeepingTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    status?: boolean
    assignedToId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingTask"]>

  export type HousekeepingTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    status?: boolean
    assignedToId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingTask"]>

  export type HousekeepingTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    status?: boolean
    assignedToId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }, ExtArgs["result"]["housekeepingTask"]>

  export type HousekeepingTaskSelectScalar = {
    id?: boolean
    bookingId?: boolean
    serviceId?: boolean
    status?: boolean
    assignedToId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HousekeepingTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "serviceId" | "status" | "assignedToId" | "note" | "createdAt" | "updatedAt", ExtArgs["result"]["housekeepingTask"]>
  export type HousekeepingTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }
  export type HousekeepingTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }
  export type HousekeepingTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    assignedTo?: boolean | HousekeepingTask$assignedToArgs<ExtArgs>
  }

  export type $HousekeepingTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HousekeepingTask"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      serviceId: number
      status: $Enums.HousekeepingTaskStatus
      assignedToId: number | null
      note: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["housekeepingTask"]>
    composites: {}
  }

  type HousekeepingTaskGetPayload<S extends boolean | null | undefined | HousekeepingTaskDefaultArgs> = $Result.GetResult<Prisma.$HousekeepingTaskPayload, S>

  type HousekeepingTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HousekeepingTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HousekeepingTaskCountAggregateInputType | true
    }

  export interface HousekeepingTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HousekeepingTask'], meta: { name: 'HousekeepingTask' } }
    /**
     * Find zero or one HousekeepingTask that matches the filter.
     * @param {HousekeepingTaskFindUniqueArgs} args - Arguments to find a HousekeepingTask
     * @example
     * // Get one HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HousekeepingTaskFindUniqueArgs>(args: SelectSubset<T, HousekeepingTaskFindUniqueArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HousekeepingTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HousekeepingTaskFindUniqueOrThrowArgs} args - Arguments to find a HousekeepingTask
     * @example
     * // Get one HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HousekeepingTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, HousekeepingTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskFindFirstArgs} args - Arguments to find a HousekeepingTask
     * @example
     * // Get one HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HousekeepingTaskFindFirstArgs>(args?: SelectSubset<T, HousekeepingTaskFindFirstArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HousekeepingTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskFindFirstOrThrowArgs} args - Arguments to find a HousekeepingTask
     * @example
     * // Get one HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HousekeepingTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, HousekeepingTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HousekeepingTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HousekeepingTasks
     * const housekeepingTasks = await prisma.housekeepingTask.findMany()
     * 
     * // Get first 10 HousekeepingTasks
     * const housekeepingTasks = await prisma.housekeepingTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const housekeepingTaskWithIdOnly = await prisma.housekeepingTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HousekeepingTaskFindManyArgs>(args?: SelectSubset<T, HousekeepingTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HousekeepingTask.
     * @param {HousekeepingTaskCreateArgs} args - Arguments to create a HousekeepingTask.
     * @example
     * // Create one HousekeepingTask
     * const HousekeepingTask = await prisma.housekeepingTask.create({
     *   data: {
     *     // ... data to create a HousekeepingTask
     *   }
     * })
     * 
     */
    create<T extends HousekeepingTaskCreateArgs>(args: SelectSubset<T, HousekeepingTaskCreateArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HousekeepingTasks.
     * @param {HousekeepingTaskCreateManyArgs} args - Arguments to create many HousekeepingTasks.
     * @example
     * // Create many HousekeepingTasks
     * const housekeepingTask = await prisma.housekeepingTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HousekeepingTaskCreateManyArgs>(args?: SelectSubset<T, HousekeepingTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HousekeepingTasks and returns the data saved in the database.
     * @param {HousekeepingTaskCreateManyAndReturnArgs} args - Arguments to create many HousekeepingTasks.
     * @example
     * // Create many HousekeepingTasks
     * const housekeepingTask = await prisma.housekeepingTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HousekeepingTasks and only return the `id`
     * const housekeepingTaskWithIdOnly = await prisma.housekeepingTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HousekeepingTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, HousekeepingTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HousekeepingTask.
     * @param {HousekeepingTaskDeleteArgs} args - Arguments to delete one HousekeepingTask.
     * @example
     * // Delete one HousekeepingTask
     * const HousekeepingTask = await prisma.housekeepingTask.delete({
     *   where: {
     *     // ... filter to delete one HousekeepingTask
     *   }
     * })
     * 
     */
    delete<T extends HousekeepingTaskDeleteArgs>(args: SelectSubset<T, HousekeepingTaskDeleteArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HousekeepingTask.
     * @param {HousekeepingTaskUpdateArgs} args - Arguments to update one HousekeepingTask.
     * @example
     * // Update one HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HousekeepingTaskUpdateArgs>(args: SelectSubset<T, HousekeepingTaskUpdateArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HousekeepingTasks.
     * @param {HousekeepingTaskDeleteManyArgs} args - Arguments to filter HousekeepingTasks to delete.
     * @example
     * // Delete a few HousekeepingTasks
     * const { count } = await prisma.housekeepingTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HousekeepingTaskDeleteManyArgs>(args?: SelectSubset<T, HousekeepingTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HousekeepingTasks
     * const housekeepingTask = await prisma.housekeepingTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HousekeepingTaskUpdateManyArgs>(args: SelectSubset<T, HousekeepingTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HousekeepingTasks and returns the data updated in the database.
     * @param {HousekeepingTaskUpdateManyAndReturnArgs} args - Arguments to update many HousekeepingTasks.
     * @example
     * // Update many HousekeepingTasks
     * const housekeepingTask = await prisma.housekeepingTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HousekeepingTasks and only return the `id`
     * const housekeepingTaskWithIdOnly = await prisma.housekeepingTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HousekeepingTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, HousekeepingTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HousekeepingTask.
     * @param {HousekeepingTaskUpsertArgs} args - Arguments to update or create a HousekeepingTask.
     * @example
     * // Update or create a HousekeepingTask
     * const housekeepingTask = await prisma.housekeepingTask.upsert({
     *   create: {
     *     // ... data to create a HousekeepingTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HousekeepingTask we want to update
     *   }
     * })
     */
    upsert<T extends HousekeepingTaskUpsertArgs>(args: SelectSubset<T, HousekeepingTaskUpsertArgs<ExtArgs>>): Prisma__HousekeepingTaskClient<$Result.GetResult<Prisma.$HousekeepingTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HousekeepingTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskCountArgs} args - Arguments to filter HousekeepingTasks to count.
     * @example
     * // Count the number of HousekeepingTasks
     * const count = await prisma.housekeepingTask.count({
     *   where: {
     *     // ... the filter for the HousekeepingTasks we want to count
     *   }
     * })
    **/
    count<T extends HousekeepingTaskCountArgs>(
      args?: Subset<T, HousekeepingTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HousekeepingTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HousekeepingTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HousekeepingTaskAggregateArgs>(args: Subset<T, HousekeepingTaskAggregateArgs>): Prisma.PrismaPromise<GetHousekeepingTaskAggregateType<T>>

    /**
     * Group by HousekeepingTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HousekeepingTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HousekeepingTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HousekeepingTaskGroupByArgs['orderBy'] }
        : { orderBy?: HousekeepingTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HousekeepingTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHousekeepingTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HousekeepingTask model
   */
  readonly fields: HousekeepingTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HousekeepingTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HousekeepingTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends HousekeepingTask$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, HousekeepingTask$assignedToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HousekeepingTask model
   */
  interface HousekeepingTaskFieldRefs {
    readonly id: FieldRef<"HousekeepingTask", 'Int'>
    readonly bookingId: FieldRef<"HousekeepingTask", 'Int'>
    readonly serviceId: FieldRef<"HousekeepingTask", 'Int'>
    readonly status: FieldRef<"HousekeepingTask", 'HousekeepingTaskStatus'>
    readonly assignedToId: FieldRef<"HousekeepingTask", 'Int'>
    readonly note: FieldRef<"HousekeepingTask", 'String'>
    readonly createdAt: FieldRef<"HousekeepingTask", 'DateTime'>
    readonly updatedAt: FieldRef<"HousekeepingTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HousekeepingTask findUnique
   */
  export type HousekeepingTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingTask to fetch.
     */
    where: HousekeepingTaskWhereUniqueInput
  }

  /**
   * HousekeepingTask findUniqueOrThrow
   */
  export type HousekeepingTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingTask to fetch.
     */
    where: HousekeepingTaskWhereUniqueInput
  }

  /**
   * HousekeepingTask findFirst
   */
  export type HousekeepingTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingTask to fetch.
     */
    where?: HousekeepingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingTasks to fetch.
     */
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingTasks.
     */
    cursor?: HousekeepingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingTasks.
     */
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * HousekeepingTask findFirstOrThrow
   */
  export type HousekeepingTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingTask to fetch.
     */
    where?: HousekeepingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingTasks to fetch.
     */
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HousekeepingTasks.
     */
    cursor?: HousekeepingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HousekeepingTasks.
     */
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * HousekeepingTask findMany
   */
  export type HousekeepingTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter, which HousekeepingTasks to fetch.
     */
    where?: HousekeepingTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HousekeepingTasks to fetch.
     */
    orderBy?: HousekeepingTaskOrderByWithRelationInput | HousekeepingTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HousekeepingTasks.
     */
    cursor?: HousekeepingTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HousekeepingTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HousekeepingTasks.
     */
    skip?: number
    distinct?: HousekeepingTaskScalarFieldEnum | HousekeepingTaskScalarFieldEnum[]
  }

  /**
   * HousekeepingTask create
   */
  export type HousekeepingTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a HousekeepingTask.
     */
    data: XOR<HousekeepingTaskCreateInput, HousekeepingTaskUncheckedCreateInput>
  }

  /**
   * HousekeepingTask createMany
   */
  export type HousekeepingTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HousekeepingTasks.
     */
    data: HousekeepingTaskCreateManyInput | HousekeepingTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HousekeepingTask createManyAndReturn
   */
  export type HousekeepingTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * The data used to create many HousekeepingTasks.
     */
    data: HousekeepingTaskCreateManyInput | HousekeepingTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HousekeepingTask update
   */
  export type HousekeepingTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a HousekeepingTask.
     */
    data: XOR<HousekeepingTaskUpdateInput, HousekeepingTaskUncheckedUpdateInput>
    /**
     * Choose, which HousekeepingTask to update.
     */
    where: HousekeepingTaskWhereUniqueInput
  }

  /**
   * HousekeepingTask updateMany
   */
  export type HousekeepingTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HousekeepingTasks.
     */
    data: XOR<HousekeepingTaskUpdateManyMutationInput, HousekeepingTaskUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingTasks to update
     */
    where?: HousekeepingTaskWhereInput
    /**
     * Limit how many HousekeepingTasks to update.
     */
    limit?: number
  }

  /**
   * HousekeepingTask updateManyAndReturn
   */
  export type HousekeepingTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * The data used to update HousekeepingTasks.
     */
    data: XOR<HousekeepingTaskUpdateManyMutationInput, HousekeepingTaskUncheckedUpdateManyInput>
    /**
     * Filter which HousekeepingTasks to update
     */
    where?: HousekeepingTaskWhereInput
    /**
     * Limit how many HousekeepingTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HousekeepingTask upsert
   */
  export type HousekeepingTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the HousekeepingTask to update in case it exists.
     */
    where: HousekeepingTaskWhereUniqueInput
    /**
     * In case the HousekeepingTask found by the `where` argument doesn't exist, create a new HousekeepingTask with this data.
     */
    create: XOR<HousekeepingTaskCreateInput, HousekeepingTaskUncheckedCreateInput>
    /**
     * In case the HousekeepingTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HousekeepingTaskUpdateInput, HousekeepingTaskUncheckedUpdateInput>
  }

  /**
   * HousekeepingTask delete
   */
  export type HousekeepingTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
    /**
     * Filter which HousekeepingTask to delete.
     */
    where: HousekeepingTaskWhereUniqueInput
  }

  /**
   * HousekeepingTask deleteMany
   */
  export type HousekeepingTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HousekeepingTasks to delete
     */
    where?: HousekeepingTaskWhereInput
    /**
     * Limit how many HousekeepingTasks to delete.
     */
    limit?: number
  }

  /**
   * HousekeepingTask.assignedTo
   */
  export type HousekeepingTask$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * HousekeepingTask without action
   */
  export type HousekeepingTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HousekeepingTask
     */
    select?: HousekeepingTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HousekeepingTask
     */
    omit?: HousekeepingTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HousekeepingTaskInclude<ExtArgs> | null
  }


  /**
   * Model Issue
   */

  export type AggregateIssue = {
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  export type IssueAvgAggregateOutputType = {
    id: number | null
    reporterId: number | null
    roomId: number | null
  }

  export type IssueSumAggregateOutputType = {
    id: number | null
    reporterId: number | null
    roomId: number | null
  }

  export type IssueMinAggregateOutputType = {
    id: number | null
    reporterId: number | null
    roomId: number | null
    issueType: $Enums.IssueType | null
    subject: string | null
    description: string | null
    priority: $Enums.IssuePriority | null
    status: $Enums.IssueStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueMaxAggregateOutputType = {
    id: number | null
    reporterId: number | null
    roomId: number | null
    issueType: $Enums.IssueType | null
    subject: string | null
    description: string | null
    priority: $Enums.IssuePriority | null
    status: $Enums.IssueStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IssueCountAggregateOutputType = {
    id: number
    reporterId: number
    roomId: number
    issueType: number
    subject: number
    description: number
    priority: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IssueAvgAggregateInputType = {
    id?: true
    reporterId?: true
    roomId?: true
  }

  export type IssueSumAggregateInputType = {
    id?: true
    reporterId?: true
    roomId?: true
  }

  export type IssueMinAggregateInputType = {
    id?: true
    reporterId?: true
    roomId?: true
    issueType?: true
    subject?: true
    description?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueMaxAggregateInputType = {
    id?: true
    reporterId?: true
    roomId?: true
    issueType?: true
    subject?: true
    description?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IssueCountAggregateInputType = {
    id?: true
    reporterId?: true
    roomId?: true
    issueType?: true
    subject?: true
    description?: true
    priority?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issue to aggregate.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Issues
    **/
    _count?: true | IssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueMaxAggregateInputType
  }

  export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
        [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssue[P]>
      : GetScalarType<T[P], AggregateIssue[P]>
  }




  export type IssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueWhereInput
    orderBy?: IssueOrderByWithAggregationInput | IssueOrderByWithAggregationInput[]
    by: IssueScalarFieldEnum[] | IssueScalarFieldEnum
    having?: IssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCountAggregateInputType | true
    _avg?: IssueAvgAggregateInputType
    _sum?: IssueSumAggregateInputType
    _min?: IssueMinAggregateInputType
    _max?: IssueMaxAggregateInputType
  }

  export type IssueGroupByOutputType = {
    id: number
    reporterId: number
    roomId: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority: $Enums.IssuePriority
    status: $Enums.IssueStatus
    createdAt: Date
    updatedAt: Date
    _count: IssueCountAggregateOutputType | null
    _avg: IssueAvgAggregateOutputType | null
    _sum: IssueSumAggregateOutputType | null
    _min: IssueMinAggregateOutputType | null
    _max: IssueMaxAggregateOutputType | null
  }

  type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueGroupByOutputType[P]>
            : GetScalarType<T[P], IssueGroupByOutputType[P]>
        }
      >
    >


  export type IssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    roomId?: boolean
    issueType?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
    comments?: boolean | Issue$commentsArgs<ExtArgs>
    attachments?: boolean | Issue$attachmentsArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    roomId?: boolean
    issueType?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    roomId?: boolean
    issueType?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
  }, ExtArgs["result"]["issue"]>

  export type IssueSelectScalar = {
    id?: boolean
    reporterId?: boolean
    roomId?: boolean
    issueType?: boolean
    subject?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporterId" | "roomId" | "issueType" | "subject" | "description" | "priority" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["issue"]>
  export type IssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
    comments?: boolean | Issue$commentsArgs<ExtArgs>
    attachments?: boolean | Issue$attachmentsArgs<ExtArgs>
    _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
  }
  export type IssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | UserDefaultArgs<ExtArgs>
    meetingRoom?: boolean | Issue$meetingRoomArgs<ExtArgs>
  }

  export type $IssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Issue"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs>
      meetingRoom: Prisma.$MeetingRoomPayload<ExtArgs> | null
      comments: Prisma.$IssueCommentPayload<ExtArgs>[]
      attachments: Prisma.$IssueAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reporterId: number
      roomId: number | null
      issueType: $Enums.IssueType
      subject: string
      description: string
      priority: $Enums.IssuePriority
      status: $Enums.IssueStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["issue"]>
    composites: {}
  }

  type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> = $Result.GetResult<Prisma.$IssuePayload, S>

  type IssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueCountAggregateInputType | true
    }

  export interface IssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue'], meta: { name: 'Issue' } }
    /**
     * Find zero or one Issue that matches the filter.
     * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssueFindUniqueArgs>(args: SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Issue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs>(args: SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssueFindFirstArgs>(args?: SelectSubset<T, IssueFindFirstArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Issue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
     * @example
     * // Get one Issue
     * const issue = await prisma.issue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssueFindFirstOrThrowArgs>(args?: SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Issues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Issues
     * const issues = await prisma.issue.findMany()
     * 
     * // Get first 10 Issues
     * const issues = await prisma.issue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssueFindManyArgs>(args?: SelectSubset<T, IssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Issue.
     * @param {IssueCreateArgs} args - Arguments to create a Issue.
     * @example
     * // Create one Issue
     * const Issue = await prisma.issue.create({
     *   data: {
     *     // ... data to create a Issue
     *   }
     * })
     * 
     */
    create<T extends IssueCreateArgs>(args: SelectSubset<T, IssueCreateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Issues.
     * @param {IssueCreateManyArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssueCreateManyArgs>(args?: SelectSubset<T, IssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Issues and returns the data saved in the database.
     * @param {IssueCreateManyAndReturnArgs} args - Arguments to create many Issues.
     * @example
     * // Create many Issues
     * const issue = await prisma.issue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssueCreateManyAndReturnArgs>(args?: SelectSubset<T, IssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Issue.
     * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
     * @example
     * // Delete one Issue
     * const Issue = await prisma.issue.delete({
     *   where: {
     *     // ... filter to delete one Issue
     *   }
     * })
     * 
     */
    delete<T extends IssueDeleteArgs>(args: SelectSubset<T, IssueDeleteArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Issue.
     * @param {IssueUpdateArgs} args - Arguments to update one Issue.
     * @example
     * // Update one Issue
     * const issue = await prisma.issue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssueUpdateArgs>(args: SelectSubset<T, IssueUpdateArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Issues.
     * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
     * @example
     * // Delete a few Issues
     * const { count } = await prisma.issue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssueDeleteManyArgs>(args?: SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssueUpdateManyArgs>(args: SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Issues and returns the data updated in the database.
     * @param {IssueUpdateManyAndReturnArgs} args - Arguments to update many Issues.
     * @example
     * // Update many Issues
     * const issue = await prisma.issue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Issues and only return the `id`
     * const issueWithIdOnly = await prisma.issue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssueUpdateManyAndReturnArgs>(args: SelectSubset<T, IssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Issue.
     * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
     * @example
     * // Update or create a Issue
     * const issue = await prisma.issue.upsert({
     *   create: {
     *     // ... data to create a Issue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Issue we want to update
     *   }
     * })
     */
    upsert<T extends IssueUpsertArgs>(args: SelectSubset<T, IssueUpsertArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Issues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCountArgs} args - Arguments to filter Issues to count.
     * @example
     * // Count the number of Issues
     * const count = await prisma.issue.count({
     *   where: {
     *     // ... the filter for the Issues we want to count
     *   }
     * })
    **/
    count<T extends IssueCountArgs>(
      args?: Subset<T, IssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAggregateArgs>(args: Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

    /**
     * Group by Issue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueGroupByArgs['orderBy'] }
        : { orderBy?: IssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Issue model
   */
  readonly fields: IssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Issue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    meetingRoom<T extends Issue$meetingRoomArgs<ExtArgs> = {}>(args?: Subset<T, Issue$meetingRoomArgs<ExtArgs>>): Prisma__MeetingRoomClient<$Result.GetResult<Prisma.$MeetingRoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Issue$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Issue$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Issue$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Issue$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Issue model
   */
  interface IssueFieldRefs {
    readonly id: FieldRef<"Issue", 'Int'>
    readonly reporterId: FieldRef<"Issue", 'Int'>
    readonly roomId: FieldRef<"Issue", 'Int'>
    readonly issueType: FieldRef<"Issue", 'IssueType'>
    readonly subject: FieldRef<"Issue", 'String'>
    readonly description: FieldRef<"Issue", 'String'>
    readonly priority: FieldRef<"Issue", 'IssuePriority'>
    readonly status: FieldRef<"Issue", 'IssueStatus'>
    readonly createdAt: FieldRef<"Issue", 'DateTime'>
    readonly updatedAt: FieldRef<"Issue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Issue findUnique
   */
  export type IssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findUniqueOrThrow
   */
  export type IssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue findFirst
   */
  export type IssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findFirstOrThrow
   */
  export type IssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issue to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Issues.
     */
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue findMany
   */
  export type IssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter, which Issues to fetch.
     */
    where?: IssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Issues to fetch.
     */
    orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Issues.
     */
    cursor?: IssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Issues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Issues.
     */
    skip?: number
    distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[]
  }

  /**
   * Issue create
   */
  export type IssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to create a Issue.
     */
    data: XOR<IssueCreateInput, IssueUncheckedCreateInput>
  }

  /**
   * Issue createMany
   */
  export type IssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Issue createManyAndReturn
   */
  export type IssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to create many Issues.
     */
    data: IssueCreateManyInput | IssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Issue update
   */
  export type IssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The data needed to update a Issue.
     */
    data: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
    /**
     * Choose, which Issue to update.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue updateMany
   */
  export type IssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
  }

  /**
   * Issue updateManyAndReturn
   */
  export type IssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * The data used to update Issues.
     */
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>
    /**
     * Filter which Issues to update
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Issue upsert
   */
  export type IssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * The filter to search for the Issue to update in case it exists.
     */
    where: IssueWhereUniqueInput
    /**
     * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
     */
    create: XOR<IssueCreateInput, IssueUncheckedCreateInput>
    /**
     * In case the Issue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>
  }

  /**
   * Issue delete
   */
  export type IssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
    /**
     * Filter which Issue to delete.
     */
    where: IssueWhereUniqueInput
  }

  /**
   * Issue deleteMany
   */
  export type IssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Issues to delete
     */
    where?: IssueWhereInput
    /**
     * Limit how many Issues to delete.
     */
    limit?: number
  }

  /**
   * Issue.meetingRoom
   */
  export type Issue$meetingRoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRoom
     */
    select?: MeetingRoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRoom
     */
    omit?: MeetingRoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRoomInclude<ExtArgs> | null
    where?: MeetingRoomWhereInput
  }

  /**
   * Issue.comments
   */
  export type Issue$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    where?: IssueCommentWhereInput
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    cursor?: IssueCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueCommentScalarFieldEnum | IssueCommentScalarFieldEnum[]
  }

  /**
   * Issue.attachments
   */
  export type Issue$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    where?: IssueAttachmentWhereInput
    orderBy?: IssueAttachmentOrderByWithRelationInput | IssueAttachmentOrderByWithRelationInput[]
    cursor?: IssueAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IssueAttachmentScalarFieldEnum | IssueAttachmentScalarFieldEnum[]
  }

  /**
   * Issue without action
   */
  export type IssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Issue
     */
    select?: IssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Issue
     */
    omit?: IssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueInclude<ExtArgs> | null
  }


  /**
   * Model IssueComment
   */

  export type AggregateIssueComment = {
    _count: IssueCommentCountAggregateOutputType | null
    _avg: IssueCommentAvgAggregateOutputType | null
    _sum: IssueCommentSumAggregateOutputType | null
    _min: IssueCommentMinAggregateOutputType | null
    _max: IssueCommentMaxAggregateOutputType | null
  }

  export type IssueCommentAvgAggregateOutputType = {
    id: number | null
    issueId: number | null
    authorId: number | null
  }

  export type IssueCommentSumAggregateOutputType = {
    id: number | null
    issueId: number | null
    authorId: number | null
  }

  export type IssueCommentMinAggregateOutputType = {
    id: number | null
    issueId: number | null
    authorId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type IssueCommentMaxAggregateOutputType = {
    id: number | null
    issueId: number | null
    authorId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type IssueCommentCountAggregateOutputType = {
    id: number
    issueId: number
    authorId: number
    message: number
    createdAt: number
    _all: number
  }


  export type IssueCommentAvgAggregateInputType = {
    id?: true
    issueId?: true
    authorId?: true
  }

  export type IssueCommentSumAggregateInputType = {
    id?: true
    issueId?: true
    authorId?: true
  }

  export type IssueCommentMinAggregateInputType = {
    id?: true
    issueId?: true
    authorId?: true
    message?: true
    createdAt?: true
  }

  export type IssueCommentMaxAggregateInputType = {
    id?: true
    issueId?: true
    authorId?: true
    message?: true
    createdAt?: true
  }

  export type IssueCommentCountAggregateInputType = {
    id?: true
    issueId?: true
    authorId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type IssueCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IssueComment to aggregate.
     */
    where?: IssueCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueComments to fetch.
     */
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IssueComments
    **/
    _count?: true | IssueCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssueCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssueCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueCommentMaxAggregateInputType
  }

  export type GetIssueCommentAggregateType<T extends IssueCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateIssueComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssueComment[P]>
      : GetScalarType<T[P], AggregateIssueComment[P]>
  }




  export type IssueCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueCommentWhereInput
    orderBy?: IssueCommentOrderByWithAggregationInput | IssueCommentOrderByWithAggregationInput[]
    by: IssueCommentScalarFieldEnum[] | IssueCommentScalarFieldEnum
    having?: IssueCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueCommentCountAggregateInputType | true
    _avg?: IssueCommentAvgAggregateInputType
    _sum?: IssueCommentSumAggregateInputType
    _min?: IssueCommentMinAggregateInputType
    _max?: IssueCommentMaxAggregateInputType
  }

  export type IssueCommentGroupByOutputType = {
    id: number
    issueId: number
    authorId: number
    message: string
    createdAt: Date
    _count: IssueCommentCountAggregateOutputType | null
    _avg: IssueCommentAvgAggregateOutputType | null
    _sum: IssueCommentSumAggregateOutputType | null
    _min: IssueCommentMinAggregateOutputType | null
    _max: IssueCommentMaxAggregateOutputType | null
  }

  type GetIssueCommentGroupByPayload<T extends IssueCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueCommentGroupByOutputType[P]>
            : GetScalarType<T[P], IssueCommentGroupByOutputType[P]>
        }
      >
    >


  export type IssueCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueComment"]>

  export type IssueCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueComment"]>

  export type IssueCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueComment"]>

  export type IssueCommentSelectScalar = {
    id?: boolean
    issueId?: boolean
    authorId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type IssueCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "issueId" | "authorId" | "message" | "createdAt", ExtArgs["result"]["issueComment"]>
  export type IssueCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IssueCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IssueCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IssueCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IssueComment"
    objects: {
      issue: Prisma.$IssuePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      issueId: number
      authorId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["issueComment"]>
    composites: {}
  }

  type IssueCommentGetPayload<S extends boolean | null | undefined | IssueCommentDefaultArgs> = $Result.GetResult<Prisma.$IssueCommentPayload, S>

  type IssueCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssueCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueCommentCountAggregateInputType | true
    }

  export interface IssueCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IssueComment'], meta: { name: 'IssueComment' } }
    /**
     * Find zero or one IssueComment that matches the filter.
     * @param {IssueCommentFindUniqueArgs} args - Arguments to find a IssueComment
     * @example
     * // Get one IssueComment
     * const issueComment = await prisma.issueComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssueCommentFindUniqueArgs>(args: SelectSubset<T, IssueCommentFindUniqueArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IssueComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssueCommentFindUniqueOrThrowArgs} args - Arguments to find a IssueComment
     * @example
     * // Get one IssueComment
     * const issueComment = await prisma.issueComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssueCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, IssueCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentFindFirstArgs} args - Arguments to find a IssueComment
     * @example
     * // Get one IssueComment
     * const issueComment = await prisma.issueComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssueCommentFindFirstArgs>(args?: SelectSubset<T, IssueCommentFindFirstArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentFindFirstOrThrowArgs} args - Arguments to find a IssueComment
     * @example
     * // Get one IssueComment
     * const issueComment = await prisma.issueComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssueCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, IssueCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IssueComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IssueComments
     * const issueComments = await prisma.issueComment.findMany()
     * 
     * // Get first 10 IssueComments
     * const issueComments = await prisma.issueComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueCommentWithIdOnly = await prisma.issueComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssueCommentFindManyArgs>(args?: SelectSubset<T, IssueCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IssueComment.
     * @param {IssueCommentCreateArgs} args - Arguments to create a IssueComment.
     * @example
     * // Create one IssueComment
     * const IssueComment = await prisma.issueComment.create({
     *   data: {
     *     // ... data to create a IssueComment
     *   }
     * })
     * 
     */
    create<T extends IssueCommentCreateArgs>(args: SelectSubset<T, IssueCommentCreateArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IssueComments.
     * @param {IssueCommentCreateManyArgs} args - Arguments to create many IssueComments.
     * @example
     * // Create many IssueComments
     * const issueComment = await prisma.issueComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssueCommentCreateManyArgs>(args?: SelectSubset<T, IssueCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IssueComments and returns the data saved in the database.
     * @param {IssueCommentCreateManyAndReturnArgs} args - Arguments to create many IssueComments.
     * @example
     * // Create many IssueComments
     * const issueComment = await prisma.issueComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IssueComments and only return the `id`
     * const issueCommentWithIdOnly = await prisma.issueComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssueCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, IssueCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IssueComment.
     * @param {IssueCommentDeleteArgs} args - Arguments to delete one IssueComment.
     * @example
     * // Delete one IssueComment
     * const IssueComment = await prisma.issueComment.delete({
     *   where: {
     *     // ... filter to delete one IssueComment
     *   }
     * })
     * 
     */
    delete<T extends IssueCommentDeleteArgs>(args: SelectSubset<T, IssueCommentDeleteArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IssueComment.
     * @param {IssueCommentUpdateArgs} args - Arguments to update one IssueComment.
     * @example
     * // Update one IssueComment
     * const issueComment = await prisma.issueComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssueCommentUpdateArgs>(args: SelectSubset<T, IssueCommentUpdateArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IssueComments.
     * @param {IssueCommentDeleteManyArgs} args - Arguments to filter IssueComments to delete.
     * @example
     * // Delete a few IssueComments
     * const { count } = await prisma.issueComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssueCommentDeleteManyArgs>(args?: SelectSubset<T, IssueCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IssueComments
     * const issueComment = await prisma.issueComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssueCommentUpdateManyArgs>(args: SelectSubset<T, IssueCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueComments and returns the data updated in the database.
     * @param {IssueCommentUpdateManyAndReturnArgs} args - Arguments to update many IssueComments.
     * @example
     * // Update many IssueComments
     * const issueComment = await prisma.issueComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IssueComments and only return the `id`
     * const issueCommentWithIdOnly = await prisma.issueComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssueCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, IssueCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IssueComment.
     * @param {IssueCommentUpsertArgs} args - Arguments to update or create a IssueComment.
     * @example
     * // Update or create a IssueComment
     * const issueComment = await prisma.issueComment.upsert({
     *   create: {
     *     // ... data to create a IssueComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IssueComment we want to update
     *   }
     * })
     */
    upsert<T extends IssueCommentUpsertArgs>(args: SelectSubset<T, IssueCommentUpsertArgs<ExtArgs>>): Prisma__IssueCommentClient<$Result.GetResult<Prisma.$IssueCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IssueComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentCountArgs} args - Arguments to filter IssueComments to count.
     * @example
     * // Count the number of IssueComments
     * const count = await prisma.issueComment.count({
     *   where: {
     *     // ... the filter for the IssueComments we want to count
     *   }
     * })
    **/
    count<T extends IssueCommentCountArgs>(
      args?: Subset<T, IssueCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IssueComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueCommentAggregateArgs>(args: Subset<T, IssueCommentAggregateArgs>): Prisma.PrismaPromise<GetIssueCommentAggregateType<T>>

    /**
     * Group by IssueComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueCommentGroupByArgs['orderBy'] }
        : { orderBy?: IssueCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IssueComment model
   */
  readonly fields: IssueCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IssueComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issue<T extends IssueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IssueDefaultArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IssueComment model
   */
  interface IssueCommentFieldRefs {
    readonly id: FieldRef<"IssueComment", 'Int'>
    readonly issueId: FieldRef<"IssueComment", 'Int'>
    readonly authorId: FieldRef<"IssueComment", 'Int'>
    readonly message: FieldRef<"IssueComment", 'String'>
    readonly createdAt: FieldRef<"IssueComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IssueComment findUnique
   */
  export type IssueCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter, which IssueComment to fetch.
     */
    where: IssueCommentWhereUniqueInput
  }

  /**
   * IssueComment findUniqueOrThrow
   */
  export type IssueCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter, which IssueComment to fetch.
     */
    where: IssueCommentWhereUniqueInput
  }

  /**
   * IssueComment findFirst
   */
  export type IssueCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter, which IssueComment to fetch.
     */
    where?: IssueCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueComments to fetch.
     */
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IssueComments.
     */
    cursor?: IssueCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IssueComments.
     */
    distinct?: IssueCommentScalarFieldEnum | IssueCommentScalarFieldEnum[]
  }

  /**
   * IssueComment findFirstOrThrow
   */
  export type IssueCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter, which IssueComment to fetch.
     */
    where?: IssueCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueComments to fetch.
     */
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IssueComments.
     */
    cursor?: IssueCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IssueComments.
     */
    distinct?: IssueCommentScalarFieldEnum | IssueCommentScalarFieldEnum[]
  }

  /**
   * IssueComment findMany
   */
  export type IssueCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter, which IssueComments to fetch.
     */
    where?: IssueCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueComments to fetch.
     */
    orderBy?: IssueCommentOrderByWithRelationInput | IssueCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IssueComments.
     */
    cursor?: IssueCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueComments.
     */
    skip?: number
    distinct?: IssueCommentScalarFieldEnum | IssueCommentScalarFieldEnum[]
  }

  /**
   * IssueComment create
   */
  export type IssueCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a IssueComment.
     */
    data: XOR<IssueCommentCreateInput, IssueCommentUncheckedCreateInput>
  }

  /**
   * IssueComment createMany
   */
  export type IssueCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IssueComments.
     */
    data: IssueCommentCreateManyInput | IssueCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IssueComment createManyAndReturn
   */
  export type IssueCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * The data used to create many IssueComments.
     */
    data: IssueCommentCreateManyInput | IssueCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IssueComment update
   */
  export type IssueCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a IssueComment.
     */
    data: XOR<IssueCommentUpdateInput, IssueCommentUncheckedUpdateInput>
    /**
     * Choose, which IssueComment to update.
     */
    where: IssueCommentWhereUniqueInput
  }

  /**
   * IssueComment updateMany
   */
  export type IssueCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IssueComments.
     */
    data: XOR<IssueCommentUpdateManyMutationInput, IssueCommentUncheckedUpdateManyInput>
    /**
     * Filter which IssueComments to update
     */
    where?: IssueCommentWhereInput
    /**
     * Limit how many IssueComments to update.
     */
    limit?: number
  }

  /**
   * IssueComment updateManyAndReturn
   */
  export type IssueCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * The data used to update IssueComments.
     */
    data: XOR<IssueCommentUpdateManyMutationInput, IssueCommentUncheckedUpdateManyInput>
    /**
     * Filter which IssueComments to update
     */
    where?: IssueCommentWhereInput
    /**
     * Limit how many IssueComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IssueComment upsert
   */
  export type IssueCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the IssueComment to update in case it exists.
     */
    where: IssueCommentWhereUniqueInput
    /**
     * In case the IssueComment found by the `where` argument doesn't exist, create a new IssueComment with this data.
     */
    create: XOR<IssueCommentCreateInput, IssueCommentUncheckedCreateInput>
    /**
     * In case the IssueComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueCommentUpdateInput, IssueCommentUncheckedUpdateInput>
  }

  /**
   * IssueComment delete
   */
  export type IssueCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
    /**
     * Filter which IssueComment to delete.
     */
    where: IssueCommentWhereUniqueInput
  }

  /**
   * IssueComment deleteMany
   */
  export type IssueCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IssueComments to delete
     */
    where?: IssueCommentWhereInput
    /**
     * Limit how many IssueComments to delete.
     */
    limit?: number
  }

  /**
   * IssueComment without action
   */
  export type IssueCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueComment
     */
    select?: IssueCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueComment
     */
    omit?: IssueCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueCommentInclude<ExtArgs> | null
  }


  /**
   * Model IssueAttachment
   */

  export type AggregateIssueAttachment = {
    _count: IssueAttachmentCountAggregateOutputType | null
    _avg: IssueAttachmentAvgAggregateOutputType | null
    _sum: IssueAttachmentSumAggregateOutputType | null
    _min: IssueAttachmentMinAggregateOutputType | null
    _max: IssueAttachmentMaxAggregateOutputType | null
  }

  export type IssueAttachmentAvgAggregateOutputType = {
    id: number | null
    issueId: number | null
  }

  export type IssueAttachmentSumAggregateOutputType = {
    id: number | null
    issueId: number | null
  }

  export type IssueAttachmentMinAggregateOutputType = {
    id: number | null
    issueId: number | null
    filename: string | null
    url: string | null
    contentType: string | null
    createdAt: Date | null
  }

  export type IssueAttachmentMaxAggregateOutputType = {
    id: number | null
    issueId: number | null
    filename: string | null
    url: string | null
    contentType: string | null
    createdAt: Date | null
  }

  export type IssueAttachmentCountAggregateOutputType = {
    id: number
    issueId: number
    filename: number
    url: number
    contentType: number
    createdAt: number
    _all: number
  }


  export type IssueAttachmentAvgAggregateInputType = {
    id?: true
    issueId?: true
  }

  export type IssueAttachmentSumAggregateInputType = {
    id?: true
    issueId?: true
  }

  export type IssueAttachmentMinAggregateInputType = {
    id?: true
    issueId?: true
    filename?: true
    url?: true
    contentType?: true
    createdAt?: true
  }

  export type IssueAttachmentMaxAggregateInputType = {
    id?: true
    issueId?: true
    filename?: true
    url?: true
    contentType?: true
    createdAt?: true
  }

  export type IssueAttachmentCountAggregateInputType = {
    id?: true
    issueId?: true
    filename?: true
    url?: true
    contentType?: true
    createdAt?: true
    _all?: true
  }

  export type IssueAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IssueAttachment to aggregate.
     */
    where?: IssueAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueAttachments to fetch.
     */
    orderBy?: IssueAttachmentOrderByWithRelationInput | IssueAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IssueAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IssueAttachments
    **/
    _count?: true | IssueAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IssueAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IssueAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IssueAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IssueAttachmentMaxAggregateInputType
  }

  export type GetIssueAttachmentAggregateType<T extends IssueAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateIssueAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIssueAttachment[P]>
      : GetScalarType<T[P], AggregateIssueAttachment[P]>
  }




  export type IssueAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IssueAttachmentWhereInput
    orderBy?: IssueAttachmentOrderByWithAggregationInput | IssueAttachmentOrderByWithAggregationInput[]
    by: IssueAttachmentScalarFieldEnum[] | IssueAttachmentScalarFieldEnum
    having?: IssueAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IssueAttachmentCountAggregateInputType | true
    _avg?: IssueAttachmentAvgAggregateInputType
    _sum?: IssueAttachmentSumAggregateInputType
    _min?: IssueAttachmentMinAggregateInputType
    _max?: IssueAttachmentMaxAggregateInputType
  }

  export type IssueAttachmentGroupByOutputType = {
    id: number
    issueId: number
    filename: string
    url: string
    contentType: string | null
    createdAt: Date
    _count: IssueAttachmentCountAggregateOutputType | null
    _avg: IssueAttachmentAvgAggregateOutputType | null
    _sum: IssueAttachmentSumAggregateOutputType | null
    _min: IssueAttachmentMinAggregateOutputType | null
    _max: IssueAttachmentMaxAggregateOutputType | null
  }

  type GetIssueAttachmentGroupByPayload<T extends IssueAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IssueAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IssueAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IssueAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], IssueAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type IssueAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    filename?: boolean
    url?: boolean
    contentType?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueAttachment"]>

  export type IssueAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    filename?: boolean
    url?: boolean
    contentType?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueAttachment"]>

  export type IssueAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    issueId?: boolean
    filename?: boolean
    url?: boolean
    contentType?: boolean
    createdAt?: boolean
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["issueAttachment"]>

  export type IssueAttachmentSelectScalar = {
    id?: boolean
    issueId?: boolean
    filename?: boolean
    url?: boolean
    contentType?: boolean
    createdAt?: boolean
  }

  export type IssueAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "issueId" | "filename" | "url" | "contentType" | "createdAt", ExtArgs["result"]["issueAttachment"]>
  export type IssueAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type IssueAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }
  export type IssueAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    issue?: boolean | IssueDefaultArgs<ExtArgs>
  }

  export type $IssueAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IssueAttachment"
    objects: {
      issue: Prisma.$IssuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      issueId: number
      filename: string
      url: string
      contentType: string | null
      createdAt: Date
    }, ExtArgs["result"]["issueAttachment"]>
    composites: {}
  }

  type IssueAttachmentGetPayload<S extends boolean | null | undefined | IssueAttachmentDefaultArgs> = $Result.GetResult<Prisma.$IssueAttachmentPayload, S>

  type IssueAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IssueAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IssueAttachmentCountAggregateInputType | true
    }

  export interface IssueAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IssueAttachment'], meta: { name: 'IssueAttachment' } }
    /**
     * Find zero or one IssueAttachment that matches the filter.
     * @param {IssueAttachmentFindUniqueArgs} args - Arguments to find a IssueAttachment
     * @example
     * // Get one IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IssueAttachmentFindUniqueArgs>(args: SelectSubset<T, IssueAttachmentFindUniqueArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one IssueAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IssueAttachmentFindUniqueOrThrowArgs} args - Arguments to find a IssueAttachment
     * @example
     * // Get one IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IssueAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, IssueAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentFindFirstArgs} args - Arguments to find a IssueAttachment
     * @example
     * // Get one IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IssueAttachmentFindFirstArgs>(args?: SelectSubset<T, IssueAttachmentFindFirstArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first IssueAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentFindFirstOrThrowArgs} args - Arguments to find a IssueAttachment
     * @example
     * // Get one IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IssueAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, IssueAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more IssueAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IssueAttachments
     * const issueAttachments = await prisma.issueAttachment.findMany()
     * 
     * // Get first 10 IssueAttachments
     * const issueAttachments = await prisma.issueAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const issueAttachmentWithIdOnly = await prisma.issueAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IssueAttachmentFindManyArgs>(args?: SelectSubset<T, IssueAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a IssueAttachment.
     * @param {IssueAttachmentCreateArgs} args - Arguments to create a IssueAttachment.
     * @example
     * // Create one IssueAttachment
     * const IssueAttachment = await prisma.issueAttachment.create({
     *   data: {
     *     // ... data to create a IssueAttachment
     *   }
     * })
     * 
     */
    create<T extends IssueAttachmentCreateArgs>(args: SelectSubset<T, IssueAttachmentCreateArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many IssueAttachments.
     * @param {IssueAttachmentCreateManyArgs} args - Arguments to create many IssueAttachments.
     * @example
     * // Create many IssueAttachments
     * const issueAttachment = await prisma.issueAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IssueAttachmentCreateManyArgs>(args?: SelectSubset<T, IssueAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IssueAttachments and returns the data saved in the database.
     * @param {IssueAttachmentCreateManyAndReturnArgs} args - Arguments to create many IssueAttachments.
     * @example
     * // Create many IssueAttachments
     * const issueAttachment = await prisma.issueAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IssueAttachments and only return the `id`
     * const issueAttachmentWithIdOnly = await prisma.issueAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IssueAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, IssueAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a IssueAttachment.
     * @param {IssueAttachmentDeleteArgs} args - Arguments to delete one IssueAttachment.
     * @example
     * // Delete one IssueAttachment
     * const IssueAttachment = await prisma.issueAttachment.delete({
     *   where: {
     *     // ... filter to delete one IssueAttachment
     *   }
     * })
     * 
     */
    delete<T extends IssueAttachmentDeleteArgs>(args: SelectSubset<T, IssueAttachmentDeleteArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one IssueAttachment.
     * @param {IssueAttachmentUpdateArgs} args - Arguments to update one IssueAttachment.
     * @example
     * // Update one IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IssueAttachmentUpdateArgs>(args: SelectSubset<T, IssueAttachmentUpdateArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more IssueAttachments.
     * @param {IssueAttachmentDeleteManyArgs} args - Arguments to filter IssueAttachments to delete.
     * @example
     * // Delete a few IssueAttachments
     * const { count } = await prisma.issueAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IssueAttachmentDeleteManyArgs>(args?: SelectSubset<T, IssueAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IssueAttachments
     * const issueAttachment = await prisma.issueAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IssueAttachmentUpdateManyArgs>(args: SelectSubset<T, IssueAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IssueAttachments and returns the data updated in the database.
     * @param {IssueAttachmentUpdateManyAndReturnArgs} args - Arguments to update many IssueAttachments.
     * @example
     * // Update many IssueAttachments
     * const issueAttachment = await prisma.issueAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more IssueAttachments and only return the `id`
     * const issueAttachmentWithIdOnly = await prisma.issueAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IssueAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, IssueAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one IssueAttachment.
     * @param {IssueAttachmentUpsertArgs} args - Arguments to update or create a IssueAttachment.
     * @example
     * // Update or create a IssueAttachment
     * const issueAttachment = await prisma.issueAttachment.upsert({
     *   create: {
     *     // ... data to create a IssueAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IssueAttachment we want to update
     *   }
     * })
     */
    upsert<T extends IssueAttachmentUpsertArgs>(args: SelectSubset<T, IssueAttachmentUpsertArgs<ExtArgs>>): Prisma__IssueAttachmentClient<$Result.GetResult<Prisma.$IssueAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of IssueAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentCountArgs} args - Arguments to filter IssueAttachments to count.
     * @example
     * // Count the number of IssueAttachments
     * const count = await prisma.issueAttachment.count({
     *   where: {
     *     // ... the filter for the IssueAttachments we want to count
     *   }
     * })
    **/
    count<T extends IssueAttachmentCountArgs>(
      args?: Subset<T, IssueAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IssueAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IssueAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IssueAttachmentAggregateArgs>(args: Subset<T, IssueAttachmentAggregateArgs>): Prisma.PrismaPromise<GetIssueAttachmentAggregateType<T>>

    /**
     * Group by IssueAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IssueAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IssueAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IssueAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: IssueAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IssueAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IssueAttachment model
   */
  readonly fields: IssueAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IssueAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IssueAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    issue<T extends IssueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IssueDefaultArgs<ExtArgs>>): Prisma__IssueClient<$Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IssueAttachment model
   */
  interface IssueAttachmentFieldRefs {
    readonly id: FieldRef<"IssueAttachment", 'Int'>
    readonly issueId: FieldRef<"IssueAttachment", 'Int'>
    readonly filename: FieldRef<"IssueAttachment", 'String'>
    readonly url: FieldRef<"IssueAttachment", 'String'>
    readonly contentType: FieldRef<"IssueAttachment", 'String'>
    readonly createdAt: FieldRef<"IssueAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IssueAttachment findUnique
   */
  export type IssueAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which IssueAttachment to fetch.
     */
    where: IssueAttachmentWhereUniqueInput
  }

  /**
   * IssueAttachment findUniqueOrThrow
   */
  export type IssueAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which IssueAttachment to fetch.
     */
    where: IssueAttachmentWhereUniqueInput
  }

  /**
   * IssueAttachment findFirst
   */
  export type IssueAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which IssueAttachment to fetch.
     */
    where?: IssueAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueAttachments to fetch.
     */
    orderBy?: IssueAttachmentOrderByWithRelationInput | IssueAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IssueAttachments.
     */
    cursor?: IssueAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IssueAttachments.
     */
    distinct?: IssueAttachmentScalarFieldEnum | IssueAttachmentScalarFieldEnum[]
  }

  /**
   * IssueAttachment findFirstOrThrow
   */
  export type IssueAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which IssueAttachment to fetch.
     */
    where?: IssueAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueAttachments to fetch.
     */
    orderBy?: IssueAttachmentOrderByWithRelationInput | IssueAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IssueAttachments.
     */
    cursor?: IssueAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IssueAttachments.
     */
    distinct?: IssueAttachmentScalarFieldEnum | IssueAttachmentScalarFieldEnum[]
  }

  /**
   * IssueAttachment findMany
   */
  export type IssueAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which IssueAttachments to fetch.
     */
    where?: IssueAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IssueAttachments to fetch.
     */
    orderBy?: IssueAttachmentOrderByWithRelationInput | IssueAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IssueAttachments.
     */
    cursor?: IssueAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IssueAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IssueAttachments.
     */
    skip?: number
    distinct?: IssueAttachmentScalarFieldEnum | IssueAttachmentScalarFieldEnum[]
  }

  /**
   * IssueAttachment create
   */
  export type IssueAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a IssueAttachment.
     */
    data: XOR<IssueAttachmentCreateInput, IssueAttachmentUncheckedCreateInput>
  }

  /**
   * IssueAttachment createMany
   */
  export type IssueAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IssueAttachments.
     */
    data: IssueAttachmentCreateManyInput | IssueAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IssueAttachment createManyAndReturn
   */
  export type IssueAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many IssueAttachments.
     */
    data: IssueAttachmentCreateManyInput | IssueAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IssueAttachment update
   */
  export type IssueAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a IssueAttachment.
     */
    data: XOR<IssueAttachmentUpdateInput, IssueAttachmentUncheckedUpdateInput>
    /**
     * Choose, which IssueAttachment to update.
     */
    where: IssueAttachmentWhereUniqueInput
  }

  /**
   * IssueAttachment updateMany
   */
  export type IssueAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IssueAttachments.
     */
    data: XOR<IssueAttachmentUpdateManyMutationInput, IssueAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which IssueAttachments to update
     */
    where?: IssueAttachmentWhereInput
    /**
     * Limit how many IssueAttachments to update.
     */
    limit?: number
  }

  /**
   * IssueAttachment updateManyAndReturn
   */
  export type IssueAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update IssueAttachments.
     */
    data: XOR<IssueAttachmentUpdateManyMutationInput, IssueAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which IssueAttachments to update
     */
    where?: IssueAttachmentWhereInput
    /**
     * Limit how many IssueAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * IssueAttachment upsert
   */
  export type IssueAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the IssueAttachment to update in case it exists.
     */
    where: IssueAttachmentWhereUniqueInput
    /**
     * In case the IssueAttachment found by the `where` argument doesn't exist, create a new IssueAttachment with this data.
     */
    create: XOR<IssueAttachmentCreateInput, IssueAttachmentUncheckedCreateInput>
    /**
     * In case the IssueAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IssueAttachmentUpdateInput, IssueAttachmentUncheckedUpdateInput>
  }

  /**
   * IssueAttachment delete
   */
  export type IssueAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
    /**
     * Filter which IssueAttachment to delete.
     */
    where: IssueAttachmentWhereUniqueInput
  }

  /**
   * IssueAttachment deleteMany
   */
  export type IssueAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IssueAttachments to delete
     */
    where?: IssueAttachmentWhereInput
    /**
     * Limit how many IssueAttachments to delete.
     */
    limit?: number
  }

  /**
   * IssueAttachment without action
   */
  export type IssueAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IssueAttachment
     */
    select?: IssueAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the IssueAttachment
     */
    omit?: IssueAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IssueAttachmentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isAdmin: 'isAdmin',
    isNoteManager: 'isNoteManager',
    isNoteTaker: 'isNoteTaker',
    isHousekeeper: 'isHousekeeper',
    isHousekeepingLead: 'isHousekeepingLead',
    description: 'description',
    departmentId: 'departmentId'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    email: 'email',
    positionId: 'positionId',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MeetingRoomScalarFieldEnum: {
    id: 'id',
    roomName: 'roomName',
    capacity: 'capacity',
    status: 'status'
  };

  export type MeetingRoomScalarFieldEnum = (typeof MeetingRoomScalarFieldEnum)[keyof typeof MeetingRoomScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    bookedById: 'bookedById',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    purpose: 'purpose',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingRequiredPositionScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    positionId: 'positionId'
  };

  export type BookingRequiredPositionScalarFieldEnum = (typeof BookingRequiredPositionScalarFieldEnum)[keyof typeof BookingRequiredPositionScalarFieldEnum]


  export const BookingInviteScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    userId: 'userId',
    status: 'status',
    respondedAt: 'respondedAt'
  };

  export type BookingInviteScalarFieldEnum = (typeof BookingInviteScalarFieldEnum)[keyof typeof BookingInviteScalarFieldEnum]


  export const BookingNoteTakerScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    userId: 'userId',
    roleIndex: 'roleIndex',
    status: 'status'
  };

  export type BookingNoteTakerScalarFieldEnum = (typeof BookingNoteTakerScalarFieldEnum)[keyof typeof BookingNoteTakerScalarFieldEnum]


  export const NoteTakerQueueScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    orderNo: 'orderNo',
    isActive: 'isActive'
  };

  export type NoteTakerQueueScalarFieldEnum = (typeof NoteTakerQueueScalarFieldEnum)[keyof typeof NoteTakerQueueScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    departmentId: 'departmentId',
    requiresApproval: 'requiresApproval'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const BookingServiceScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    serviceId: 'serviceId',
    quantity: 'quantity',
    status: 'status'
  };

  export type BookingServiceScalarFieldEnum = (typeof BookingServiceScalarFieldEnum)[keyof typeof BookingServiceScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    refType: 'refType',
    refId: 'refId',
    isRead: 'isRead',
    createdAt: 'createdAt',
    readAt: 'readAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NoteTakerLeaveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type NoteTakerLeaveScalarFieldEnum = (typeof NoteTakerLeaveScalarFieldEnum)[keyof typeof NoteTakerLeaveScalarFieldEnum]


  export const HousekeepingTaskScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    serviceId: 'serviceId',
    status: 'status',
    assignedToId: 'assignedToId',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HousekeepingTaskScalarFieldEnum = (typeof HousekeepingTaskScalarFieldEnum)[keyof typeof HousekeepingTaskScalarFieldEnum]


  export const IssueScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    roomId: 'roomId',
    issueType: 'issueType',
    subject: 'subject',
    description: 'description',
    priority: 'priority',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


  export const IssueCommentScalarFieldEnum: {
    id: 'id',
    issueId: 'issueId',
    authorId: 'authorId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type IssueCommentScalarFieldEnum = (typeof IssueCommentScalarFieldEnum)[keyof typeof IssueCommentScalarFieldEnum]


  export const IssueAttachmentScalarFieldEnum: {
    id: 'id',
    issueId: 'issueId',
    filename: 'filename',
    url: 'url',
    contentType: 'contentType',
    createdAt: 'createdAt'
  };

  export type IssueAttachmentScalarFieldEnum = (typeof IssueAttachmentScalarFieldEnum)[keyof typeof IssueAttachmentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'RoomStatus'
   */
  export type EnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus'>
    


  /**
   * Reference to a field of type 'RoomStatus[]'
   */
  export type ListEnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'NoteQueueStatus'
   */
  export type EnumNoteQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteQueueStatus'>
    


  /**
   * Reference to a field of type 'NoteQueueStatus[]'
   */
  export type ListEnumNoteQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteQueueStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus'>
    


  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus[]'>
    


  /**
   * Reference to a field of type 'NotifType'
   */
  export type EnumNotifTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotifType'>
    


  /**
   * Reference to a field of type 'NotifType[]'
   */
  export type ListEnumNotifTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotifType[]'>
    


  /**
   * Reference to a field of type 'RefType'
   */
  export type EnumRefTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefType'>
    


  /**
   * Reference to a field of type 'RefType[]'
   */
  export type ListEnumRefTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefType[]'>
    


  /**
   * Reference to a field of type 'HousekeepingTaskStatus'
   */
  export type EnumHousekeepingTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HousekeepingTaskStatus'>
    


  /**
   * Reference to a field of type 'HousekeepingTaskStatus[]'
   */
  export type ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HousekeepingTaskStatus[]'>
    


  /**
   * Reference to a field of type 'IssueType'
   */
  export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType'>
    


  /**
   * Reference to a field of type 'IssueType[]'
   */
  export type ListEnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType[]'>
    


  /**
   * Reference to a field of type 'IssuePriority'
   */
  export type EnumIssuePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssuePriority'>
    


  /**
   * Reference to a field of type 'IssuePriority[]'
   */
  export type ListEnumIssuePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssuePriority[]'>
    


  /**
   * Reference to a field of type 'IssueStatus'
   */
  export type EnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus'>
    


  /**
   * Reference to a field of type 'IssueStatus[]'
   */
  export type ListEnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    positions?: PositionListRelationFilter
    services?: ServiceListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    positions?: PositionOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    positions?: PositionListRelationFilter
    services?: ServiceListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: IntFilter<"Position"> | number
    name?: StringFilter<"Position"> | string
    isAdmin?: BoolFilter<"Position"> | boolean
    isNoteManager?: BoolFilter<"Position"> | boolean
    isNoteTaker?: BoolFilter<"Position"> | boolean
    isHousekeeper?: BoolFilter<"Position"> | boolean
    isHousekeepingLead?: BoolFilter<"Position"> | boolean
    description?: StringNullableFilter<"Position"> | string | null
    departmentId?: IntNullableFilter<"Position"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    users?: UserListRelationFilter
    neededBy?: BookingRequiredPositionListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    isNoteManager?: SortOrder
    isNoteTaker?: SortOrder
    isHousekeeper?: SortOrder
    isHousekeepingLead?: SortOrder
    description?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
    neededBy?: BookingRequiredPositionOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    isAdmin?: BoolFilter<"Position"> | boolean
    isNoteManager?: BoolFilter<"Position"> | boolean
    isNoteTaker?: BoolFilter<"Position"> | boolean
    isHousekeeper?: BoolFilter<"Position"> | boolean
    isHousekeepingLead?: BoolFilter<"Position"> | boolean
    description?: StringNullableFilter<"Position"> | string | null
    departmentId?: IntNullableFilter<"Position"> | number | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    users?: UserListRelationFilter
    neededBy?: BookingRequiredPositionListRelationFilter
  }, "id" | "name">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    isNoteManager?: SortOrder
    isNoteTaker?: SortOrder
    isHousekeeper?: SortOrder
    isHousekeepingLead?: SortOrder
    description?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Position"> | number
    name?: StringWithAggregatesFilter<"Position"> | string
    isAdmin?: BoolWithAggregatesFilter<"Position"> | boolean
    isNoteManager?: BoolWithAggregatesFilter<"Position"> | boolean
    isNoteTaker?: BoolWithAggregatesFilter<"Position"> | boolean
    isHousekeeper?: BoolWithAggregatesFilter<"Position"> | boolean
    isHousekeepingLead?: BoolWithAggregatesFilter<"Position"> | boolean
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    departmentId?: IntNullableWithAggregatesFilter<"Position"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    positionId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    bookingsBooked?: BookingListRelationFilter
    bookingInvites?: BookingInviteListRelationFilter
    noteTakerAssigns?: BookingNoteTakerListRelationFilter
    notifications?: NotificationListRelationFilter
    noteTakerQueue?: XOR<NoteTakerQueueNullableScalarRelationFilter, NoteTakerQueueWhereInput> | null
    noteTakerLeaves?: NoteTakerLeaveListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
    reportedIssues?: IssueListRelationFilter
    issueComments?: IssueCommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    email?: SortOrderInput | SortOrder
    positionId?: SortOrder
    createdAt?: SortOrder
    position?: PositionOrderByWithRelationInput
    bookingsBooked?: BookingOrderByRelationAggregateInput
    bookingInvites?: BookingInviteOrderByRelationAggregateInput
    noteTakerAssigns?: BookingNoteTakerOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    noteTakerQueue?: NoteTakerQueueOrderByWithRelationInput
    noteTakerLeaves?: NoteTakerLeaveOrderByRelationAggregateInput
    housekeepingTasks?: HousekeepingTaskOrderByRelationAggregateInput
    reportedIssues?: IssueOrderByRelationAggregateInput
    issueComments?: IssueCommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    positionId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    bookingsBooked?: BookingListRelationFilter
    bookingInvites?: BookingInviteListRelationFilter
    noteTakerAssigns?: BookingNoteTakerListRelationFilter
    notifications?: NotificationListRelationFilter
    noteTakerQueue?: XOR<NoteTakerQueueNullableScalarRelationFilter, NoteTakerQueueWhereInput> | null
    noteTakerLeaves?: NoteTakerLeaveListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
    reportedIssues?: IssueListRelationFilter
    issueComments?: IssueCommentListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    email?: SortOrderInput | SortOrder
    positionId?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    positionId?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MeetingRoomWhereInput = {
    AND?: MeetingRoomWhereInput | MeetingRoomWhereInput[]
    OR?: MeetingRoomWhereInput[]
    NOT?: MeetingRoomWhereInput | MeetingRoomWhereInput[]
    id?: IntFilter<"MeetingRoom"> | number
    roomName?: StringFilter<"MeetingRoom"> | string
    capacity?: IntFilter<"MeetingRoom"> | number
    status?: EnumRoomStatusFilter<"MeetingRoom"> | $Enums.RoomStatus
    bookings?: BookingListRelationFilter
    issues?: IssueListRelationFilter
  }

  export type MeetingRoomOrderByWithRelationInput = {
    id?: SortOrder
    roomName?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    issues?: IssueOrderByRelationAggregateInput
  }

  export type MeetingRoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roomName?: string
    AND?: MeetingRoomWhereInput | MeetingRoomWhereInput[]
    OR?: MeetingRoomWhereInput[]
    NOT?: MeetingRoomWhereInput | MeetingRoomWhereInput[]
    capacity?: IntFilter<"MeetingRoom"> | number
    status?: EnumRoomStatusFilter<"MeetingRoom"> | $Enums.RoomStatus
    bookings?: BookingListRelationFilter
    issues?: IssueListRelationFilter
  }, "id" | "roomName">

  export type MeetingRoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomName?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
    _count?: MeetingRoomCountOrderByAggregateInput
    _avg?: MeetingRoomAvgOrderByAggregateInput
    _max?: MeetingRoomMaxOrderByAggregateInput
    _min?: MeetingRoomMinOrderByAggregateInput
    _sum?: MeetingRoomSumOrderByAggregateInput
  }

  export type MeetingRoomScalarWhereWithAggregatesInput = {
    AND?: MeetingRoomScalarWhereWithAggregatesInput | MeetingRoomScalarWhereWithAggregatesInput[]
    OR?: MeetingRoomScalarWhereWithAggregatesInput[]
    NOT?: MeetingRoomScalarWhereWithAggregatesInput | MeetingRoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MeetingRoom"> | number
    roomName?: StringWithAggregatesFilter<"MeetingRoom"> | string
    capacity?: IntWithAggregatesFilter<"MeetingRoom"> | number
    status?: EnumRoomStatusWithAggregatesFilter<"MeetingRoom"> | $Enums.RoomStatus
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    roomId?: IntFilter<"Booking"> | number
    bookedById?: IntFilter<"Booking"> | number
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    purpose?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    room?: XOR<MeetingRoomScalarRelationFilter, MeetingRoomWhereInput>
    bookedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requiredPositions?: BookingRequiredPositionListRelationFilter
    invites?: BookingInviteListRelationFilter
    noteTakers?: BookingNoteTakerListRelationFilter
    services?: BookingServiceListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    purpose?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    room?: MeetingRoomOrderByWithRelationInput
    bookedBy?: UserOrderByWithRelationInput
    requiredPositions?: BookingRequiredPositionOrderByRelationAggregateInput
    invites?: BookingInviteOrderByRelationAggregateInput
    noteTakers?: BookingNoteTakerOrderByRelationAggregateInput
    services?: BookingServiceOrderByRelationAggregateInput
    housekeepingTasks?: HousekeepingTaskOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    roomId?: IntFilter<"Booking"> | number
    bookedById?: IntFilter<"Booking"> | number
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    purpose?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    room?: XOR<MeetingRoomScalarRelationFilter, MeetingRoomWhereInput>
    bookedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    requiredPositions?: BookingRequiredPositionListRelationFilter
    invites?: BookingInviteListRelationFilter
    noteTakers?: BookingNoteTakerListRelationFilter
    services?: BookingServiceListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    purpose?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    roomId?: IntWithAggregatesFilter<"Booking"> | number
    bookedById?: IntWithAggregatesFilter<"Booking"> | number
    startTime?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    purpose?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type BookingRequiredPositionWhereInput = {
    AND?: BookingRequiredPositionWhereInput | BookingRequiredPositionWhereInput[]
    OR?: BookingRequiredPositionWhereInput[]
    NOT?: BookingRequiredPositionWhereInput | BookingRequiredPositionWhereInput[]
    id?: IntFilter<"BookingRequiredPosition"> | number
    bookingId?: IntFilter<"BookingRequiredPosition"> | number
    positionId?: IntFilter<"BookingRequiredPosition"> | number
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
  }

  export type BookingRequiredPositionOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
    booking?: BookingOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
  }

  export type BookingRequiredPositionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingRequiredPositionWhereInput | BookingRequiredPositionWhereInput[]
    OR?: BookingRequiredPositionWhereInput[]
    NOT?: BookingRequiredPositionWhereInput | BookingRequiredPositionWhereInput[]
    bookingId?: IntFilter<"BookingRequiredPosition"> | number
    positionId?: IntFilter<"BookingRequiredPosition"> | number
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
  }, "id">

  export type BookingRequiredPositionOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
    _count?: BookingRequiredPositionCountOrderByAggregateInput
    _avg?: BookingRequiredPositionAvgOrderByAggregateInput
    _max?: BookingRequiredPositionMaxOrderByAggregateInput
    _min?: BookingRequiredPositionMinOrderByAggregateInput
    _sum?: BookingRequiredPositionSumOrderByAggregateInput
  }

  export type BookingRequiredPositionScalarWhereWithAggregatesInput = {
    AND?: BookingRequiredPositionScalarWhereWithAggregatesInput | BookingRequiredPositionScalarWhereWithAggregatesInput[]
    OR?: BookingRequiredPositionScalarWhereWithAggregatesInput[]
    NOT?: BookingRequiredPositionScalarWhereWithAggregatesInput | BookingRequiredPositionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingRequiredPosition"> | number
    bookingId?: IntWithAggregatesFilter<"BookingRequiredPosition"> | number
    positionId?: IntWithAggregatesFilter<"BookingRequiredPosition"> | number
  }

  export type BookingInviteWhereInput = {
    AND?: BookingInviteWhereInput | BookingInviteWhereInput[]
    OR?: BookingInviteWhereInput[]
    NOT?: BookingInviteWhereInput | BookingInviteWhereInput[]
    id?: IntFilter<"BookingInvite"> | number
    bookingId?: IntFilter<"BookingInvite"> | number
    userId?: IntFilter<"BookingInvite"> | number
    status?: EnumInviteStatusFilter<"BookingInvite"> | $Enums.InviteStatus
    respondedAt?: DateTimeNullableFilter<"BookingInvite"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookingInviteOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BookingInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId_userId?: BookingInviteBookingIdUserIdCompoundUniqueInput
    AND?: BookingInviteWhereInput | BookingInviteWhereInput[]
    OR?: BookingInviteWhereInput[]
    NOT?: BookingInviteWhereInput | BookingInviteWhereInput[]
    bookingId?: IntFilter<"BookingInvite"> | number
    userId?: IntFilter<"BookingInvite"> | number
    status?: EnumInviteStatusFilter<"BookingInvite"> | $Enums.InviteStatus
    respondedAt?: DateTimeNullableFilter<"BookingInvite"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bookingId_userId">

  export type BookingInviteOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: BookingInviteCountOrderByAggregateInput
    _avg?: BookingInviteAvgOrderByAggregateInput
    _max?: BookingInviteMaxOrderByAggregateInput
    _min?: BookingInviteMinOrderByAggregateInput
    _sum?: BookingInviteSumOrderByAggregateInput
  }

  export type BookingInviteScalarWhereWithAggregatesInput = {
    AND?: BookingInviteScalarWhereWithAggregatesInput | BookingInviteScalarWhereWithAggregatesInput[]
    OR?: BookingInviteScalarWhereWithAggregatesInput[]
    NOT?: BookingInviteScalarWhereWithAggregatesInput | BookingInviteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingInvite"> | number
    bookingId?: IntWithAggregatesFilter<"BookingInvite"> | number
    userId?: IntWithAggregatesFilter<"BookingInvite"> | number
    status?: EnumInviteStatusWithAggregatesFilter<"BookingInvite"> | $Enums.InviteStatus
    respondedAt?: DateTimeNullableWithAggregatesFilter<"BookingInvite"> | Date | string | null
  }

  export type BookingNoteTakerWhereInput = {
    AND?: BookingNoteTakerWhereInput | BookingNoteTakerWhereInput[]
    OR?: BookingNoteTakerWhereInput[]
    NOT?: BookingNoteTakerWhereInput | BookingNoteTakerWhereInput[]
    id?: IntFilter<"BookingNoteTaker"> | number
    bookingId?: IntFilter<"BookingNoteTaker"> | number
    userId?: IntFilter<"BookingNoteTaker"> | number
    roleIndex?: IntFilter<"BookingNoteTaker"> | number
    status?: EnumNoteQueueStatusFilter<"BookingNoteTaker"> | $Enums.NoteQueueStatus
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BookingNoteTakerOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
    status?: SortOrder
    booking?: BookingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BookingNoteTakerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId_userId?: BookingNoteTakerBookingIdUserIdCompoundUniqueInput
    AND?: BookingNoteTakerWhereInput | BookingNoteTakerWhereInput[]
    OR?: BookingNoteTakerWhereInput[]
    NOT?: BookingNoteTakerWhereInput | BookingNoteTakerWhereInput[]
    bookingId?: IntFilter<"BookingNoteTaker"> | number
    userId?: IntFilter<"BookingNoteTaker"> | number
    roleIndex?: IntFilter<"BookingNoteTaker"> | number
    status?: EnumNoteQueueStatusFilter<"BookingNoteTaker"> | $Enums.NoteQueueStatus
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bookingId_userId">

  export type BookingNoteTakerOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
    status?: SortOrder
    _count?: BookingNoteTakerCountOrderByAggregateInput
    _avg?: BookingNoteTakerAvgOrderByAggregateInput
    _max?: BookingNoteTakerMaxOrderByAggregateInput
    _min?: BookingNoteTakerMinOrderByAggregateInput
    _sum?: BookingNoteTakerSumOrderByAggregateInput
  }

  export type BookingNoteTakerScalarWhereWithAggregatesInput = {
    AND?: BookingNoteTakerScalarWhereWithAggregatesInput | BookingNoteTakerScalarWhereWithAggregatesInput[]
    OR?: BookingNoteTakerScalarWhereWithAggregatesInput[]
    NOT?: BookingNoteTakerScalarWhereWithAggregatesInput | BookingNoteTakerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingNoteTaker"> | number
    bookingId?: IntWithAggregatesFilter<"BookingNoteTaker"> | number
    userId?: IntWithAggregatesFilter<"BookingNoteTaker"> | number
    roleIndex?: IntWithAggregatesFilter<"BookingNoteTaker"> | number
    status?: EnumNoteQueueStatusWithAggregatesFilter<"BookingNoteTaker"> | $Enums.NoteQueueStatus
  }

  export type NoteTakerQueueWhereInput = {
    AND?: NoteTakerQueueWhereInput | NoteTakerQueueWhereInput[]
    OR?: NoteTakerQueueWhereInput[]
    NOT?: NoteTakerQueueWhereInput | NoteTakerQueueWhereInput[]
    id?: IntFilter<"NoteTakerQueue"> | number
    userId?: IntFilter<"NoteTakerQueue"> | number
    orderNo?: IntFilter<"NoteTakerQueue"> | number
    isActive?: BoolFilter<"NoteTakerQueue"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NoteTakerQueueOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
    isActive?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NoteTakerQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: NoteTakerQueueWhereInput | NoteTakerQueueWhereInput[]
    OR?: NoteTakerQueueWhereInput[]
    NOT?: NoteTakerQueueWhereInput | NoteTakerQueueWhereInput[]
    orderNo?: IntFilter<"NoteTakerQueue"> | number
    isActive?: BoolFilter<"NoteTakerQueue"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type NoteTakerQueueOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
    isActive?: SortOrder
    _count?: NoteTakerQueueCountOrderByAggregateInput
    _avg?: NoteTakerQueueAvgOrderByAggregateInput
    _max?: NoteTakerQueueMaxOrderByAggregateInput
    _min?: NoteTakerQueueMinOrderByAggregateInput
    _sum?: NoteTakerQueueSumOrderByAggregateInput
  }

  export type NoteTakerQueueScalarWhereWithAggregatesInput = {
    AND?: NoteTakerQueueScalarWhereWithAggregatesInput | NoteTakerQueueScalarWhereWithAggregatesInput[]
    OR?: NoteTakerQueueScalarWhereWithAggregatesInput[]
    NOT?: NoteTakerQueueScalarWhereWithAggregatesInput | NoteTakerQueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NoteTakerQueue"> | number
    userId?: IntWithAggregatesFilter<"NoteTakerQueue"> | number
    orderNo?: IntWithAggregatesFilter<"NoteTakerQueue"> | number
    isActive?: BoolWithAggregatesFilter<"NoteTakerQueue"> | boolean
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: IntNullableFilter<"Service"> | number | null
    requiresApproval?: BoolFilter<"Service"> | boolean
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    bookingUsages?: BookingServiceListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    bookingUsages?: BookingServiceOrderByRelationAggregateInput
    housekeepingTasks?: HousekeepingTaskOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: IntNullableFilter<"Service"> | number | null
    requiresApproval?: BoolFilter<"Service"> | boolean
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    bookingUsages?: BookingServiceListRelationFilter
    housekeepingTasks?: HousekeepingTaskListRelationFilter
  }, "id" | "name">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: IntNullableWithAggregatesFilter<"Service"> | number | null
    requiresApproval?: BoolWithAggregatesFilter<"Service"> | boolean
  }

  export type BookingServiceWhereInput = {
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    id?: IntFilter<"BookingService"> | number
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntFilter<"BookingService"> | number
    quantity?: IntNullableFilter<"BookingService"> | number | null
    status?: EnumServiceStatusFilter<"BookingService"> | $Enums.ServiceStatus
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type BookingServiceOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    status?: SortOrder
    booking?: BookingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type BookingServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingServiceWhereInput | BookingServiceWhereInput[]
    OR?: BookingServiceWhereInput[]
    NOT?: BookingServiceWhereInput | BookingServiceWhereInput[]
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntFilter<"BookingService"> | number
    quantity?: IntNullableFilter<"BookingService"> | number | null
    status?: EnumServiceStatusFilter<"BookingService"> | $Enums.ServiceStatus
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type BookingServiceOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: BookingServiceCountOrderByAggregateInput
    _avg?: BookingServiceAvgOrderByAggregateInput
    _max?: BookingServiceMaxOrderByAggregateInput
    _min?: BookingServiceMinOrderByAggregateInput
    _sum?: BookingServiceSumOrderByAggregateInput
  }

  export type BookingServiceScalarWhereWithAggregatesInput = {
    AND?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    OR?: BookingServiceScalarWhereWithAggregatesInput[]
    NOT?: BookingServiceScalarWhereWithAggregatesInput | BookingServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookingService"> | number
    bookingId?: IntWithAggregatesFilter<"BookingService"> | number
    serviceId?: IntWithAggregatesFilter<"BookingService"> | number
    quantity?: IntNullableWithAggregatesFilter<"BookingService"> | number | null
    status?: EnumServiceStatusWithAggregatesFilter<"BookingService"> | $Enums.ServiceStatus
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotifTypeFilter<"Notification"> | $Enums.NotifType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    refType?: EnumRefTypeNullableFilter<"Notification"> | $Enums.RefType | null
    refId?: IntNullableFilter<"Notification"> | number | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotifTypeFilter<"Notification"> | $Enums.NotifType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    refType?: EnumRefTypeNullableFilter<"Notification"> | $Enums.RefType | null
    refId?: IntNullableFilter<"Notification"> | number | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    refType?: SortOrderInput | SortOrder
    refId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: EnumNotifTypeWithAggregatesFilter<"Notification"> | $Enums.NotifType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    refType?: EnumRefTypeNullableWithAggregatesFilter<"Notification"> | $Enums.RefType | null
    refId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
  }

  export type NoteTakerLeaveWhereInput = {
    AND?: NoteTakerLeaveWhereInput | NoteTakerLeaveWhereInput[]
    OR?: NoteTakerLeaveWhereInput[]
    NOT?: NoteTakerLeaveWhereInput | NoteTakerLeaveWhereInput[]
    id?: IntFilter<"NoteTakerLeave"> | number
    userId?: IntFilter<"NoteTakerLeave"> | number
    date?: DateTimeFilter<"NoteTakerLeave"> | Date | string
    reason?: StringNullableFilter<"NoteTakerLeave"> | string | null
    createdAt?: DateTimeFilter<"NoteTakerLeave"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NoteTakerLeaveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NoteTakerLeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_date?: NoteTakerLeaveUserIdDateCompoundUniqueInput
    AND?: NoteTakerLeaveWhereInput | NoteTakerLeaveWhereInput[]
    OR?: NoteTakerLeaveWhereInput[]
    NOT?: NoteTakerLeaveWhereInput | NoteTakerLeaveWhereInput[]
    userId?: IntFilter<"NoteTakerLeave"> | number
    date?: DateTimeFilter<"NoteTakerLeave"> | Date | string
    reason?: StringNullableFilter<"NoteTakerLeave"> | string | null
    createdAt?: DateTimeFilter<"NoteTakerLeave"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_date">

  export type NoteTakerLeaveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NoteTakerLeaveCountOrderByAggregateInput
    _avg?: NoteTakerLeaveAvgOrderByAggregateInput
    _max?: NoteTakerLeaveMaxOrderByAggregateInput
    _min?: NoteTakerLeaveMinOrderByAggregateInput
    _sum?: NoteTakerLeaveSumOrderByAggregateInput
  }

  export type NoteTakerLeaveScalarWhereWithAggregatesInput = {
    AND?: NoteTakerLeaveScalarWhereWithAggregatesInput | NoteTakerLeaveScalarWhereWithAggregatesInput[]
    OR?: NoteTakerLeaveScalarWhereWithAggregatesInput[]
    NOT?: NoteTakerLeaveScalarWhereWithAggregatesInput | NoteTakerLeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NoteTakerLeave"> | number
    userId?: IntWithAggregatesFilter<"NoteTakerLeave"> | number
    date?: DateTimeWithAggregatesFilter<"NoteTakerLeave"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"NoteTakerLeave"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NoteTakerLeave"> | Date | string
  }

  export type HousekeepingTaskWhereInput = {
    AND?: HousekeepingTaskWhereInput | HousekeepingTaskWhereInput[]
    OR?: HousekeepingTaskWhereInput[]
    NOT?: HousekeepingTaskWhereInput | HousekeepingTaskWhereInput[]
    id?: IntFilter<"HousekeepingTask"> | number
    bookingId?: IntFilter<"HousekeepingTask"> | number
    serviceId?: IntFilter<"HousekeepingTask"> | number
    status?: EnumHousekeepingTaskStatusFilter<"HousekeepingTask"> | $Enums.HousekeepingTaskStatus
    assignedToId?: IntNullableFilter<"HousekeepingTask"> | number | null
    note?: StringNullableFilter<"HousekeepingTask"> | string | null
    createdAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type HousekeepingTaskOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
  }

  export type HousekeepingTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId_serviceId?: HousekeepingTaskBookingIdServiceIdCompoundUniqueInput
    AND?: HousekeepingTaskWhereInput | HousekeepingTaskWhereInput[]
    OR?: HousekeepingTaskWhereInput[]
    NOT?: HousekeepingTaskWhereInput | HousekeepingTaskWhereInput[]
    bookingId?: IntFilter<"HousekeepingTask"> | number
    serviceId?: IntFilter<"HousekeepingTask"> | number
    status?: EnumHousekeepingTaskStatusFilter<"HousekeepingTask"> | $Enums.HousekeepingTaskStatus
    assignedToId?: IntNullableFilter<"HousekeepingTask"> | number | null
    note?: StringNullableFilter<"HousekeepingTask"> | string | null
    createdAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    assignedTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "bookingId_serviceId">

  export type HousekeepingTaskOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HousekeepingTaskCountOrderByAggregateInput
    _avg?: HousekeepingTaskAvgOrderByAggregateInput
    _max?: HousekeepingTaskMaxOrderByAggregateInput
    _min?: HousekeepingTaskMinOrderByAggregateInput
    _sum?: HousekeepingTaskSumOrderByAggregateInput
  }

  export type HousekeepingTaskScalarWhereWithAggregatesInput = {
    AND?: HousekeepingTaskScalarWhereWithAggregatesInput | HousekeepingTaskScalarWhereWithAggregatesInput[]
    OR?: HousekeepingTaskScalarWhereWithAggregatesInput[]
    NOT?: HousekeepingTaskScalarWhereWithAggregatesInput | HousekeepingTaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HousekeepingTask"> | number
    bookingId?: IntWithAggregatesFilter<"HousekeepingTask"> | number
    serviceId?: IntWithAggregatesFilter<"HousekeepingTask"> | number
    status?: EnumHousekeepingTaskStatusWithAggregatesFilter<"HousekeepingTask"> | $Enums.HousekeepingTaskStatus
    assignedToId?: IntNullableWithAggregatesFilter<"HousekeepingTask"> | number | null
    note?: StringNullableWithAggregatesFilter<"HousekeepingTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HousekeepingTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HousekeepingTask"> | Date | string
  }

  export type IssueWhereInput = {
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    id?: IntFilter<"Issue"> | number
    reporterId?: IntFilter<"Issue"> | number
    roomId?: IntNullableFilter<"Issue"> | number | null
    issueType?: EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
    subject?: StringFilter<"Issue"> | string
    description?: StringFilter<"Issue"> | string
    priority?: EnumIssuePriorityFilter<"Issue"> | $Enums.IssuePriority
    status?: EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"Issue"> | Date | string
    updatedAt?: DateTimeFilter<"Issue"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    meetingRoom?: XOR<MeetingRoomNullableScalarRelationFilter, MeetingRoomWhereInput> | null
    comments?: IssueCommentListRelationFilter
    attachments?: IssueAttachmentListRelationFilter
  }

  export type IssueOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    issueType?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
    meetingRoom?: MeetingRoomOrderByWithRelationInput
    comments?: IssueCommentOrderByRelationAggregateInput
    attachments?: IssueAttachmentOrderByRelationAggregateInput
  }

  export type IssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IssueWhereInput | IssueWhereInput[]
    OR?: IssueWhereInput[]
    NOT?: IssueWhereInput | IssueWhereInput[]
    reporterId?: IntFilter<"Issue"> | number
    roomId?: IntNullableFilter<"Issue"> | number | null
    issueType?: EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
    subject?: StringFilter<"Issue"> | string
    description?: StringFilter<"Issue"> | string
    priority?: EnumIssuePriorityFilter<"Issue"> | $Enums.IssuePriority
    status?: EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"Issue"> | Date | string
    updatedAt?: DateTimeFilter<"Issue"> | Date | string
    reporter?: XOR<UserScalarRelationFilter, UserWhereInput>
    meetingRoom?: XOR<MeetingRoomNullableScalarRelationFilter, MeetingRoomWhereInput> | null
    comments?: IssueCommentListRelationFilter
    attachments?: IssueAttachmentListRelationFilter
  }, "id">

  export type IssueOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    issueType?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IssueCountOrderByAggregateInput
    _avg?: IssueAvgOrderByAggregateInput
    _max?: IssueMaxOrderByAggregateInput
    _min?: IssueMinOrderByAggregateInput
    _sum?: IssueSumOrderByAggregateInput
  }

  export type IssueScalarWhereWithAggregatesInput = {
    AND?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    OR?: IssueScalarWhereWithAggregatesInput[]
    NOT?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Issue"> | number
    reporterId?: IntWithAggregatesFilter<"Issue"> | number
    roomId?: IntNullableWithAggregatesFilter<"Issue"> | number | null
    issueType?: EnumIssueTypeWithAggregatesFilter<"Issue"> | $Enums.IssueType
    subject?: StringWithAggregatesFilter<"Issue"> | string
    description?: StringWithAggregatesFilter<"Issue"> | string
    priority?: EnumIssuePriorityWithAggregatesFilter<"Issue"> | $Enums.IssuePriority
    status?: EnumIssueStatusWithAggregatesFilter<"Issue"> | $Enums.IssueStatus
    createdAt?: DateTimeWithAggregatesFilter<"Issue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Issue"> | Date | string
  }

  export type IssueCommentWhereInput = {
    AND?: IssueCommentWhereInput | IssueCommentWhereInput[]
    OR?: IssueCommentWhereInput[]
    NOT?: IssueCommentWhereInput | IssueCommentWhereInput[]
    id?: IntFilter<"IssueComment"> | number
    issueId?: IntFilter<"IssueComment"> | number
    authorId?: IntFilter<"IssueComment"> | number
    message?: StringFilter<"IssueComment"> | string
    createdAt?: DateTimeFilter<"IssueComment"> | Date | string
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type IssueCommentOrderByWithRelationInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    issue?: IssueOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type IssueCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IssueCommentWhereInput | IssueCommentWhereInput[]
    OR?: IssueCommentWhereInput[]
    NOT?: IssueCommentWhereInput | IssueCommentWhereInput[]
    issueId?: IntFilter<"IssueComment"> | number
    authorId?: IntFilter<"IssueComment"> | number
    message?: StringFilter<"IssueComment"> | string
    createdAt?: DateTimeFilter<"IssueComment"> | Date | string
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type IssueCommentOrderByWithAggregationInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: IssueCommentCountOrderByAggregateInput
    _avg?: IssueCommentAvgOrderByAggregateInput
    _max?: IssueCommentMaxOrderByAggregateInput
    _min?: IssueCommentMinOrderByAggregateInput
    _sum?: IssueCommentSumOrderByAggregateInput
  }

  export type IssueCommentScalarWhereWithAggregatesInput = {
    AND?: IssueCommentScalarWhereWithAggregatesInput | IssueCommentScalarWhereWithAggregatesInput[]
    OR?: IssueCommentScalarWhereWithAggregatesInput[]
    NOT?: IssueCommentScalarWhereWithAggregatesInput | IssueCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IssueComment"> | number
    issueId?: IntWithAggregatesFilter<"IssueComment"> | number
    authorId?: IntWithAggregatesFilter<"IssueComment"> | number
    message?: StringWithAggregatesFilter<"IssueComment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IssueComment"> | Date | string
  }

  export type IssueAttachmentWhereInput = {
    AND?: IssueAttachmentWhereInput | IssueAttachmentWhereInput[]
    OR?: IssueAttachmentWhereInput[]
    NOT?: IssueAttachmentWhereInput | IssueAttachmentWhereInput[]
    id?: IntFilter<"IssueAttachment"> | number
    issueId?: IntFilter<"IssueAttachment"> | number
    filename?: StringFilter<"IssueAttachment"> | string
    url?: StringFilter<"IssueAttachment"> | string
    contentType?: StringNullableFilter<"IssueAttachment"> | string | null
    createdAt?: DateTimeFilter<"IssueAttachment"> | Date | string
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }

  export type IssueAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    issueId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    contentType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    issue?: IssueOrderByWithRelationInput
  }

  export type IssueAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IssueAttachmentWhereInput | IssueAttachmentWhereInput[]
    OR?: IssueAttachmentWhereInput[]
    NOT?: IssueAttachmentWhereInput | IssueAttachmentWhereInput[]
    issueId?: IntFilter<"IssueAttachment"> | number
    filename?: StringFilter<"IssueAttachment"> | string
    url?: StringFilter<"IssueAttachment"> | string
    contentType?: StringNullableFilter<"IssueAttachment"> | string | null
    createdAt?: DateTimeFilter<"IssueAttachment"> | Date | string
    issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>
  }, "id">

  export type IssueAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    issueId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    contentType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: IssueAttachmentCountOrderByAggregateInput
    _avg?: IssueAttachmentAvgOrderByAggregateInput
    _max?: IssueAttachmentMaxOrderByAggregateInput
    _min?: IssueAttachmentMinOrderByAggregateInput
    _sum?: IssueAttachmentSumOrderByAggregateInput
  }

  export type IssueAttachmentScalarWhereWithAggregatesInput = {
    AND?: IssueAttachmentScalarWhereWithAggregatesInput | IssueAttachmentScalarWhereWithAggregatesInput[]
    OR?: IssueAttachmentScalarWhereWithAggregatesInput[]
    NOT?: IssueAttachmentScalarWhereWithAggregatesInput | IssueAttachmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"IssueAttachment"> | number
    issueId?: IntWithAggregatesFilter<"IssueAttachment"> | number
    filename?: StringWithAggregatesFilter<"IssueAttachment"> | string
    url?: StringWithAggregatesFilter<"IssueAttachment"> | string
    contentType?: StringNullableWithAggregatesFilter<"IssueAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IssueAttachment"> | Date | string
  }

  export type DepartmentCreateInput = {
    name: string
    positions?: PositionCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PositionCreateInput = {
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    department?: DepartmentCreateNestedOneWithoutPositionsInput
    users?: UserCreateNestedManyWithoutPositionInput
    neededBy?: BookingRequiredPositionCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    departmentId?: number | null
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
    neededBy?: BookingRequiredPositionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPositionsNestedInput
    users?: UserUpdateManyWithoutPositionNestedInput
    neededBy?: BookingRequiredPositionUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
    neededBy?: BookingRequiredPositionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    departmentId?: number | null
  }

  export type PositionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRoomCreateInput = {
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    bookings?: BookingCreateNestedManyWithoutRoomInput
    issues?: IssueCreateNestedManyWithoutMeetingRoomInput
  }

  export type MeetingRoomUncheckedCreateInput = {
    id?: number
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
    issues?: IssueUncheckedCreateNestedManyWithoutMeetingRoomInput
  }

  export type MeetingRoomUpdateInput = {
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    bookings?: BookingUpdateManyWithoutRoomNestedInput
    issues?: IssueUpdateManyWithoutMeetingRoomNestedInput
  }

  export type MeetingRoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
    issues?: IssueUncheckedUpdateManyWithoutMeetingRoomNestedInput
  }

  export type MeetingRoomCreateManyInput = {
    id?: number
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
  }

  export type MeetingRoomUpdateManyMutationInput = {
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
  }

  export type MeetingRoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
  }

  export type BookingCreateInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRequiredPositionCreateInput = {
    booking: BookingCreateNestedOneWithoutRequiredPositionsInput
    position: PositionCreateNestedOneWithoutNeededByInput
  }

  export type BookingRequiredPositionUncheckedCreateInput = {
    id?: number
    bookingId: number
    positionId: number
  }

  export type BookingRequiredPositionUpdateInput = {
    booking?: BookingUpdateOneRequiredWithoutRequiredPositionsNestedInput
    position?: PositionUpdateOneRequiredWithoutNeededByNestedInput
  }

  export type BookingRequiredPositionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    positionId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingRequiredPositionCreateManyInput = {
    id?: number
    bookingId: number
    positionId: number
  }

  export type BookingRequiredPositionUpdateManyMutationInput = {

  }

  export type BookingRequiredPositionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    positionId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingInviteCreateInput = {
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutInvitesInput
    user: UserCreateNestedOneWithoutBookingInvitesInput
  }

  export type BookingInviteUncheckedCreateInput = {
    id?: number
    bookingId: number
    userId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingInviteUpdateInput = {
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutInvitesNestedInput
    user?: UserUpdateOneRequiredWithoutBookingInvitesNestedInput
  }

  export type BookingInviteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingInviteCreateManyInput = {
    id?: number
    bookingId: number
    userId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingInviteUpdateManyMutationInput = {
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingInviteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingNoteTakerCreateInput = {
    roleIndex: number
    status?: $Enums.NoteQueueStatus
    booking: BookingCreateNestedOneWithoutNoteTakersInput
    user: UserCreateNestedOneWithoutNoteTakerAssignsInput
  }

  export type BookingNoteTakerUncheckedCreateInput = {
    id?: number
    bookingId: number
    userId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerUpdateInput = {
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
    booking?: BookingUpdateOneRequiredWithoutNoteTakersNestedInput
    user?: UserUpdateOneRequiredWithoutNoteTakerAssignsNestedInput
  }

  export type BookingNoteTakerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerCreateManyInput = {
    id?: number
    bookingId: number
    userId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerUpdateManyMutationInput = {
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type NoteTakerQueueCreateInput = {
    orderNo: number
    isActive?: boolean
    user: UserCreateNestedOneWithoutNoteTakerQueueInput
  }

  export type NoteTakerQueueUncheckedCreateInput = {
    id?: number
    userId: number
    orderNo: number
    isActive?: boolean
  }

  export type NoteTakerQueueUpdateInput = {
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNoteTakerQueueNestedInput
  }

  export type NoteTakerQueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteTakerQueueCreateManyInput = {
    id?: number
    userId: number
    orderNo: number
    isActive?: boolean
  }

  export type NoteTakerQueueUpdateManyMutationInput = {
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteTakerQueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceCreateInput = {
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
    department?: DepartmentCreateNestedOneWithoutServicesInput
    bookingUsages?: BookingServiceCreateNestedManyWithoutServiceInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    departmentId?: number | null
    requiresApproval?: boolean
    bookingUsages?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutServicesNestedInput
    bookingUsages?: BookingServiceUpdateManyWithoutServiceNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    bookingUsages?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    departmentId?: number | null
    requiresApproval?: boolean
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingServiceCreateInput = {
    quantity?: number | null
    status?: $Enums.ServiceStatus
    booking: BookingCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutBookingUsagesInput
  }

  export type BookingServiceUncheckedCreateInput = {
    id?: number
    bookingId: number
    serviceId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type BookingServiceUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutBookingUsagesNestedInput
  }

  export type BookingServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type BookingServiceCreateManyInput = {
    id?: number
    bookingId: number
    serviceId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type BookingServiceUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type BookingServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type NotificationCreateInput = {
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateInput = {
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUpdateManyMutationInput = {
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoteTakerLeaveCreateInput = {
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNoteTakerLeavesInput
  }

  export type NoteTakerLeaveUncheckedCreateInput = {
    id?: number
    userId: number
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type NoteTakerLeaveUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNoteTakerLeavesNestedInput
  }

  export type NoteTakerLeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteTakerLeaveCreateManyInput = {
    id?: number
    userId: number
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type NoteTakerLeaveUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteTakerLeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskCreateInput = {
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutHousekeepingTasksInput
    service: ServiceCreateNestedOneWithoutHousekeepingTasksInput
    assignedTo?: UserCreateNestedOneWithoutHousekeepingTasksInput
  }

  export type HousekeepingTaskUncheckedCreateInput = {
    id?: number
    bookingId: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingTaskUpdateInput = {
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutHousekeepingTasksNestedInput
    service?: ServiceUpdateOneRequiredWithoutHousekeepingTasksNestedInput
    assignedTo?: UserUpdateOneWithoutHousekeepingTasksNestedInput
  }

  export type HousekeepingTaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskCreateManyInput = {
    id?: number
    bookingId: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingTaskUpdateManyMutationInput = {
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCreateInput = {
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedIssuesInput
    meetingRoom?: MeetingRoomCreateNestedOneWithoutIssuesInput
    comments?: IssueCommentCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateInput = {
    id?: number
    reporterId: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: IssueCommentUncheckedCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueUpdateInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedIssuesNestedInput
    meetingRoom?: MeetingRoomUpdateOneWithoutIssuesNestedInput
    comments?: IssueCommentUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: IssueCommentUncheckedUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueCreateManyInput = {
    id?: number
    reporterId: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IssueUpdateManyMutationInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentCreateInput = {
    message: string
    createdAt?: Date | string
    issue: IssueCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutIssueCommentsInput
  }

  export type IssueCommentUncheckedCreateInput = {
    id?: number
    issueId: number
    authorId: number
    message: string
    createdAt?: Date | string
  }

  export type IssueCommentUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutIssueCommentsNestedInput
  }

  export type IssueCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentCreateManyInput = {
    id?: number
    issueId: number
    authorId: number
    message: string
    createdAt?: Date | string
  }

  export type IssueCommentUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentCreateInput = {
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
    issue: IssueCreateNestedOneWithoutAttachmentsInput
  }

  export type IssueAttachmentUncheckedCreateInput = {
    id?: number
    issueId: number
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
  }

  export type IssueAttachmentUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type IssueAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentCreateManyInput = {
    id?: number
    issueId: number
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
  }

  export type IssueAttachmentUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type BookingRequiredPositionListRelationFilter = {
    every?: BookingRequiredPositionWhereInput
    some?: BookingRequiredPositionWhereInput
    none?: BookingRequiredPositionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingRequiredPositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    isNoteManager?: SortOrder
    isNoteTaker?: SortOrder
    isHousekeeper?: SortOrder
    isHousekeepingLead?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    isNoteManager?: SortOrder
    isNoteTaker?: SortOrder
    isHousekeeper?: SortOrder
    isHousekeepingLead?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isAdmin?: SortOrder
    isNoteManager?: SortOrder
    isNoteTaker?: SortOrder
    isHousekeeper?: SortOrder
    isHousekeepingLead?: SortOrder
    description?: SortOrder
    departmentId?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PositionScalarRelationFilter = {
    is?: PositionWhereInput
    isNot?: PositionWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BookingInviteListRelationFilter = {
    every?: BookingInviteWhereInput
    some?: BookingInviteWhereInput
    none?: BookingInviteWhereInput
  }

  export type BookingNoteTakerListRelationFilter = {
    every?: BookingNoteTakerWhereInput
    some?: BookingNoteTakerWhereInput
    none?: BookingNoteTakerWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NoteTakerQueueNullableScalarRelationFilter = {
    is?: NoteTakerQueueWhereInput | null
    isNot?: NoteTakerQueueWhereInput | null
  }

  export type NoteTakerLeaveListRelationFilter = {
    every?: NoteTakerLeaveWhereInput
    some?: NoteTakerLeaveWhereInput
    none?: NoteTakerLeaveWhereInput
  }

  export type HousekeepingTaskListRelationFilter = {
    every?: HousekeepingTaskWhereInput
    some?: HousekeepingTaskWhereInput
    none?: HousekeepingTaskWhereInput
  }

  export type IssueListRelationFilter = {
    every?: IssueWhereInput
    some?: IssueWhereInput
    none?: IssueWhereInput
  }

  export type IssueCommentListRelationFilter = {
    every?: IssueCommentWhereInput
    some?: IssueCommentWhereInput
    none?: IssueCommentWhereInput
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingNoteTakerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteTakerLeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HousekeepingTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    positionId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    positionId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type MeetingRoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type MeetingRoomAvgOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type MeetingRoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type MeetingRoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomName?: SortOrder
    capacity?: SortOrder
    status?: SortOrder
  }

  export type MeetingRoomSumOrderByAggregateInput = {
    id?: SortOrder
    capacity?: SortOrder
  }

  export type EnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type MeetingRoomScalarRelationFilter = {
    is?: MeetingRoomWhereInput
    isNot?: MeetingRoomWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookingServiceListRelationFilter = {
    every?: BookingServiceWhereInput
    some?: BookingServiceWhereInput
    none?: BookingServiceWhereInput
  }

  export type BookingServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    purpose?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    purpose?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    purpose?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    bookedById?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingRequiredPositionCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
  }

  export type BookingRequiredPositionAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
  }

  export type BookingRequiredPositionMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
  }

  export type BookingRequiredPositionMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
  }

  export type BookingRequiredPositionSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    positionId?: SortOrder
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BookingInviteBookingIdUserIdCompoundUniqueInput = {
    bookingId: number
    userId: number
  }

  export type BookingInviteCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    respondedAt?: SortOrder
  }

  export type BookingInviteAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
  }

  export type BookingInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    respondedAt?: SortOrder
  }

  export type BookingInviteMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    respondedAt?: SortOrder
  }

  export type BookingInviteSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumNoteQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteQueueStatus | EnumNoteQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteQueueStatusFilter<$PrismaModel> | $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerBookingIdUserIdCompoundUniqueInput = {
    bookingId: number
    userId: number
  }

  export type BookingNoteTakerCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
    status?: SortOrder
  }

  export type BookingNoteTakerAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
  }

  export type BookingNoteTakerMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
    status?: SortOrder
  }

  export type BookingNoteTakerMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
    status?: SortOrder
  }

  export type BookingNoteTakerSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    roleIndex?: SortOrder
  }

  export type EnumNoteQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteQueueStatus | EnumNoteQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.NoteQueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumNoteQueueStatusFilter<$PrismaModel>
  }

  export type NoteTakerQueueCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
    isActive?: SortOrder
  }

  export type NoteTakerQueueAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
  }

  export type NoteTakerQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
    isActive?: SortOrder
  }

  export type NoteTakerQueueMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
    isActive?: SortOrder
  }

  export type NoteTakerQueueSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    orderNo?: SortOrder
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    requiresApproval?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    requiresApproval?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    requiresApproval?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type BookingServiceCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
  }

  export type BookingServiceAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type BookingServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
  }

  export type BookingServiceMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
  }

  export type BookingServiceSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    quantity?: SortOrder
  }

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type EnumNotifTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotifType | EnumNotifTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotifTypeFilter<$PrismaModel> | $Enums.NotifType
  }

  export type EnumRefTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefType | EnumRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefTypeNullableFilter<$PrismaModel> | $Enums.RefType | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    refType?: SortOrder
    refId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refId?: SortOrder
  }

  export type EnumNotifTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotifType | EnumNotifTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotifTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotifType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotifTypeFilter<$PrismaModel>
    _max?: NestedEnumNotifTypeFilter<$PrismaModel>
  }

  export type EnumRefTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefType | EnumRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRefTypeNullableFilter<$PrismaModel>
  }

  export type NoteTakerLeaveUserIdDateCompoundUniqueInput = {
    userId: number
    date: Date | string
  }

  export type NoteTakerLeaveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteTakerLeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NoteTakerLeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteTakerLeaveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type NoteTakerLeaveSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumHousekeepingTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HousekeepingTaskStatus | EnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel> | $Enums.HousekeepingTaskStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type HousekeepingTaskBookingIdServiceIdCompoundUniqueInput = {
    bookingId: number
    serviceId: number
  }

  export type HousekeepingTaskCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingTaskAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    assignedToId?: SortOrder
  }

  export type HousekeepingTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingTaskMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    assignedToId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HousekeepingTaskSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    serviceId?: SortOrder
    assignedToId?: SortOrder
  }

  export type EnumHousekeepingTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HousekeepingTaskStatus | EnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHousekeepingTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.HousekeepingTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel>
  }

  export type EnumIssueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
  }

  export type EnumIssuePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuePriority | EnumIssuePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuePriorityFilter<$PrismaModel> | $Enums.IssuePriority
  }

  export type EnumIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
  }

  export type MeetingRoomNullableScalarRelationFilter = {
    is?: MeetingRoomWhereInput | null
    isNot?: MeetingRoomWhereInput | null
  }

  export type IssueAttachmentListRelationFilter = {
    every?: IssueAttachmentWhereInput
    some?: IssueAttachmentWhereInput
    none?: IssueAttachmentWhereInput
  }

  export type IssueAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IssueCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrder
    issueType?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueAvgOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrder
  }

  export type IssueMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrder
    issueType?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrder
    issueType?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IssueSumOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    roomId?: SortOrder
  }

  export type EnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueTypeFilter<$PrismaModel>
    _max?: NestedEnumIssueTypeFilter<$PrismaModel>
  }

  export type EnumIssuePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuePriority | EnumIssuePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuePriorityWithAggregatesFilter<$PrismaModel> | $Enums.IssuePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssuePriorityFilter<$PrismaModel>
    _max?: NestedEnumIssuePriorityFilter<$PrismaModel>
  }

  export type EnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumIssueStatusFilter<$PrismaModel>
  }

  export type IssueScalarRelationFilter = {
    is?: IssueWhereInput
    isNot?: IssueWhereInput
  }

  export type IssueCommentCountOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
  }

  export type IssueCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueCommentMinOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueCommentSumOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    authorId?: SortOrder
  }

  export type IssueAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
  }

  export type IssueAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
  }

  export type IssueAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
    issueId?: SortOrder
  }

  export type PositionCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PositionUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PositionUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutDepartmentInput | PositionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutDepartmentInput | PositionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutDepartmentInput | PositionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PositionUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput> | PositionCreateWithoutDepartmentInput[] | PositionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutDepartmentInput | PositionCreateOrConnectWithoutDepartmentInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutDepartmentInput | PositionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PositionCreateManyDepartmentInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutDepartmentInput | PositionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutDepartmentInput | PositionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutPositionsInput = {
    create?: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPositionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequiredPositionCreateNestedManyWithoutPositionInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput> | BookingRequiredPositionCreateWithoutPositionInput[] | BookingRequiredPositionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutPositionInput | BookingRequiredPositionCreateOrConnectWithoutPositionInput[]
    createMany?: BookingRequiredPositionCreateManyPositionInputEnvelope
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookingRequiredPositionUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput> | BookingRequiredPositionCreateWithoutPositionInput[] | BookingRequiredPositionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutPositionInput | BookingRequiredPositionCreateOrConnectWithoutPositionInput[]
    createMany?: BookingRequiredPositionCreateManyPositionInputEnvelope
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DepartmentUpdateOneWithoutPositionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPositionsInput
    upsert?: DepartmentUpsertWithoutPositionsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPositionsInput, DepartmentUpdateWithoutPositionsInput>, DepartmentUncheckedUpdateWithoutPositionsInput>
  }

  export type UserUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequiredPositionUpdateManyWithoutPositionNestedInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput> | BookingRequiredPositionCreateWithoutPositionInput[] | BookingRequiredPositionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutPositionInput | BookingRequiredPositionCreateOrConnectWithoutPositionInput[]
    upsert?: BookingRequiredPositionUpsertWithWhereUniqueWithoutPositionInput | BookingRequiredPositionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: BookingRequiredPositionCreateManyPositionInputEnvelope
    set?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    disconnect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    delete?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    update?: BookingRequiredPositionUpdateWithWhereUniqueWithoutPositionInput | BookingRequiredPositionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: BookingRequiredPositionUpdateManyWithWhereWithoutPositionInput | BookingRequiredPositionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput> | UserCreateWithoutPositionInput[] | UserUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: UserCreateOrConnectWithoutPositionInput | UserCreateOrConnectWithoutPositionInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutPositionInput | UserUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: UserCreateManyPositionInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutPositionInput | UserUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: UserUpdateManyWithWhereWithoutPositionInput | UserUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookingRequiredPositionUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput> | BookingRequiredPositionCreateWithoutPositionInput[] | BookingRequiredPositionUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutPositionInput | BookingRequiredPositionCreateOrConnectWithoutPositionInput[]
    upsert?: BookingRequiredPositionUpsertWithWhereUniqueWithoutPositionInput | BookingRequiredPositionUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: BookingRequiredPositionCreateManyPositionInputEnvelope
    set?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    disconnect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    delete?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    update?: BookingRequiredPositionUpdateWithWhereUniqueWithoutPositionInput | BookingRequiredPositionUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: BookingRequiredPositionUpdateManyWithWhereWithoutPositionInput | BookingRequiredPositionUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
  }

  export type PositionCreateNestedOneWithoutUsersInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    connect?: PositionWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutBookedByInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingInviteCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput> | BookingInviteCreateWithoutUserInput[] | BookingInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutUserInput | BookingInviteCreateOrConnectWithoutUserInput[]
    createMany?: BookingInviteCreateManyUserInputEnvelope
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
  }

  export type BookingNoteTakerCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput> | BookingNoteTakerCreateWithoutUserInput[] | BookingNoteTakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutUserInput | BookingNoteTakerCreateOrConnectWithoutUserInput[]
    createMany?: BookingNoteTakerCreateManyUserInputEnvelope
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NoteTakerQueueCreateNestedOneWithoutUserInput = {
    create?: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
    connectOrCreate?: NoteTakerQueueCreateOrConnectWithoutUserInput
    connect?: NoteTakerQueueWhereUniqueInput
  }

  export type NoteTakerLeaveCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput> | NoteTakerLeaveCreateWithoutUserInput[] | NoteTakerLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteTakerLeaveCreateOrConnectWithoutUserInput | NoteTakerLeaveCreateOrConnectWithoutUserInput[]
    createMany?: NoteTakerLeaveCreateManyUserInputEnvelope
    connect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
  }

  export type HousekeepingTaskCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput> | HousekeepingTaskCreateWithoutAssignedToInput[] | HousekeepingTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutAssignedToInput | HousekeepingTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: HousekeepingTaskCreateManyAssignedToInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutReporterInput = {
    create?: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput> | IssueCreateWithoutReporterInput[] | IssueUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutReporterInput | IssueCreateOrConnectWithoutReporterInput[]
    createMany?: IssueCreateManyReporterInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type IssueCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput> | IssueCommentCreateWithoutAuthorInput[] | IssueCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutAuthorInput | IssueCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: IssueCommentCreateManyAuthorInputEnvelope
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBookedByInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingInviteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput> | BookingInviteCreateWithoutUserInput[] | BookingInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutUserInput | BookingInviteCreateOrConnectWithoutUserInput[]
    createMany?: BookingInviteCreateManyUserInputEnvelope
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
  }

  export type BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput> | BookingNoteTakerCreateWithoutUserInput[] | BookingNoteTakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutUserInput | BookingNoteTakerCreateOrConnectWithoutUserInput[]
    createMany?: BookingNoteTakerCreateManyUserInputEnvelope
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
    connectOrCreate?: NoteTakerQueueCreateOrConnectWithoutUserInput
    connect?: NoteTakerQueueWhereUniqueInput
  }

  export type NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput> | NoteTakerLeaveCreateWithoutUserInput[] | NoteTakerLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteTakerLeaveCreateOrConnectWithoutUserInput | NoteTakerLeaveCreateOrConnectWithoutUserInput[]
    createMany?: NoteTakerLeaveCreateManyUserInputEnvelope
    connect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
  }

  export type HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput> | HousekeepingTaskCreateWithoutAssignedToInput[] | HousekeepingTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutAssignedToInput | HousekeepingTaskCreateOrConnectWithoutAssignedToInput[]
    createMany?: HousekeepingTaskCreateManyAssignedToInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput> | IssueCreateWithoutReporterInput[] | IssueUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutReporterInput | IssueCreateOrConnectWithoutReporterInput[]
    createMany?: IssueCreateManyReporterInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type IssueCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput> | IssueCommentCreateWithoutAuthorInput[] | IssueCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutAuthorInput | IssueCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: IssueCommentCreateManyAuthorInputEnvelope
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PositionUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    connectOrCreate?: PositionCreateOrConnectWithoutUsersInput
    upsert?: PositionUpsertWithoutUsersInput
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutUsersInput, PositionUpdateWithoutUsersInput>, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type BookingUpdateManyWithoutBookedByNestedInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBookedByInput | BookingUpsertWithWhereUniqueWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBookedByInput | BookingUpdateWithWhereUniqueWithoutBookedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBookedByInput | BookingUpdateManyWithWhereWithoutBookedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingInviteUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput> | BookingInviteCreateWithoutUserInput[] | BookingInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutUserInput | BookingInviteCreateOrConnectWithoutUserInput[]
    upsert?: BookingInviteUpsertWithWhereUniqueWithoutUserInput | BookingInviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingInviteCreateManyUserInputEnvelope
    set?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    disconnect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    delete?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    update?: BookingInviteUpdateWithWhereUniqueWithoutUserInput | BookingInviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingInviteUpdateManyWithWhereWithoutUserInput | BookingInviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
  }

  export type BookingNoteTakerUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput> | BookingNoteTakerCreateWithoutUserInput[] | BookingNoteTakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutUserInput | BookingNoteTakerCreateOrConnectWithoutUserInput[]
    upsert?: BookingNoteTakerUpsertWithWhereUniqueWithoutUserInput | BookingNoteTakerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingNoteTakerCreateManyUserInputEnvelope
    set?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    disconnect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    delete?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    update?: BookingNoteTakerUpdateWithWhereUniqueWithoutUserInput | BookingNoteTakerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingNoteTakerUpdateManyWithWhereWithoutUserInput | BookingNoteTakerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NoteTakerQueueUpdateOneWithoutUserNestedInput = {
    create?: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
    connectOrCreate?: NoteTakerQueueCreateOrConnectWithoutUserInput
    upsert?: NoteTakerQueueUpsertWithoutUserInput
    disconnect?: NoteTakerQueueWhereInput | boolean
    delete?: NoteTakerQueueWhereInput | boolean
    connect?: NoteTakerQueueWhereUniqueInput
    update?: XOR<XOR<NoteTakerQueueUpdateToOneWithWhereWithoutUserInput, NoteTakerQueueUpdateWithoutUserInput>, NoteTakerQueueUncheckedUpdateWithoutUserInput>
  }

  export type NoteTakerLeaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput> | NoteTakerLeaveCreateWithoutUserInput[] | NoteTakerLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteTakerLeaveCreateOrConnectWithoutUserInput | NoteTakerLeaveCreateOrConnectWithoutUserInput[]
    upsert?: NoteTakerLeaveUpsertWithWhereUniqueWithoutUserInput | NoteTakerLeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteTakerLeaveCreateManyUserInputEnvelope
    set?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    disconnect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    delete?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    connect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    update?: NoteTakerLeaveUpdateWithWhereUniqueWithoutUserInput | NoteTakerLeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteTakerLeaveUpdateManyWithWhereWithoutUserInput | NoteTakerLeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteTakerLeaveScalarWhereInput | NoteTakerLeaveScalarWhereInput[]
  }

  export type HousekeepingTaskUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput> | HousekeepingTaskCreateWithoutAssignedToInput[] | HousekeepingTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutAssignedToInput | HousekeepingTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutAssignedToInput | HousekeepingTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: HousekeepingTaskCreateManyAssignedToInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutAssignedToInput | HousekeepingTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutAssignedToInput | HousekeepingTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput> | IssueCreateWithoutReporterInput[] | IssueUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutReporterInput | IssueCreateOrConnectWithoutReporterInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutReporterInput | IssueUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IssueCreateManyReporterInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutReporterInput | IssueUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutReporterInput | IssueUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type IssueCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput> | IssueCommentCreateWithoutAuthorInput[] | IssueCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutAuthorInput | IssueCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: IssueCommentUpsertWithWhereUniqueWithoutAuthorInput | IssueCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: IssueCommentCreateManyAuthorInputEnvelope
    set?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    disconnect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    delete?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    update?: IssueCommentUpdateWithWhereUniqueWithoutAuthorInput | IssueCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: IssueCommentUpdateManyWithWhereWithoutAuthorInput | IssueCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBookedByNestedInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBookedByInput | BookingUpsertWithWhereUniqueWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBookedByInput | BookingUpdateWithWhereUniqueWithoutBookedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBookedByInput | BookingUpdateManyWithWhereWithoutBookedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingInviteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput> | BookingInviteCreateWithoutUserInput[] | BookingInviteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutUserInput | BookingInviteCreateOrConnectWithoutUserInput[]
    upsert?: BookingInviteUpsertWithWhereUniqueWithoutUserInput | BookingInviteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingInviteCreateManyUserInputEnvelope
    set?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    disconnect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    delete?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    update?: BookingInviteUpdateWithWhereUniqueWithoutUserInput | BookingInviteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingInviteUpdateManyWithWhereWithoutUserInput | BookingInviteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
  }

  export type BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput> | BookingNoteTakerCreateWithoutUserInput[] | BookingNoteTakerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutUserInput | BookingNoteTakerCreateOrConnectWithoutUserInput[]
    upsert?: BookingNoteTakerUpsertWithWhereUniqueWithoutUserInput | BookingNoteTakerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingNoteTakerCreateManyUserInputEnvelope
    set?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    disconnect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    delete?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    update?: BookingNoteTakerUpdateWithWhereUniqueWithoutUserInput | BookingNoteTakerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingNoteTakerUpdateManyWithWhereWithoutUserInput | BookingNoteTakerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
    connectOrCreate?: NoteTakerQueueCreateOrConnectWithoutUserInput
    upsert?: NoteTakerQueueUpsertWithoutUserInput
    disconnect?: NoteTakerQueueWhereInput | boolean
    delete?: NoteTakerQueueWhereInput | boolean
    connect?: NoteTakerQueueWhereUniqueInput
    update?: XOR<XOR<NoteTakerQueueUpdateToOneWithWhereWithoutUserInput, NoteTakerQueueUpdateWithoutUserInput>, NoteTakerQueueUncheckedUpdateWithoutUserInput>
  }

  export type NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput> | NoteTakerLeaveCreateWithoutUserInput[] | NoteTakerLeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NoteTakerLeaveCreateOrConnectWithoutUserInput | NoteTakerLeaveCreateOrConnectWithoutUserInput[]
    upsert?: NoteTakerLeaveUpsertWithWhereUniqueWithoutUserInput | NoteTakerLeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NoteTakerLeaveCreateManyUserInputEnvelope
    set?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    disconnect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    delete?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    connect?: NoteTakerLeaveWhereUniqueInput | NoteTakerLeaveWhereUniqueInput[]
    update?: NoteTakerLeaveUpdateWithWhereUniqueWithoutUserInput | NoteTakerLeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NoteTakerLeaveUpdateManyWithWhereWithoutUserInput | NoteTakerLeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NoteTakerLeaveScalarWhereInput | NoteTakerLeaveScalarWhereInput[]
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput> | HousekeepingTaskCreateWithoutAssignedToInput[] | HousekeepingTaskUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutAssignedToInput | HousekeepingTaskCreateOrConnectWithoutAssignedToInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutAssignedToInput | HousekeepingTaskUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: HousekeepingTaskCreateManyAssignedToInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutAssignedToInput | HousekeepingTaskUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutAssignedToInput | HousekeepingTaskUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput> | IssueCreateWithoutReporterInput[] | IssueUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutReporterInput | IssueCreateOrConnectWithoutReporterInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutReporterInput | IssueUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: IssueCreateManyReporterInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutReporterInput | IssueUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutReporterInput | IssueUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput> | IssueCommentCreateWithoutAuthorInput[] | IssueCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutAuthorInput | IssueCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: IssueCommentUpsertWithWhereUniqueWithoutAuthorInput | IssueCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: IssueCommentCreateManyAuthorInputEnvelope
    set?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    disconnect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    delete?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    update?: IssueCommentUpdateWithWhereUniqueWithoutAuthorInput | IssueCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: IssueCommentUpdateManyWithWhereWithoutAuthorInput | IssueCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type IssueCreateNestedManyWithoutMeetingRoomInput = {
    create?: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput> | IssueCreateWithoutMeetingRoomInput[] | IssueUncheckedCreateWithoutMeetingRoomInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutMeetingRoomInput | IssueCreateOrConnectWithoutMeetingRoomInput[]
    createMany?: IssueCreateManyMeetingRoomInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type IssueUncheckedCreateNestedManyWithoutMeetingRoomInput = {
    create?: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput> | IssueCreateWithoutMeetingRoomInput[] | IssueUncheckedCreateWithoutMeetingRoomInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutMeetingRoomInput | IssueCreateOrConnectWithoutMeetingRoomInput[]
    createMany?: IssueCreateManyMeetingRoomInputEnvelope
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
  }

  export type EnumRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoomStatus
  }

  export type BookingUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomInput | BookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomInput | BookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomInput | BookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type IssueUpdateManyWithoutMeetingRoomNestedInput = {
    create?: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput> | IssueCreateWithoutMeetingRoomInput[] | IssueUncheckedCreateWithoutMeetingRoomInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutMeetingRoomInput | IssueCreateOrConnectWithoutMeetingRoomInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutMeetingRoomInput | IssueUpsertWithWhereUniqueWithoutMeetingRoomInput[]
    createMany?: IssueCreateManyMeetingRoomInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutMeetingRoomInput | IssueUpdateWithWhereUniqueWithoutMeetingRoomInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutMeetingRoomInput | IssueUpdateManyWithWhereWithoutMeetingRoomInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput> | BookingCreateWithoutRoomInput[] | BookingUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomInput | BookingCreateOrConnectWithoutRoomInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomInput | BookingUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: BookingCreateManyRoomInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomInput | BookingUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomInput | BookingUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type IssueUncheckedUpdateManyWithoutMeetingRoomNestedInput = {
    create?: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput> | IssueCreateWithoutMeetingRoomInput[] | IssueUncheckedCreateWithoutMeetingRoomInput[]
    connectOrCreate?: IssueCreateOrConnectWithoutMeetingRoomInput | IssueCreateOrConnectWithoutMeetingRoomInput[]
    upsert?: IssueUpsertWithWhereUniqueWithoutMeetingRoomInput | IssueUpsertWithWhereUniqueWithoutMeetingRoomInput[]
    createMany?: IssueCreateManyMeetingRoomInputEnvelope
    set?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[]
    update?: IssueUpdateWithWhereUniqueWithoutMeetingRoomInput | IssueUpdateWithWhereUniqueWithoutMeetingRoomInput[]
    updateMany?: IssueUpdateManyWithWhereWithoutMeetingRoomInput | IssueUpdateManyWithWhereWithoutMeetingRoomInput[]
    deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[]
  }

  export type MeetingRoomCreateNestedOneWithoutBookingsInput = {
    create?: XOR<MeetingRoomCreateWithoutBookingsInput, MeetingRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: MeetingRoomCreateOrConnectWithoutBookingsInput
    connect?: MeetingRoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsBookedInput = {
    create?: XOR<UserCreateWithoutBookingsBookedInput, UserUncheckedCreateWithoutBookingsBookedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsBookedInput
    connect?: UserWhereUniqueInput
  }

  export type BookingRequiredPositionCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput> | BookingRequiredPositionCreateWithoutBookingInput[] | BookingRequiredPositionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutBookingInput | BookingRequiredPositionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingRequiredPositionCreateManyBookingInputEnvelope
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
  }

  export type BookingInviteCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput> | BookingInviteCreateWithoutBookingInput[] | BookingInviteUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutBookingInput | BookingInviteCreateOrConnectWithoutBookingInput[]
    createMany?: BookingInviteCreateManyBookingInputEnvelope
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
  }

  export type BookingNoteTakerCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput> | BookingNoteTakerCreateWithoutBookingInput[] | BookingNoteTakerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutBookingInput | BookingNoteTakerCreateOrConnectWithoutBookingInput[]
    createMany?: BookingNoteTakerCreateManyBookingInputEnvelope
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
  }

  export type BookingServiceCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type HousekeepingTaskCreateNestedManyWithoutBookingInput = {
    create?: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput> | HousekeepingTaskCreateWithoutBookingInput[] | HousekeepingTaskUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutBookingInput | HousekeepingTaskCreateOrConnectWithoutBookingInput[]
    createMany?: HousekeepingTaskCreateManyBookingInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput> | BookingRequiredPositionCreateWithoutBookingInput[] | BookingRequiredPositionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutBookingInput | BookingRequiredPositionCreateOrConnectWithoutBookingInput[]
    createMany?: BookingRequiredPositionCreateManyBookingInputEnvelope
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
  }

  export type BookingInviteUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput> | BookingInviteCreateWithoutBookingInput[] | BookingInviteUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutBookingInput | BookingInviteCreateOrConnectWithoutBookingInput[]
    createMany?: BookingInviteCreateManyBookingInputEnvelope
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
  }

  export type BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput> | BookingNoteTakerCreateWithoutBookingInput[] | BookingNoteTakerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutBookingInput | BookingNoteTakerCreateOrConnectWithoutBookingInput[]
    createMany?: BookingNoteTakerCreateManyBookingInputEnvelope
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput> | HousekeepingTaskCreateWithoutBookingInput[] | HousekeepingTaskUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutBookingInput | HousekeepingTaskCreateOrConnectWithoutBookingInput[]
    createMany?: HousekeepingTaskCreateManyBookingInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<MeetingRoomCreateWithoutBookingsInput, MeetingRoomUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: MeetingRoomCreateOrConnectWithoutBookingsInput
    upsert?: MeetingRoomUpsertWithoutBookingsInput
    connect?: MeetingRoomWhereUniqueInput
    update?: XOR<XOR<MeetingRoomUpdateToOneWithWhereWithoutBookingsInput, MeetingRoomUpdateWithoutBookingsInput>, MeetingRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsBookedNestedInput = {
    create?: XOR<UserCreateWithoutBookingsBookedInput, UserUncheckedCreateWithoutBookingsBookedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsBookedInput
    upsert?: UserUpsertWithoutBookingsBookedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsBookedInput, UserUpdateWithoutBookingsBookedInput>, UserUncheckedUpdateWithoutBookingsBookedInput>
  }

  export type BookingRequiredPositionUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput> | BookingRequiredPositionCreateWithoutBookingInput[] | BookingRequiredPositionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutBookingInput | BookingRequiredPositionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingRequiredPositionUpsertWithWhereUniqueWithoutBookingInput | BookingRequiredPositionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingRequiredPositionCreateManyBookingInputEnvelope
    set?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    disconnect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    delete?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    update?: BookingRequiredPositionUpdateWithWhereUniqueWithoutBookingInput | BookingRequiredPositionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingRequiredPositionUpdateManyWithWhereWithoutBookingInput | BookingRequiredPositionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
  }

  export type BookingInviteUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput> | BookingInviteCreateWithoutBookingInput[] | BookingInviteUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutBookingInput | BookingInviteCreateOrConnectWithoutBookingInput[]
    upsert?: BookingInviteUpsertWithWhereUniqueWithoutBookingInput | BookingInviteUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingInviteCreateManyBookingInputEnvelope
    set?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    disconnect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    delete?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    update?: BookingInviteUpdateWithWhereUniqueWithoutBookingInput | BookingInviteUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingInviteUpdateManyWithWhereWithoutBookingInput | BookingInviteUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
  }

  export type BookingNoteTakerUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput> | BookingNoteTakerCreateWithoutBookingInput[] | BookingNoteTakerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutBookingInput | BookingNoteTakerCreateOrConnectWithoutBookingInput[]
    upsert?: BookingNoteTakerUpsertWithWhereUniqueWithoutBookingInput | BookingNoteTakerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingNoteTakerCreateManyBookingInputEnvelope
    set?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    disconnect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    delete?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    update?: BookingNoteTakerUpdateWithWhereUniqueWithoutBookingInput | BookingNoteTakerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingNoteTakerUpdateManyWithWhereWithoutBookingInput | BookingNoteTakerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
  }

  export type BookingServiceUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type HousekeepingTaskUpdateManyWithoutBookingNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput> | HousekeepingTaskCreateWithoutBookingInput[] | HousekeepingTaskUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutBookingInput | HousekeepingTaskCreateOrConnectWithoutBookingInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutBookingInput | HousekeepingTaskUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: HousekeepingTaskCreateManyBookingInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutBookingInput | HousekeepingTaskUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutBookingInput | HousekeepingTaskUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput> | BookingRequiredPositionCreateWithoutBookingInput[] | BookingRequiredPositionUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingRequiredPositionCreateOrConnectWithoutBookingInput | BookingRequiredPositionCreateOrConnectWithoutBookingInput[]
    upsert?: BookingRequiredPositionUpsertWithWhereUniqueWithoutBookingInput | BookingRequiredPositionUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingRequiredPositionCreateManyBookingInputEnvelope
    set?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    disconnect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    delete?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    connect?: BookingRequiredPositionWhereUniqueInput | BookingRequiredPositionWhereUniqueInput[]
    update?: BookingRequiredPositionUpdateWithWhereUniqueWithoutBookingInput | BookingRequiredPositionUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingRequiredPositionUpdateManyWithWhereWithoutBookingInput | BookingRequiredPositionUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
  }

  export type BookingInviteUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput> | BookingInviteCreateWithoutBookingInput[] | BookingInviteUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingInviteCreateOrConnectWithoutBookingInput | BookingInviteCreateOrConnectWithoutBookingInput[]
    upsert?: BookingInviteUpsertWithWhereUniqueWithoutBookingInput | BookingInviteUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingInviteCreateManyBookingInputEnvelope
    set?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    disconnect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    delete?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    connect?: BookingInviteWhereUniqueInput | BookingInviteWhereUniqueInput[]
    update?: BookingInviteUpdateWithWhereUniqueWithoutBookingInput | BookingInviteUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingInviteUpdateManyWithWhereWithoutBookingInput | BookingInviteUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
  }

  export type BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput> | BookingNoteTakerCreateWithoutBookingInput[] | BookingNoteTakerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingNoteTakerCreateOrConnectWithoutBookingInput | BookingNoteTakerCreateOrConnectWithoutBookingInput[]
    upsert?: BookingNoteTakerUpsertWithWhereUniqueWithoutBookingInput | BookingNoteTakerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingNoteTakerCreateManyBookingInputEnvelope
    set?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    disconnect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    delete?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    connect?: BookingNoteTakerWhereUniqueInput | BookingNoteTakerWhereUniqueInput[]
    update?: BookingNoteTakerUpdateWithWhereUniqueWithoutBookingInput | BookingNoteTakerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingNoteTakerUpdateManyWithWhereWithoutBookingInput | BookingNoteTakerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput> | BookingServiceCreateWithoutBookingInput[] | BookingServiceUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutBookingInput | BookingServiceCreateOrConnectWithoutBookingInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutBookingInput | BookingServiceUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingServiceCreateManyBookingInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutBookingInput | BookingServiceUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutBookingInput | BookingServiceUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput> | HousekeepingTaskCreateWithoutBookingInput[] | HousekeepingTaskUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutBookingInput | HousekeepingTaskCreateOrConnectWithoutBookingInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutBookingInput | HousekeepingTaskUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: HousekeepingTaskCreateManyBookingInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutBookingInput | HousekeepingTaskUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutBookingInput | HousekeepingTaskUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutRequiredPositionsInput = {
    create?: XOR<BookingCreateWithoutRequiredPositionsInput, BookingUncheckedCreateWithoutRequiredPositionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutRequiredPositionsInput
    connect?: BookingWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutNeededByInput = {
    create?: XOR<PositionCreateWithoutNeededByInput, PositionUncheckedCreateWithoutNeededByInput>
    connectOrCreate?: PositionCreateOrConnectWithoutNeededByInput
    connect?: PositionWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutRequiredPositionsNestedInput = {
    create?: XOR<BookingCreateWithoutRequiredPositionsInput, BookingUncheckedCreateWithoutRequiredPositionsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutRequiredPositionsInput
    upsert?: BookingUpsertWithoutRequiredPositionsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutRequiredPositionsInput, BookingUpdateWithoutRequiredPositionsInput>, BookingUncheckedUpdateWithoutRequiredPositionsInput>
  }

  export type PositionUpdateOneRequiredWithoutNeededByNestedInput = {
    create?: XOR<PositionCreateWithoutNeededByInput, PositionUncheckedCreateWithoutNeededByInput>
    connectOrCreate?: PositionCreateOrConnectWithoutNeededByInput
    upsert?: PositionUpsertWithoutNeededByInput
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutNeededByInput, PositionUpdateWithoutNeededByInput>, PositionUncheckedUpdateWithoutNeededByInput>
  }

  export type BookingCreateNestedOneWithoutInvitesInput = {
    create?: XOR<BookingCreateWithoutInvitesInput, BookingUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvitesInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingInvitesInput = {
    create?: XOR<UserCreateWithoutBookingInvitesInput, UserUncheckedCreateWithoutBookingInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BookingUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<BookingCreateWithoutInvitesInput, BookingUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInvitesInput
    upsert?: BookingUpsertWithoutInvitesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInvitesInput, BookingUpdateWithoutInvitesInput>, BookingUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutBookingInvitesNestedInput = {
    create?: XOR<UserCreateWithoutBookingInvitesInput, UserUncheckedCreateWithoutBookingInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingInvitesInput
    upsert?: UserUpsertWithoutBookingInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingInvitesInput, UserUpdateWithoutBookingInvitesInput>, UserUncheckedUpdateWithoutBookingInvitesInput>
  }

  export type BookingCreateNestedOneWithoutNoteTakersInput = {
    create?: XOR<BookingCreateWithoutNoteTakersInput, BookingUncheckedCreateWithoutNoteTakersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNoteTakersInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNoteTakerAssignsInput = {
    create?: XOR<UserCreateWithoutNoteTakerAssignsInput, UserUncheckedCreateWithoutNoteTakerAssignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerAssignsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNoteQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.NoteQueueStatus
  }

  export type BookingUpdateOneRequiredWithoutNoteTakersNestedInput = {
    create?: XOR<BookingCreateWithoutNoteTakersInput, BookingUncheckedCreateWithoutNoteTakersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutNoteTakersInput
    upsert?: BookingUpsertWithoutNoteTakersInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutNoteTakersInput, BookingUpdateWithoutNoteTakersInput>, BookingUncheckedUpdateWithoutNoteTakersInput>
  }

  export type UserUpdateOneRequiredWithoutNoteTakerAssignsNestedInput = {
    create?: XOR<UserCreateWithoutNoteTakerAssignsInput, UserUncheckedCreateWithoutNoteTakerAssignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerAssignsInput
    upsert?: UserUpsertWithoutNoteTakerAssignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteTakerAssignsInput, UserUpdateWithoutNoteTakerAssignsInput>, UserUncheckedUpdateWithoutNoteTakerAssignsInput>
  }

  export type UserCreateNestedOneWithoutNoteTakerQueueInput = {
    create?: XOR<UserCreateWithoutNoteTakerQueueInput, UserUncheckedCreateWithoutNoteTakerQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerQueueInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoteTakerQueueNestedInput = {
    create?: XOR<UserCreateWithoutNoteTakerQueueInput, UserUncheckedCreateWithoutNoteTakerQueueInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerQueueInput
    upsert?: UserUpsertWithoutNoteTakerQueueInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteTakerQueueInput, UserUpdateWithoutNoteTakerQueueInput>, UserUncheckedUpdateWithoutNoteTakerQueueInput>
  }

  export type DepartmentCreateNestedOneWithoutServicesInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type BookingServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type HousekeepingTaskCreateNestedManyWithoutServiceInput = {
    create?: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput> | HousekeepingTaskCreateWithoutServiceInput[] | HousekeepingTaskUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutServiceInput | HousekeepingTaskCreateOrConnectWithoutServiceInput[]
    createMany?: HousekeepingTaskCreateManyServiceInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type BookingServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
  }

  export type HousekeepingTaskUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput> | HousekeepingTaskCreateWithoutServiceInput[] | HousekeepingTaskUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutServiceInput | HousekeepingTaskCreateOrConnectWithoutServiceInput[]
    createMany?: HousekeepingTaskCreateManyServiceInputEnvelope
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type DepartmentUpdateOneWithoutServicesNestedInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    upsert?: DepartmentUpsertWithoutServicesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutServicesInput, DepartmentUpdateWithoutServicesInput>, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type BookingServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type HousekeepingTaskUpdateManyWithoutServiceNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput> | HousekeepingTaskCreateWithoutServiceInput[] | HousekeepingTaskUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutServiceInput | HousekeepingTaskCreateOrConnectWithoutServiceInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutServiceInput | HousekeepingTaskUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: HousekeepingTaskCreateManyServiceInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutServiceInput | HousekeepingTaskUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutServiceInput | HousekeepingTaskUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput> | BookingServiceCreateWithoutServiceInput[] | BookingServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: BookingServiceCreateOrConnectWithoutServiceInput | BookingServiceCreateOrConnectWithoutServiceInput[]
    upsert?: BookingServiceUpsertWithWhereUniqueWithoutServiceInput | BookingServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: BookingServiceCreateManyServiceInputEnvelope
    set?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    disconnect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    delete?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    connect?: BookingServiceWhereUniqueInput | BookingServiceWhereUniqueInput[]
    update?: BookingServiceUpdateWithWhereUniqueWithoutServiceInput | BookingServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: BookingServiceUpdateManyWithWhereWithoutServiceInput | BookingServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput> | HousekeepingTaskCreateWithoutServiceInput[] | HousekeepingTaskUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: HousekeepingTaskCreateOrConnectWithoutServiceInput | HousekeepingTaskCreateOrConnectWithoutServiceInput[]
    upsert?: HousekeepingTaskUpsertWithWhereUniqueWithoutServiceInput | HousekeepingTaskUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: HousekeepingTaskCreateManyServiceInputEnvelope
    set?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    disconnect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    delete?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    connect?: HousekeepingTaskWhereUniqueInput | HousekeepingTaskWhereUniqueInput[]
    update?: HousekeepingTaskUpdateWithWhereUniqueWithoutServiceInput | HousekeepingTaskUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: HousekeepingTaskUpdateManyWithWhereWithoutServiceInput | HousekeepingTaskUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutServicesInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    connect?: BookingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutBookingUsagesInput = {
    create?: XOR<ServiceCreateWithoutBookingUsagesInput, ServiceUncheckedCreateWithoutBookingUsagesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingUsagesInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus
  }

  export type BookingUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutServicesInput
    upsert?: BookingUpsertWithoutServicesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutServicesInput, BookingUpdateWithoutServicesInput>, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutBookingUsagesNestedInput = {
    create?: XOR<ServiceCreateWithoutBookingUsagesInput, ServiceUncheckedCreateWithoutBookingUsagesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutBookingUsagesInput
    upsert?: ServiceUpsertWithoutBookingUsagesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutBookingUsagesInput, ServiceUpdateWithoutBookingUsagesInput>, ServiceUncheckedUpdateWithoutBookingUsagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotifTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotifType
  }

  export type NullableEnumRefTypeFieldUpdateOperationsInput = {
    set?: $Enums.RefType | null
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutNoteTakerLeavesInput = {
    create?: XOR<UserCreateWithoutNoteTakerLeavesInput, UserUncheckedCreateWithoutNoteTakerLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerLeavesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNoteTakerLeavesNestedInput = {
    create?: XOR<UserCreateWithoutNoteTakerLeavesInput, UserUncheckedCreateWithoutNoteTakerLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNoteTakerLeavesInput
    upsert?: UserUpsertWithoutNoteTakerLeavesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNoteTakerLeavesInput, UserUpdateWithoutNoteTakerLeavesInput>, UserUncheckedUpdateWithoutNoteTakerLeavesInput>
  }

  export type BookingCreateNestedOneWithoutHousekeepingTasksInput = {
    create?: XOR<BookingCreateWithoutHousekeepingTasksInput, BookingUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: BookingCreateOrConnectWithoutHousekeepingTasksInput
    connect?: BookingWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutHousekeepingTasksInput = {
    create?: XOR<ServiceCreateWithoutHousekeepingTasksInput, ServiceUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutHousekeepingTasksInput
    connect?: ServiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHousekeepingTasksInput = {
    create?: XOR<UserCreateWithoutHousekeepingTasksInput, UserUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutHousekeepingTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumHousekeepingTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.HousekeepingTaskStatus
  }

  export type BookingUpdateOneRequiredWithoutHousekeepingTasksNestedInput = {
    create?: XOR<BookingCreateWithoutHousekeepingTasksInput, BookingUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: BookingCreateOrConnectWithoutHousekeepingTasksInput
    upsert?: BookingUpsertWithoutHousekeepingTasksInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutHousekeepingTasksInput, BookingUpdateWithoutHousekeepingTasksInput>, BookingUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type ServiceUpdateOneRequiredWithoutHousekeepingTasksNestedInput = {
    create?: XOR<ServiceCreateWithoutHousekeepingTasksInput, ServiceUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutHousekeepingTasksInput
    upsert?: ServiceUpsertWithoutHousekeepingTasksInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutHousekeepingTasksInput, ServiceUpdateWithoutHousekeepingTasksInput>, ServiceUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type UserUpdateOneWithoutHousekeepingTasksNestedInput = {
    create?: XOR<UserCreateWithoutHousekeepingTasksInput, UserUncheckedCreateWithoutHousekeepingTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutHousekeepingTasksInput
    upsert?: UserUpsertWithoutHousekeepingTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHousekeepingTasksInput, UserUpdateWithoutHousekeepingTasksInput>, UserUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type UserCreateNestedOneWithoutReportedIssuesInput = {
    create?: XOR<UserCreateWithoutReportedIssuesInput, UserUncheckedCreateWithoutReportedIssuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedIssuesInput
    connect?: UserWhereUniqueInput
  }

  export type MeetingRoomCreateNestedOneWithoutIssuesInput = {
    create?: XOR<MeetingRoomCreateWithoutIssuesInput, MeetingRoomUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: MeetingRoomCreateOrConnectWithoutIssuesInput
    connect?: MeetingRoomWhereUniqueInput
  }

  export type IssueCommentCreateNestedManyWithoutIssueInput = {
    create?: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput> | IssueCommentCreateWithoutIssueInput[] | IssueCommentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutIssueInput | IssueCommentCreateOrConnectWithoutIssueInput[]
    createMany?: IssueCommentCreateManyIssueInputEnvelope
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
  }

  export type IssueAttachmentCreateNestedManyWithoutIssueInput = {
    create?: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput> | IssueAttachmentCreateWithoutIssueInput[] | IssueAttachmentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueAttachmentCreateOrConnectWithoutIssueInput | IssueAttachmentCreateOrConnectWithoutIssueInput[]
    createMany?: IssueAttachmentCreateManyIssueInputEnvelope
    connect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
  }

  export type IssueCommentUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput> | IssueCommentCreateWithoutIssueInput[] | IssueCommentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutIssueInput | IssueCommentCreateOrConnectWithoutIssueInput[]
    createMany?: IssueCommentCreateManyIssueInputEnvelope
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
  }

  export type IssueAttachmentUncheckedCreateNestedManyWithoutIssueInput = {
    create?: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput> | IssueAttachmentCreateWithoutIssueInput[] | IssueAttachmentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueAttachmentCreateOrConnectWithoutIssueInput | IssueAttachmentCreateOrConnectWithoutIssueInput[]
    createMany?: IssueAttachmentCreateManyIssueInputEnvelope
    connect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
  }

  export type EnumIssueTypeFieldUpdateOperationsInput = {
    set?: $Enums.IssueType
  }

  export type EnumIssuePriorityFieldUpdateOperationsInput = {
    set?: $Enums.IssuePriority
  }

  export type EnumIssueStatusFieldUpdateOperationsInput = {
    set?: $Enums.IssueStatus
  }

  export type UserUpdateOneRequiredWithoutReportedIssuesNestedInput = {
    create?: XOR<UserCreateWithoutReportedIssuesInput, UserUncheckedCreateWithoutReportedIssuesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportedIssuesInput
    upsert?: UserUpsertWithoutReportedIssuesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportedIssuesInput, UserUpdateWithoutReportedIssuesInput>, UserUncheckedUpdateWithoutReportedIssuesInput>
  }

  export type MeetingRoomUpdateOneWithoutIssuesNestedInput = {
    create?: XOR<MeetingRoomCreateWithoutIssuesInput, MeetingRoomUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: MeetingRoomCreateOrConnectWithoutIssuesInput
    upsert?: MeetingRoomUpsertWithoutIssuesInput
    disconnect?: MeetingRoomWhereInput | boolean
    delete?: MeetingRoomWhereInput | boolean
    connect?: MeetingRoomWhereUniqueInput
    update?: XOR<XOR<MeetingRoomUpdateToOneWithWhereWithoutIssuesInput, MeetingRoomUpdateWithoutIssuesInput>, MeetingRoomUncheckedUpdateWithoutIssuesInput>
  }

  export type IssueCommentUpdateManyWithoutIssueNestedInput = {
    create?: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput> | IssueCommentCreateWithoutIssueInput[] | IssueCommentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutIssueInput | IssueCommentCreateOrConnectWithoutIssueInput[]
    upsert?: IssueCommentUpsertWithWhereUniqueWithoutIssueInput | IssueCommentUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: IssueCommentCreateManyIssueInputEnvelope
    set?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    disconnect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    delete?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    update?: IssueCommentUpdateWithWhereUniqueWithoutIssueInput | IssueCommentUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: IssueCommentUpdateManyWithWhereWithoutIssueInput | IssueCommentUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
  }

  export type IssueAttachmentUpdateManyWithoutIssueNestedInput = {
    create?: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput> | IssueAttachmentCreateWithoutIssueInput[] | IssueAttachmentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueAttachmentCreateOrConnectWithoutIssueInput | IssueAttachmentCreateOrConnectWithoutIssueInput[]
    upsert?: IssueAttachmentUpsertWithWhereUniqueWithoutIssueInput | IssueAttachmentUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: IssueAttachmentCreateManyIssueInputEnvelope
    set?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    disconnect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    delete?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    connect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    update?: IssueAttachmentUpdateWithWhereUniqueWithoutIssueInput | IssueAttachmentUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: IssueAttachmentUpdateManyWithWhereWithoutIssueInput | IssueAttachmentUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: IssueAttachmentScalarWhereInput | IssueAttachmentScalarWhereInput[]
  }

  export type IssueCommentUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput> | IssueCommentCreateWithoutIssueInput[] | IssueCommentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueCommentCreateOrConnectWithoutIssueInput | IssueCommentCreateOrConnectWithoutIssueInput[]
    upsert?: IssueCommentUpsertWithWhereUniqueWithoutIssueInput | IssueCommentUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: IssueCommentCreateManyIssueInputEnvelope
    set?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    disconnect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    delete?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    connect?: IssueCommentWhereUniqueInput | IssueCommentWhereUniqueInput[]
    update?: IssueCommentUpdateWithWhereUniqueWithoutIssueInput | IssueCommentUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: IssueCommentUpdateManyWithWhereWithoutIssueInput | IssueCommentUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
  }

  export type IssueAttachmentUncheckedUpdateManyWithoutIssueNestedInput = {
    create?: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput> | IssueAttachmentCreateWithoutIssueInput[] | IssueAttachmentUncheckedCreateWithoutIssueInput[]
    connectOrCreate?: IssueAttachmentCreateOrConnectWithoutIssueInput | IssueAttachmentCreateOrConnectWithoutIssueInput[]
    upsert?: IssueAttachmentUpsertWithWhereUniqueWithoutIssueInput | IssueAttachmentUpsertWithWhereUniqueWithoutIssueInput[]
    createMany?: IssueAttachmentCreateManyIssueInputEnvelope
    set?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    disconnect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    delete?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    connect?: IssueAttachmentWhereUniqueInput | IssueAttachmentWhereUniqueInput[]
    update?: IssueAttachmentUpdateWithWhereUniqueWithoutIssueInput | IssueAttachmentUpdateWithWhereUniqueWithoutIssueInput[]
    updateMany?: IssueAttachmentUpdateManyWithWhereWithoutIssueInput | IssueAttachmentUpdateManyWithWhereWithoutIssueInput[]
    deleteMany?: IssueAttachmentScalarWhereInput | IssueAttachmentScalarWhereInput[]
  }

  export type IssueCreateNestedOneWithoutCommentsInput = {
    create?: XOR<IssueCreateWithoutCommentsInput, IssueUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutCommentsInput
    connect?: IssueWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIssueCommentsInput = {
    create?: XOR<UserCreateWithoutIssueCommentsInput, UserUncheckedCreateWithoutIssueCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssueCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type IssueUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<IssueCreateWithoutCommentsInput, IssueUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutCommentsInput
    upsert?: IssueUpsertWithoutCommentsInput
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutCommentsInput, IssueUpdateWithoutCommentsInput>, IssueUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutIssueCommentsNestedInput = {
    create?: XOR<UserCreateWithoutIssueCommentsInput, UserUncheckedCreateWithoutIssueCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutIssueCommentsInput
    upsert?: UserUpsertWithoutIssueCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIssueCommentsInput, UserUpdateWithoutIssueCommentsInput>, UserUncheckedUpdateWithoutIssueCommentsInput>
  }

  export type IssueCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<IssueCreateWithoutAttachmentsInput, IssueUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAttachmentsInput
    connect?: IssueWhereUniqueInput
  }

  export type IssueUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<IssueCreateWithoutAttachmentsInput, IssueUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: IssueCreateOrConnectWithoutAttachmentsInput
    upsert?: IssueUpsertWithoutAttachmentsInput
    connect?: IssueWhereUniqueInput
    update?: XOR<XOR<IssueUpdateToOneWithWhereWithoutAttachmentsInput, IssueUpdateWithoutAttachmentsInput>, IssueUncheckedUpdateWithoutAttachmentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumNoteQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteQueueStatus | EnumNoteQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteQueueStatusFilter<$PrismaModel> | $Enums.NoteQueueStatus
  }

  export type NestedEnumNoteQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteQueueStatus | EnumNoteQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteQueueStatus[] | ListEnumNoteQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.NoteQueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumNoteQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotifTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotifType | EnumNotifTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotifTypeFilter<$PrismaModel> | $Enums.NotifType
  }

  export type NestedEnumRefTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefType | EnumRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefTypeNullableFilter<$PrismaModel> | $Enums.RefType | null
  }

  export type NestedEnumNotifTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotifType | EnumNotifTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotifType[] | ListEnumNotifTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotifTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotifType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotifTypeFilter<$PrismaModel>
    _max?: NestedEnumNotifTypeFilter<$PrismaModel>
  }

  export type NestedEnumRefTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefType | EnumRefTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RefType[] | ListEnumRefTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRefTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumRefTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumHousekeepingTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HousekeepingTaskStatus | EnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel> | $Enums.HousekeepingTaskStatus
  }

  export type NestedEnumHousekeepingTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HousekeepingTaskStatus | EnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HousekeepingTaskStatus[] | ListEnumHousekeepingTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHousekeepingTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.HousekeepingTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumHousekeepingTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumIssueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
  }

  export type NestedEnumIssuePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuePriority | EnumIssuePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuePriorityFilter<$PrismaModel> | $Enums.IssuePriority
  }

  export type NestedEnumIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
  }

  export type NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueType[] | ListEnumIssueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueTypeFilter<$PrismaModel>
    _max?: NestedEnumIssueTypeFilter<$PrismaModel>
  }

  export type NestedEnumIssuePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssuePriority | EnumIssuePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssuePriority[] | ListEnumIssuePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssuePriorityWithAggregatesFilter<$PrismaModel> | $Enums.IssuePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssuePriorityFilter<$PrismaModel>
    _max?: NestedEnumIssuePriorityFilter<$PrismaModel>
  }

  export type NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumIssueStatusFilter<$PrismaModel>
  }

  export type PositionCreateWithoutDepartmentInput = {
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    users?: UserCreateNestedManyWithoutPositionInput
    neededBy?: BookingRequiredPositionCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
    neededBy?: BookingRequiredPositionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput>
  }

  export type PositionCreateManyDepartmentInputEnvelope = {
    data: PositionCreateManyDepartmentInput | PositionCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutDepartmentInput = {
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
    bookingUsages?: BookingServiceCreateNestedManyWithoutServiceInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutDepartmentInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
    bookingUsages?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceCreateManyDepartmentInputEnvelope = {
    data: ServiceCreateManyDepartmentInput | ServiceCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type PositionUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutDepartmentInput, PositionUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PositionCreateWithoutDepartmentInput, PositionUncheckedCreateWithoutDepartmentInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutDepartmentInput, PositionUncheckedUpdateWithoutDepartmentInput>
  }

  export type PositionUpdateManyWithWhereWithoutDepartmentInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type PositionScalarWhereInput = {
    AND?: PositionScalarWhereInput | PositionScalarWhereInput[]
    OR?: PositionScalarWhereInput[]
    NOT?: PositionScalarWhereInput | PositionScalarWhereInput[]
    id?: IntFilter<"Position"> | number
    name?: StringFilter<"Position"> | string
    isAdmin?: BoolFilter<"Position"> | boolean
    isNoteManager?: BoolFilter<"Position"> | boolean
    isNoteTaker?: BoolFilter<"Position"> | boolean
    isHousekeeper?: BoolFilter<"Position"> | boolean
    isHousekeepingLead?: BoolFilter<"Position"> | boolean
    description?: StringNullableFilter<"Position"> | string | null
    departmentId?: IntNullableFilter<"Position"> | number | null
  }

  export type ServiceUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
  }

  export type ServiceUpdateManyWithWhereWithoutDepartmentInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: IntNullableFilter<"Service"> | number | null
    requiresApproval?: BoolFilter<"Service"> | boolean
  }

  export type DepartmentCreateWithoutPositionsInput = {
    name: string
    services?: ServiceCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPositionsInput = {
    id?: number
    name: string
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPositionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
  }

  export type UserCreateWithoutPositionInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutPositionInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutPositionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserCreateManyPositionInputEnvelope = {
    data: UserCreateManyPositionInput | UserCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type BookingRequiredPositionCreateWithoutPositionInput = {
    booking: BookingCreateNestedOneWithoutRequiredPositionsInput
  }

  export type BookingRequiredPositionUncheckedCreateWithoutPositionInput = {
    id?: number
    bookingId: number
  }

  export type BookingRequiredPositionCreateOrConnectWithoutPositionInput = {
    where: BookingRequiredPositionWhereUniqueInput
    create: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput>
  }

  export type BookingRequiredPositionCreateManyPositionInputEnvelope = {
    data: BookingRequiredPositionCreateManyPositionInput | BookingRequiredPositionCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutPositionsInput = {
    update: XOR<DepartmentUpdateWithoutPositionsInput, DepartmentUncheckedUpdateWithoutPositionsInput>
    create: XOR<DepartmentCreateWithoutPositionsInput, DepartmentUncheckedCreateWithoutPositionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPositionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPositionsInput, DepartmentUncheckedUpdateWithoutPositionsInput>
  }

  export type DepartmentUpdateWithoutPositionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPositionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
    create: XOR<UserCreateWithoutPositionInput, UserUncheckedCreateWithoutPositionInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPositionInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPositionInput, UserUncheckedUpdateWithoutPositionInput>
  }

  export type UserUpdateManyWithWhereWithoutPositionInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutPositionInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    positionId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type BookingRequiredPositionUpsertWithWhereUniqueWithoutPositionInput = {
    where: BookingRequiredPositionWhereUniqueInput
    update: XOR<BookingRequiredPositionUpdateWithoutPositionInput, BookingRequiredPositionUncheckedUpdateWithoutPositionInput>
    create: XOR<BookingRequiredPositionCreateWithoutPositionInput, BookingRequiredPositionUncheckedCreateWithoutPositionInput>
  }

  export type BookingRequiredPositionUpdateWithWhereUniqueWithoutPositionInput = {
    where: BookingRequiredPositionWhereUniqueInput
    data: XOR<BookingRequiredPositionUpdateWithoutPositionInput, BookingRequiredPositionUncheckedUpdateWithoutPositionInput>
  }

  export type BookingRequiredPositionUpdateManyWithWhereWithoutPositionInput = {
    where: BookingRequiredPositionScalarWhereInput
    data: XOR<BookingRequiredPositionUpdateManyMutationInput, BookingRequiredPositionUncheckedUpdateManyWithoutPositionInput>
  }

  export type BookingRequiredPositionScalarWhereInput = {
    AND?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
    OR?: BookingRequiredPositionScalarWhereInput[]
    NOT?: BookingRequiredPositionScalarWhereInput | BookingRequiredPositionScalarWhereInput[]
    id?: IntFilter<"BookingRequiredPosition"> | number
    bookingId?: IntFilter<"BookingRequiredPosition"> | number
    positionId?: IntFilter<"BookingRequiredPosition"> | number
  }

  export type PositionCreateWithoutUsersInput = {
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    department?: DepartmentCreateNestedOneWithoutPositionsInput
    neededBy?: BookingRequiredPositionCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    departmentId?: number | null
    neededBy?: BookingRequiredPositionUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutUsersInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
  }

  export type BookingCreateWithoutBookedByInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutBookedByInput = {
    id?: number
    roomId: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput>
  }

  export type BookingCreateManyBookedByInputEnvelope = {
    data: BookingCreateManyBookedByInput | BookingCreateManyBookedByInput[]
    skipDuplicates?: boolean
  }

  export type BookingInviteCreateWithoutUserInput = {
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutInvitesInput
  }

  export type BookingInviteUncheckedCreateWithoutUserInput = {
    id?: number
    bookingId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingInviteCreateOrConnectWithoutUserInput = {
    where: BookingInviteWhereUniqueInput
    create: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput>
  }

  export type BookingInviteCreateManyUserInputEnvelope = {
    data: BookingInviteCreateManyUserInput | BookingInviteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BookingNoteTakerCreateWithoutUserInput = {
    roleIndex: number
    status?: $Enums.NoteQueueStatus
    booking: BookingCreateNestedOneWithoutNoteTakersInput
  }

  export type BookingNoteTakerUncheckedCreateWithoutUserInput = {
    id?: number
    bookingId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerCreateOrConnectWithoutUserInput = {
    where: BookingNoteTakerWhereUniqueInput
    create: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput>
  }

  export type BookingNoteTakerCreateManyUserInputEnvelope = {
    data: BookingNoteTakerCreateManyUserInput | BookingNoteTakerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NoteTakerQueueCreateWithoutUserInput = {
    orderNo: number
    isActive?: boolean
  }

  export type NoteTakerQueueUncheckedCreateWithoutUserInput = {
    id?: number
    orderNo: number
    isActive?: boolean
  }

  export type NoteTakerQueueCreateOrConnectWithoutUserInput = {
    where: NoteTakerQueueWhereUniqueInput
    create: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
  }

  export type NoteTakerLeaveCreateWithoutUserInput = {
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type NoteTakerLeaveUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type NoteTakerLeaveCreateOrConnectWithoutUserInput = {
    where: NoteTakerLeaveWhereUniqueInput
    create: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput>
  }

  export type NoteTakerLeaveCreateManyUserInputEnvelope = {
    data: NoteTakerLeaveCreateManyUserInput | NoteTakerLeaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type HousekeepingTaskCreateWithoutAssignedToInput = {
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutHousekeepingTasksInput
    service: ServiceCreateNestedOneWithoutHousekeepingTasksInput
  }

  export type HousekeepingTaskUncheckedCreateWithoutAssignedToInput = {
    id?: number
    bookingId: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingTaskCreateOrConnectWithoutAssignedToInput = {
    where: HousekeepingTaskWhereUniqueInput
    create: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type HousekeepingTaskCreateManyAssignedToInputEnvelope = {
    data: HousekeepingTaskCreateManyAssignedToInput | HousekeepingTaskCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutReporterInput = {
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    meetingRoom?: MeetingRoomCreateNestedOneWithoutIssuesInput
    comments?: IssueCommentCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutReporterInput = {
    id?: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: IssueCommentUncheckedCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutReporterInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput>
  }

  export type IssueCreateManyReporterInputEnvelope = {
    data: IssueCreateManyReporterInput | IssueCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type IssueCommentCreateWithoutAuthorInput = {
    message: string
    createdAt?: Date | string
    issue: IssueCreateNestedOneWithoutCommentsInput
  }

  export type IssueCommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    issueId: number
    message: string
    createdAt?: Date | string
  }

  export type IssueCommentCreateOrConnectWithoutAuthorInput = {
    where: IssueCommentWhereUniqueInput
    create: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput>
  }

  export type IssueCommentCreateManyAuthorInputEnvelope = {
    data: IssueCommentCreateManyAuthorInput | IssueCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PositionUpsertWithoutUsersInput = {
    update: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
    create: XOR<PositionCreateWithoutUsersInput, PositionUncheckedCreateWithoutUsersInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutUsersInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutUsersInput, PositionUncheckedUpdateWithoutUsersInput>
  }

  export type PositionUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPositionsNestedInput
    neededBy?: BookingRequiredPositionUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    neededBy?: BookingRequiredPositionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBookedByInput, BookingUncheckedUpdateWithoutBookedByInput>
    create: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBookedByInput, BookingUncheckedUpdateWithoutBookedByInput>
  }

  export type BookingUpdateManyWithWhereWithoutBookedByInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBookedByInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    roomId?: IntFilter<"Booking"> | number
    bookedById?: IntFilter<"Booking"> | number
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    purpose?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingInviteUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingInviteWhereUniqueInput
    update: XOR<BookingInviteUpdateWithoutUserInput, BookingInviteUncheckedUpdateWithoutUserInput>
    create: XOR<BookingInviteCreateWithoutUserInput, BookingInviteUncheckedCreateWithoutUserInput>
  }

  export type BookingInviteUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingInviteWhereUniqueInput
    data: XOR<BookingInviteUpdateWithoutUserInput, BookingInviteUncheckedUpdateWithoutUserInput>
  }

  export type BookingInviteUpdateManyWithWhereWithoutUserInput = {
    where: BookingInviteScalarWhereInput
    data: XOR<BookingInviteUpdateManyMutationInput, BookingInviteUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingInviteScalarWhereInput = {
    AND?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
    OR?: BookingInviteScalarWhereInput[]
    NOT?: BookingInviteScalarWhereInput | BookingInviteScalarWhereInput[]
    id?: IntFilter<"BookingInvite"> | number
    bookingId?: IntFilter<"BookingInvite"> | number
    userId?: IntFilter<"BookingInvite"> | number
    status?: EnumInviteStatusFilter<"BookingInvite"> | $Enums.InviteStatus
    respondedAt?: DateTimeNullableFilter<"BookingInvite"> | Date | string | null
  }

  export type BookingNoteTakerUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingNoteTakerWhereUniqueInput
    update: XOR<BookingNoteTakerUpdateWithoutUserInput, BookingNoteTakerUncheckedUpdateWithoutUserInput>
    create: XOR<BookingNoteTakerCreateWithoutUserInput, BookingNoteTakerUncheckedCreateWithoutUserInput>
  }

  export type BookingNoteTakerUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingNoteTakerWhereUniqueInput
    data: XOR<BookingNoteTakerUpdateWithoutUserInput, BookingNoteTakerUncheckedUpdateWithoutUserInput>
  }

  export type BookingNoteTakerUpdateManyWithWhereWithoutUserInput = {
    where: BookingNoteTakerScalarWhereInput
    data: XOR<BookingNoteTakerUpdateManyMutationInput, BookingNoteTakerUncheckedUpdateManyWithoutUserInput>
  }

  export type BookingNoteTakerScalarWhereInput = {
    AND?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
    OR?: BookingNoteTakerScalarWhereInput[]
    NOT?: BookingNoteTakerScalarWhereInput | BookingNoteTakerScalarWhereInput[]
    id?: IntFilter<"BookingNoteTaker"> | number
    bookingId?: IntFilter<"BookingNoteTaker"> | number
    userId?: IntFilter<"BookingNoteTaker"> | number
    roleIndex?: IntFilter<"BookingNoteTaker"> | number
    status?: EnumNoteQueueStatusFilter<"BookingNoteTaker"> | $Enums.NoteQueueStatus
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: EnumNotifTypeFilter<"Notification"> | $Enums.NotifType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    refType?: EnumRefTypeNullableFilter<"Notification"> | $Enums.RefType | null
    refId?: IntNullableFilter<"Notification"> | number | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
  }

  export type NoteTakerQueueUpsertWithoutUserInput = {
    update: XOR<NoteTakerQueueUpdateWithoutUserInput, NoteTakerQueueUncheckedUpdateWithoutUserInput>
    create: XOR<NoteTakerQueueCreateWithoutUserInput, NoteTakerQueueUncheckedCreateWithoutUserInput>
    where?: NoteTakerQueueWhereInput
  }

  export type NoteTakerQueueUpdateToOneWithWhereWithoutUserInput = {
    where?: NoteTakerQueueWhereInput
    data: XOR<NoteTakerQueueUpdateWithoutUserInput, NoteTakerQueueUncheckedUpdateWithoutUserInput>
  }

  export type NoteTakerQueueUpdateWithoutUserInput = {
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteTakerQueueUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNo?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteTakerLeaveUpsertWithWhereUniqueWithoutUserInput = {
    where: NoteTakerLeaveWhereUniqueInput
    update: XOR<NoteTakerLeaveUpdateWithoutUserInput, NoteTakerLeaveUncheckedUpdateWithoutUserInput>
    create: XOR<NoteTakerLeaveCreateWithoutUserInput, NoteTakerLeaveUncheckedCreateWithoutUserInput>
  }

  export type NoteTakerLeaveUpdateWithWhereUniqueWithoutUserInput = {
    where: NoteTakerLeaveWhereUniqueInput
    data: XOR<NoteTakerLeaveUpdateWithoutUserInput, NoteTakerLeaveUncheckedUpdateWithoutUserInput>
  }

  export type NoteTakerLeaveUpdateManyWithWhereWithoutUserInput = {
    where: NoteTakerLeaveScalarWhereInput
    data: XOR<NoteTakerLeaveUpdateManyMutationInput, NoteTakerLeaveUncheckedUpdateManyWithoutUserInput>
  }

  export type NoteTakerLeaveScalarWhereInput = {
    AND?: NoteTakerLeaveScalarWhereInput | NoteTakerLeaveScalarWhereInput[]
    OR?: NoteTakerLeaveScalarWhereInput[]
    NOT?: NoteTakerLeaveScalarWhereInput | NoteTakerLeaveScalarWhereInput[]
    id?: IntFilter<"NoteTakerLeave"> | number
    userId?: IntFilter<"NoteTakerLeave"> | number
    date?: DateTimeFilter<"NoteTakerLeave"> | Date | string
    reason?: StringNullableFilter<"NoteTakerLeave"> | string | null
    createdAt?: DateTimeFilter<"NoteTakerLeave"> | Date | string
  }

  export type HousekeepingTaskUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: HousekeepingTaskWhereUniqueInput
    update: XOR<HousekeepingTaskUpdateWithoutAssignedToInput, HousekeepingTaskUncheckedUpdateWithoutAssignedToInput>
    create: XOR<HousekeepingTaskCreateWithoutAssignedToInput, HousekeepingTaskUncheckedCreateWithoutAssignedToInput>
  }

  export type HousekeepingTaskUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: HousekeepingTaskWhereUniqueInput
    data: XOR<HousekeepingTaskUpdateWithoutAssignedToInput, HousekeepingTaskUncheckedUpdateWithoutAssignedToInput>
  }

  export type HousekeepingTaskUpdateManyWithWhereWithoutAssignedToInput = {
    where: HousekeepingTaskScalarWhereInput
    data: XOR<HousekeepingTaskUpdateManyMutationInput, HousekeepingTaskUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type HousekeepingTaskScalarWhereInput = {
    AND?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
    OR?: HousekeepingTaskScalarWhereInput[]
    NOT?: HousekeepingTaskScalarWhereInput | HousekeepingTaskScalarWhereInput[]
    id?: IntFilter<"HousekeepingTask"> | number
    bookingId?: IntFilter<"HousekeepingTask"> | number
    serviceId?: IntFilter<"HousekeepingTask"> | number
    status?: EnumHousekeepingTaskStatusFilter<"HousekeepingTask"> | $Enums.HousekeepingTaskStatus
    assignedToId?: IntNullableFilter<"HousekeepingTask"> | number | null
    note?: StringNullableFilter<"HousekeepingTask"> | string | null
    createdAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
    updatedAt?: DateTimeFilter<"HousekeepingTask"> | Date | string
  }

  export type IssueUpsertWithWhereUniqueWithoutReporterInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutReporterInput, IssueUncheckedUpdateWithoutReporterInput>
    create: XOR<IssueCreateWithoutReporterInput, IssueUncheckedCreateWithoutReporterInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutReporterInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutReporterInput, IssueUncheckedUpdateWithoutReporterInput>
  }

  export type IssueUpdateManyWithWhereWithoutReporterInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutReporterInput>
  }

  export type IssueScalarWhereInput = {
    AND?: IssueScalarWhereInput | IssueScalarWhereInput[]
    OR?: IssueScalarWhereInput[]
    NOT?: IssueScalarWhereInput | IssueScalarWhereInput[]
    id?: IntFilter<"Issue"> | number
    reporterId?: IntFilter<"Issue"> | number
    roomId?: IntNullableFilter<"Issue"> | number | null
    issueType?: EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
    subject?: StringFilter<"Issue"> | string
    description?: StringFilter<"Issue"> | string
    priority?: EnumIssuePriorityFilter<"Issue"> | $Enums.IssuePriority
    status?: EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"Issue"> | Date | string
    updatedAt?: DateTimeFilter<"Issue"> | Date | string
  }

  export type IssueCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: IssueCommentWhereUniqueInput
    update: XOR<IssueCommentUpdateWithoutAuthorInput, IssueCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<IssueCommentCreateWithoutAuthorInput, IssueCommentUncheckedCreateWithoutAuthorInput>
  }

  export type IssueCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: IssueCommentWhereUniqueInput
    data: XOR<IssueCommentUpdateWithoutAuthorInput, IssueCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type IssueCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: IssueCommentScalarWhereInput
    data: XOR<IssueCommentUpdateManyMutationInput, IssueCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type IssueCommentScalarWhereInput = {
    AND?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
    OR?: IssueCommentScalarWhereInput[]
    NOT?: IssueCommentScalarWhereInput | IssueCommentScalarWhereInput[]
    id?: IntFilter<"IssueComment"> | number
    issueId?: IntFilter<"IssueComment"> | number
    authorId?: IntFilter<"IssueComment"> | number
    message?: StringFilter<"IssueComment"> | string
    createdAt?: DateTimeFilter<"IssueComment"> | Date | string
  }

  export type BookingCreateWithoutRoomInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRoomInput = {
    id?: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRoomInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput>
  }

  export type BookingCreateManyRoomInputEnvelope = {
    data: BookingCreateManyRoomInput | BookingCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type IssueCreateWithoutMeetingRoomInput = {
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedIssuesInput
    comments?: IssueCommentCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutMeetingRoomInput = {
    id?: number
    reporterId: number
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: IssueCommentUncheckedCreateNestedManyWithoutIssueInput
    attachments?: IssueAttachmentUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutMeetingRoomInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput>
  }

  export type IssueCreateManyMeetingRoomInputEnvelope = {
    data: IssueCreateManyMeetingRoomInput | IssueCreateManyMeetingRoomInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutRoomInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRoomInput, BookingUncheckedUpdateWithoutRoomInput>
    create: XOR<BookingCreateWithoutRoomInput, BookingUncheckedCreateWithoutRoomInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRoomInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRoomInput, BookingUncheckedUpdateWithoutRoomInput>
  }

  export type BookingUpdateManyWithWhereWithoutRoomInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRoomInput>
  }

  export type IssueUpsertWithWhereUniqueWithoutMeetingRoomInput = {
    where: IssueWhereUniqueInput
    update: XOR<IssueUpdateWithoutMeetingRoomInput, IssueUncheckedUpdateWithoutMeetingRoomInput>
    create: XOR<IssueCreateWithoutMeetingRoomInput, IssueUncheckedCreateWithoutMeetingRoomInput>
  }

  export type IssueUpdateWithWhereUniqueWithoutMeetingRoomInput = {
    where: IssueWhereUniqueInput
    data: XOR<IssueUpdateWithoutMeetingRoomInput, IssueUncheckedUpdateWithoutMeetingRoomInput>
  }

  export type IssueUpdateManyWithWhereWithoutMeetingRoomInput = {
    where: IssueScalarWhereInput
    data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutMeetingRoomInput>
  }

  export type MeetingRoomCreateWithoutBookingsInput = {
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    issues?: IssueCreateNestedManyWithoutMeetingRoomInput
  }

  export type MeetingRoomUncheckedCreateWithoutBookingsInput = {
    id?: number
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    issues?: IssueUncheckedCreateNestedManyWithoutMeetingRoomInput
  }

  export type MeetingRoomCreateOrConnectWithoutBookingsInput = {
    where: MeetingRoomWhereUniqueInput
    create: XOR<MeetingRoomCreateWithoutBookingsInput, MeetingRoomUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsBookedInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBookingsBookedInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBookingsBookedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsBookedInput, UserUncheckedCreateWithoutBookingsBookedInput>
  }

  export type BookingRequiredPositionCreateWithoutBookingInput = {
    position: PositionCreateNestedOneWithoutNeededByInput
  }

  export type BookingRequiredPositionUncheckedCreateWithoutBookingInput = {
    id?: number
    positionId: number
  }

  export type BookingRequiredPositionCreateOrConnectWithoutBookingInput = {
    where: BookingRequiredPositionWhereUniqueInput
    create: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput>
  }

  export type BookingRequiredPositionCreateManyBookingInputEnvelope = {
    data: BookingRequiredPositionCreateManyBookingInput | BookingRequiredPositionCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingInviteCreateWithoutBookingInput = {
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
    user: UserCreateNestedOneWithoutBookingInvitesInput
  }

  export type BookingInviteUncheckedCreateWithoutBookingInput = {
    id?: number
    userId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingInviteCreateOrConnectWithoutBookingInput = {
    where: BookingInviteWhereUniqueInput
    create: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput>
  }

  export type BookingInviteCreateManyBookingInputEnvelope = {
    data: BookingInviteCreateManyBookingInput | BookingInviteCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingNoteTakerCreateWithoutBookingInput = {
    roleIndex: number
    status?: $Enums.NoteQueueStatus
    user: UserCreateNestedOneWithoutNoteTakerAssignsInput
  }

  export type BookingNoteTakerUncheckedCreateWithoutBookingInput = {
    id?: number
    userId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerCreateOrConnectWithoutBookingInput = {
    where: BookingNoteTakerWhereUniqueInput
    create: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput>
  }

  export type BookingNoteTakerCreateManyBookingInputEnvelope = {
    data: BookingNoteTakerCreateManyBookingInput | BookingNoteTakerCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingServiceCreateWithoutBookingInput = {
    quantity?: number | null
    status?: $Enums.ServiceStatus
    service: ServiceCreateNestedOneWithoutBookingUsagesInput
  }

  export type BookingServiceUncheckedCreateWithoutBookingInput = {
    id?: number
    serviceId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type BookingServiceCreateOrConnectWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceCreateManyBookingInputEnvelope = {
    data: BookingServiceCreateManyBookingInput | BookingServiceCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type HousekeepingTaskCreateWithoutBookingInput = {
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutHousekeepingTasksInput
    assignedTo?: UserCreateNestedOneWithoutHousekeepingTasksInput
  }

  export type HousekeepingTaskUncheckedCreateWithoutBookingInput = {
    id?: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingTaskCreateOrConnectWithoutBookingInput = {
    where: HousekeepingTaskWhereUniqueInput
    create: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput>
  }

  export type HousekeepingTaskCreateManyBookingInputEnvelope = {
    data: HousekeepingTaskCreateManyBookingInput | HousekeepingTaskCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type MeetingRoomUpsertWithoutBookingsInput = {
    update: XOR<MeetingRoomUpdateWithoutBookingsInput, MeetingRoomUncheckedUpdateWithoutBookingsInput>
    create: XOR<MeetingRoomCreateWithoutBookingsInput, MeetingRoomUncheckedCreateWithoutBookingsInput>
    where?: MeetingRoomWhereInput
  }

  export type MeetingRoomUpdateToOneWithWhereWithoutBookingsInput = {
    where?: MeetingRoomWhereInput
    data: XOR<MeetingRoomUpdateWithoutBookingsInput, MeetingRoomUncheckedUpdateWithoutBookingsInput>
  }

  export type MeetingRoomUpdateWithoutBookingsInput = {
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    issues?: IssueUpdateManyWithoutMeetingRoomNestedInput
  }

  export type MeetingRoomUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    issues?: IssueUncheckedUpdateManyWithoutMeetingRoomNestedInput
  }

  export type UserUpsertWithoutBookingsBookedInput = {
    update: XOR<UserUpdateWithoutBookingsBookedInput, UserUncheckedUpdateWithoutBookingsBookedInput>
    create: XOR<UserCreateWithoutBookingsBookedInput, UserUncheckedCreateWithoutBookingsBookedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsBookedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsBookedInput, UserUncheckedUpdateWithoutBookingsBookedInput>
  }

  export type UserUpdateWithoutBookingsBookedInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsBookedInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BookingRequiredPositionUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingRequiredPositionWhereUniqueInput
    update: XOR<BookingRequiredPositionUpdateWithoutBookingInput, BookingRequiredPositionUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingRequiredPositionCreateWithoutBookingInput, BookingRequiredPositionUncheckedCreateWithoutBookingInput>
  }

  export type BookingRequiredPositionUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingRequiredPositionWhereUniqueInput
    data: XOR<BookingRequiredPositionUpdateWithoutBookingInput, BookingRequiredPositionUncheckedUpdateWithoutBookingInput>
  }

  export type BookingRequiredPositionUpdateManyWithWhereWithoutBookingInput = {
    where: BookingRequiredPositionScalarWhereInput
    data: XOR<BookingRequiredPositionUpdateManyMutationInput, BookingRequiredPositionUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingInviteUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingInviteWhereUniqueInput
    update: XOR<BookingInviteUpdateWithoutBookingInput, BookingInviteUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingInviteCreateWithoutBookingInput, BookingInviteUncheckedCreateWithoutBookingInput>
  }

  export type BookingInviteUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingInviteWhereUniqueInput
    data: XOR<BookingInviteUpdateWithoutBookingInput, BookingInviteUncheckedUpdateWithoutBookingInput>
  }

  export type BookingInviteUpdateManyWithWhereWithoutBookingInput = {
    where: BookingInviteScalarWhereInput
    data: XOR<BookingInviteUpdateManyMutationInput, BookingInviteUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingNoteTakerUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingNoteTakerWhereUniqueInput
    update: XOR<BookingNoteTakerUpdateWithoutBookingInput, BookingNoteTakerUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingNoteTakerCreateWithoutBookingInput, BookingNoteTakerUncheckedCreateWithoutBookingInput>
  }

  export type BookingNoteTakerUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingNoteTakerWhereUniqueInput
    data: XOR<BookingNoteTakerUpdateWithoutBookingInput, BookingNoteTakerUncheckedUpdateWithoutBookingInput>
  }

  export type BookingNoteTakerUpdateManyWithWhereWithoutBookingInput = {
    where: BookingNoteTakerScalarWhereInput
    data: XOR<BookingNoteTakerUpdateManyMutationInput, BookingNoteTakerUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingServiceCreateWithoutBookingInput, BookingServiceUncheckedCreateWithoutBookingInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutBookingInput, BookingServiceUncheckedUpdateWithoutBookingInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutBookingInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingServiceScalarWhereInput = {
    AND?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    OR?: BookingServiceScalarWhereInput[]
    NOT?: BookingServiceScalarWhereInput | BookingServiceScalarWhereInput[]
    id?: IntFilter<"BookingService"> | number
    bookingId?: IntFilter<"BookingService"> | number
    serviceId?: IntFilter<"BookingService"> | number
    quantity?: IntNullableFilter<"BookingService"> | number | null
    status?: EnumServiceStatusFilter<"BookingService"> | $Enums.ServiceStatus
  }

  export type HousekeepingTaskUpsertWithWhereUniqueWithoutBookingInput = {
    where: HousekeepingTaskWhereUniqueInput
    update: XOR<HousekeepingTaskUpdateWithoutBookingInput, HousekeepingTaskUncheckedUpdateWithoutBookingInput>
    create: XOR<HousekeepingTaskCreateWithoutBookingInput, HousekeepingTaskUncheckedCreateWithoutBookingInput>
  }

  export type HousekeepingTaskUpdateWithWhereUniqueWithoutBookingInput = {
    where: HousekeepingTaskWhereUniqueInput
    data: XOR<HousekeepingTaskUpdateWithoutBookingInput, HousekeepingTaskUncheckedUpdateWithoutBookingInput>
  }

  export type HousekeepingTaskUpdateManyWithWhereWithoutBookingInput = {
    where: HousekeepingTaskScalarWhereInput
    data: XOR<HousekeepingTaskUpdateManyMutationInput, HousekeepingTaskUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingCreateWithoutRequiredPositionsInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRequiredPositionsInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRequiredPositionsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRequiredPositionsInput, BookingUncheckedCreateWithoutRequiredPositionsInput>
  }

  export type PositionCreateWithoutNeededByInput = {
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    department?: DepartmentCreateNestedOneWithoutPositionsInput
    users?: UserCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutNeededByInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
    departmentId?: number | null
    users?: UserUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutNeededByInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutNeededByInput, PositionUncheckedCreateWithoutNeededByInput>
  }

  export type BookingUpsertWithoutRequiredPositionsInput = {
    update: XOR<BookingUpdateWithoutRequiredPositionsInput, BookingUncheckedUpdateWithoutRequiredPositionsInput>
    create: XOR<BookingCreateWithoutRequiredPositionsInput, BookingUncheckedCreateWithoutRequiredPositionsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutRequiredPositionsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutRequiredPositionsInput, BookingUncheckedUpdateWithoutRequiredPositionsInput>
  }

  export type BookingUpdateWithoutRequiredPositionsInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRequiredPositionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PositionUpsertWithoutNeededByInput = {
    update: XOR<PositionUpdateWithoutNeededByInput, PositionUncheckedUpdateWithoutNeededByInput>
    create: XOR<PositionCreateWithoutNeededByInput, PositionUncheckedCreateWithoutNeededByInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutNeededByInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutNeededByInput, PositionUncheckedUpdateWithoutNeededByInput>
  }

  export type PositionUpdateWithoutNeededByInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPositionsNestedInput
    users?: UserUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutNeededByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type BookingCreateWithoutInvitesInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutInvitesInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutInvitesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInvitesInput, BookingUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutBookingInvitesInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBookingInvitesInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBookingInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingInvitesInput, UserUncheckedCreateWithoutBookingInvitesInput>
  }

  export type BookingUpsertWithoutInvitesInput = {
    update: XOR<BookingUpdateWithoutInvitesInput, BookingUncheckedUpdateWithoutInvitesInput>
    create: XOR<BookingCreateWithoutInvitesInput, BookingUncheckedCreateWithoutInvitesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInvitesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInvitesInput, BookingUncheckedUpdateWithoutInvitesInput>
  }

  export type BookingUpdateWithoutInvitesInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInvitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutBookingInvitesInput = {
    update: XOR<UserUpdateWithoutBookingInvitesInput, UserUncheckedUpdateWithoutBookingInvitesInput>
    create: XOR<UserCreateWithoutBookingInvitesInput, UserUncheckedCreateWithoutBookingInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingInvitesInput, UserUncheckedUpdateWithoutBookingInvitesInput>
  }

  export type UserUpdateWithoutBookingInvitesInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingInvitesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BookingCreateWithoutNoteTakersInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutNoteTakersInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutNoteTakersInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutNoteTakersInput, BookingUncheckedCreateWithoutNoteTakersInput>
  }

  export type UserCreateWithoutNoteTakerAssignsInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutNoteTakerAssignsInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutNoteTakerAssignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteTakerAssignsInput, UserUncheckedCreateWithoutNoteTakerAssignsInput>
  }

  export type BookingUpsertWithoutNoteTakersInput = {
    update: XOR<BookingUpdateWithoutNoteTakersInput, BookingUncheckedUpdateWithoutNoteTakersInput>
    create: XOR<BookingCreateWithoutNoteTakersInput, BookingUncheckedCreateWithoutNoteTakersInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutNoteTakersInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutNoteTakersInput, BookingUncheckedUpdateWithoutNoteTakersInput>
  }

  export type BookingUpdateWithoutNoteTakersInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutNoteTakersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutNoteTakerAssignsInput = {
    update: XOR<UserUpdateWithoutNoteTakerAssignsInput, UserUncheckedUpdateWithoutNoteTakerAssignsInput>
    create: XOR<UserCreateWithoutNoteTakerAssignsInput, UserUncheckedCreateWithoutNoteTakerAssignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteTakerAssignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteTakerAssignsInput, UserUncheckedUpdateWithoutNoteTakerAssignsInput>
  }

  export type UserUpdateWithoutNoteTakerAssignsInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteTakerAssignsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutNoteTakerQueueInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutNoteTakerQueueInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutNoteTakerQueueInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteTakerQueueInput, UserUncheckedCreateWithoutNoteTakerQueueInput>
  }

  export type UserUpsertWithoutNoteTakerQueueInput = {
    update: XOR<UserUpdateWithoutNoteTakerQueueInput, UserUncheckedUpdateWithoutNoteTakerQueueInput>
    create: XOR<UserCreateWithoutNoteTakerQueueInput, UserUncheckedCreateWithoutNoteTakerQueueInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteTakerQueueInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteTakerQueueInput, UserUncheckedUpdateWithoutNoteTakerQueueInput>
  }

  export type UserUpdateWithoutNoteTakerQueueInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteTakerQueueInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type DepartmentCreateWithoutServicesInput = {
    name: string
    positions?: PositionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    positions?: PositionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutServicesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
  }

  export type BookingServiceCreateWithoutServiceInput = {
    quantity?: number | null
    status?: $Enums.ServiceStatus
    booking: BookingCreateNestedOneWithoutServicesInput
  }

  export type BookingServiceUncheckedCreateWithoutServiceInput = {
    id?: number
    bookingId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type BookingServiceCreateOrConnectWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceCreateManyServiceInputEnvelope = {
    data: BookingServiceCreateManyServiceInput | BookingServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type HousekeepingTaskCreateWithoutServiceInput = {
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutHousekeepingTasksInput
    assignedTo?: UserCreateNestedOneWithoutHousekeepingTasksInput
  }

  export type HousekeepingTaskUncheckedCreateWithoutServiceInput = {
    id?: number
    bookingId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HousekeepingTaskCreateOrConnectWithoutServiceInput = {
    where: HousekeepingTaskWhereUniqueInput
    create: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput>
  }

  export type HousekeepingTaskCreateManyServiceInputEnvelope = {
    data: HousekeepingTaskCreateManyServiceInput | HousekeepingTaskCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutServicesInput = {
    update: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutServicesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type DepartmentUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    positions?: PositionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    positions?: PositionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type BookingServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    update: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<BookingServiceCreateWithoutServiceInput, BookingServiceUncheckedCreateWithoutServiceInput>
  }

  export type BookingServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BookingServiceWhereUniqueInput
    data: XOR<BookingServiceUpdateWithoutServiceInput, BookingServiceUncheckedUpdateWithoutServiceInput>
  }

  export type BookingServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BookingServiceScalarWhereInput
    data: XOR<BookingServiceUpdateManyMutationInput, BookingServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type HousekeepingTaskUpsertWithWhereUniqueWithoutServiceInput = {
    where: HousekeepingTaskWhereUniqueInput
    update: XOR<HousekeepingTaskUpdateWithoutServiceInput, HousekeepingTaskUncheckedUpdateWithoutServiceInput>
    create: XOR<HousekeepingTaskCreateWithoutServiceInput, HousekeepingTaskUncheckedCreateWithoutServiceInput>
  }

  export type HousekeepingTaskUpdateWithWhereUniqueWithoutServiceInput = {
    where: HousekeepingTaskWhereUniqueInput
    data: XOR<HousekeepingTaskUpdateWithoutServiceInput, HousekeepingTaskUncheckedUpdateWithoutServiceInput>
  }

  export type HousekeepingTaskUpdateManyWithWhereWithoutServiceInput = {
    where: HousekeepingTaskScalarWhereInput
    data: XOR<HousekeepingTaskUpdateManyMutationInput, HousekeepingTaskUncheckedUpdateManyWithoutServiceInput>
  }

  export type BookingCreateWithoutServicesInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServicesInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServicesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutBookingUsagesInput = {
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
    department?: DepartmentCreateNestedOneWithoutServicesInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutBookingUsagesInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    departmentId?: number | null
    requiresApproval?: boolean
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutBookingUsagesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutBookingUsagesInput, ServiceUncheckedCreateWithoutBookingUsagesInput>
  }

  export type BookingUpsertWithoutServicesInput = {
    update: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
    create: XOR<BookingCreateWithoutServicesInput, BookingUncheckedCreateWithoutServicesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutServicesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutServicesInput, BookingUncheckedUpdateWithoutServicesInput>
  }

  export type BookingUpdateWithoutServicesInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceUpsertWithoutBookingUsagesInput = {
    update: XOR<ServiceUpdateWithoutBookingUsagesInput, ServiceUncheckedUpdateWithoutBookingUsagesInput>
    create: XOR<ServiceCreateWithoutBookingUsagesInput, ServiceUncheckedCreateWithoutBookingUsagesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutBookingUsagesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutBookingUsagesInput, ServiceUncheckedUpdateWithoutBookingUsagesInput>
  }

  export type ServiceUpdateWithoutBookingUsagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutServicesNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutBookingUsagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutNoteTakerLeavesInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutNoteTakerLeavesInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutNoteTakerLeavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNoteTakerLeavesInput, UserUncheckedCreateWithoutNoteTakerLeavesInput>
  }

  export type UserUpsertWithoutNoteTakerLeavesInput = {
    update: XOR<UserUpdateWithoutNoteTakerLeavesInput, UserUncheckedUpdateWithoutNoteTakerLeavesInput>
    create: XOR<UserCreateWithoutNoteTakerLeavesInput, UserUncheckedCreateWithoutNoteTakerLeavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNoteTakerLeavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNoteTakerLeavesInput, UserUncheckedUpdateWithoutNoteTakerLeavesInput>
  }

  export type UserUpdateWithoutNoteTakerLeavesInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutNoteTakerLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BookingCreateWithoutHousekeepingTasksInput = {
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    room: MeetingRoomCreateNestedOneWithoutBookingsInput
    bookedBy: UserCreateNestedOneWithoutBookingsBookedInput
    requiredPositions?: BookingRequiredPositionCreateNestedManyWithoutBookingInput
    invites?: BookingInviteCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerCreateNestedManyWithoutBookingInput
    services?: BookingServiceCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutHousekeepingTasksInput = {
    id?: number
    roomId: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
    requiredPositions?: BookingRequiredPositionUncheckedCreateNestedManyWithoutBookingInput
    invites?: BookingInviteUncheckedCreateNestedManyWithoutBookingInput
    noteTakers?: BookingNoteTakerUncheckedCreateNestedManyWithoutBookingInput
    services?: BookingServiceUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutHousekeepingTasksInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutHousekeepingTasksInput, BookingUncheckedCreateWithoutHousekeepingTasksInput>
  }

  export type ServiceCreateWithoutHousekeepingTasksInput = {
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
    department?: DepartmentCreateNestedOneWithoutServicesInput
    bookingUsages?: BookingServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutHousekeepingTasksInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    departmentId?: number | null
    requiresApproval?: boolean
    bookingUsages?: BookingServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutHousekeepingTasksInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutHousekeepingTasksInput, ServiceUncheckedCreateWithoutHousekeepingTasksInput>
  }

  export type UserCreateWithoutHousekeepingTasksInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutHousekeepingTasksInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutHousekeepingTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHousekeepingTasksInput, UserUncheckedCreateWithoutHousekeepingTasksInput>
  }

  export type BookingUpsertWithoutHousekeepingTasksInput = {
    update: XOR<BookingUpdateWithoutHousekeepingTasksInput, BookingUncheckedUpdateWithoutHousekeepingTasksInput>
    create: XOR<BookingCreateWithoutHousekeepingTasksInput, BookingUncheckedCreateWithoutHousekeepingTasksInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutHousekeepingTasksInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutHousekeepingTasksInput, BookingUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type BookingUpdateWithoutHousekeepingTasksInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutHousekeepingTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ServiceUpsertWithoutHousekeepingTasksInput = {
    update: XOR<ServiceUpdateWithoutHousekeepingTasksInput, ServiceUncheckedUpdateWithoutHousekeepingTasksInput>
    create: XOR<ServiceCreateWithoutHousekeepingTasksInput, ServiceUncheckedCreateWithoutHousekeepingTasksInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutHousekeepingTasksInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutHousekeepingTasksInput, ServiceUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type ServiceUpdateWithoutHousekeepingTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneWithoutServicesNestedInput
    bookingUsages?: BookingServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutHousekeepingTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    bookingUsages?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutHousekeepingTasksInput = {
    update: XOR<UserUpdateWithoutHousekeepingTasksInput, UserUncheckedUpdateWithoutHousekeepingTasksInput>
    create: XOR<UserCreateWithoutHousekeepingTasksInput, UserUncheckedCreateWithoutHousekeepingTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHousekeepingTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHousekeepingTasksInput, UserUncheckedUpdateWithoutHousekeepingTasksInput>
  }

  export type UserUpdateWithoutHousekeepingTasksInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutHousekeepingTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutReportedIssuesInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    issueComments?: IssueCommentCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReportedIssuesInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    issueComments?: IssueCommentUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReportedIssuesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportedIssuesInput, UserUncheckedCreateWithoutReportedIssuesInput>
  }

  export type MeetingRoomCreateWithoutIssuesInput = {
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    bookings?: BookingCreateNestedManyWithoutRoomInput
  }

  export type MeetingRoomUncheckedCreateWithoutIssuesInput = {
    id?: number
    roomName: string
    capacity: number
    status?: $Enums.RoomStatus
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomInput
  }

  export type MeetingRoomCreateOrConnectWithoutIssuesInput = {
    where: MeetingRoomWhereUniqueInput
    create: XOR<MeetingRoomCreateWithoutIssuesInput, MeetingRoomUncheckedCreateWithoutIssuesInput>
  }

  export type IssueCommentCreateWithoutIssueInput = {
    message: string
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutIssueCommentsInput
  }

  export type IssueCommentUncheckedCreateWithoutIssueInput = {
    id?: number
    authorId: number
    message: string
    createdAt?: Date | string
  }

  export type IssueCommentCreateOrConnectWithoutIssueInput = {
    where: IssueCommentWhereUniqueInput
    create: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput>
  }

  export type IssueCommentCreateManyIssueInputEnvelope = {
    data: IssueCommentCreateManyIssueInput | IssueCommentCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type IssueAttachmentCreateWithoutIssueInput = {
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
  }

  export type IssueAttachmentUncheckedCreateWithoutIssueInput = {
    id?: number
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
  }

  export type IssueAttachmentCreateOrConnectWithoutIssueInput = {
    where: IssueAttachmentWhereUniqueInput
    create: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput>
  }

  export type IssueAttachmentCreateManyIssueInputEnvelope = {
    data: IssueAttachmentCreateManyIssueInput | IssueAttachmentCreateManyIssueInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportedIssuesInput = {
    update: XOR<UserUpdateWithoutReportedIssuesInput, UserUncheckedUpdateWithoutReportedIssuesInput>
    create: XOR<UserCreateWithoutReportedIssuesInput, UserUncheckedCreateWithoutReportedIssuesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportedIssuesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportedIssuesInput, UserUncheckedUpdateWithoutReportedIssuesInput>
  }

  export type UserUpdateWithoutReportedIssuesInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReportedIssuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type MeetingRoomUpsertWithoutIssuesInput = {
    update: XOR<MeetingRoomUpdateWithoutIssuesInput, MeetingRoomUncheckedUpdateWithoutIssuesInput>
    create: XOR<MeetingRoomCreateWithoutIssuesInput, MeetingRoomUncheckedCreateWithoutIssuesInput>
    where?: MeetingRoomWhereInput
  }

  export type MeetingRoomUpdateToOneWithWhereWithoutIssuesInput = {
    where?: MeetingRoomWhereInput
    data: XOR<MeetingRoomUpdateWithoutIssuesInput, MeetingRoomUncheckedUpdateWithoutIssuesInput>
  }

  export type MeetingRoomUpdateWithoutIssuesInput = {
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    bookings?: BookingUpdateManyWithoutRoomNestedInput
  }

  export type MeetingRoomUncheckedUpdateWithoutIssuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomName?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    bookings?: BookingUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type IssueCommentUpsertWithWhereUniqueWithoutIssueInput = {
    where: IssueCommentWhereUniqueInput
    update: XOR<IssueCommentUpdateWithoutIssueInput, IssueCommentUncheckedUpdateWithoutIssueInput>
    create: XOR<IssueCommentCreateWithoutIssueInput, IssueCommentUncheckedCreateWithoutIssueInput>
  }

  export type IssueCommentUpdateWithWhereUniqueWithoutIssueInput = {
    where: IssueCommentWhereUniqueInput
    data: XOR<IssueCommentUpdateWithoutIssueInput, IssueCommentUncheckedUpdateWithoutIssueInput>
  }

  export type IssueCommentUpdateManyWithWhereWithoutIssueInput = {
    where: IssueCommentScalarWhereInput
    data: XOR<IssueCommentUpdateManyMutationInput, IssueCommentUncheckedUpdateManyWithoutIssueInput>
  }

  export type IssueAttachmentUpsertWithWhereUniqueWithoutIssueInput = {
    where: IssueAttachmentWhereUniqueInput
    update: XOR<IssueAttachmentUpdateWithoutIssueInput, IssueAttachmentUncheckedUpdateWithoutIssueInput>
    create: XOR<IssueAttachmentCreateWithoutIssueInput, IssueAttachmentUncheckedCreateWithoutIssueInput>
  }

  export type IssueAttachmentUpdateWithWhereUniqueWithoutIssueInput = {
    where: IssueAttachmentWhereUniqueInput
    data: XOR<IssueAttachmentUpdateWithoutIssueInput, IssueAttachmentUncheckedUpdateWithoutIssueInput>
  }

  export type IssueAttachmentUpdateManyWithWhereWithoutIssueInput = {
    where: IssueAttachmentScalarWhereInput
    data: XOR<IssueAttachmentUpdateManyMutationInput, IssueAttachmentUncheckedUpdateManyWithoutIssueInput>
  }

  export type IssueAttachmentScalarWhereInput = {
    AND?: IssueAttachmentScalarWhereInput | IssueAttachmentScalarWhereInput[]
    OR?: IssueAttachmentScalarWhereInput[]
    NOT?: IssueAttachmentScalarWhereInput | IssueAttachmentScalarWhereInput[]
    id?: IntFilter<"IssueAttachment"> | number
    issueId?: IntFilter<"IssueAttachment"> | number
    filename?: StringFilter<"IssueAttachment"> | string
    url?: StringFilter<"IssueAttachment"> | string
    contentType?: StringNullableFilter<"IssueAttachment"> | string | null
    createdAt?: DateTimeFilter<"IssueAttachment"> | Date | string
  }

  export type IssueCreateWithoutCommentsInput = {
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedIssuesInput
    meetingRoom?: MeetingRoomCreateNestedOneWithoutIssuesInput
    attachments?: IssueAttachmentCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutCommentsInput = {
    id?: number
    reporterId: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: IssueAttachmentUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutCommentsInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutCommentsInput, IssueUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutIssueCommentsInput = {
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
    position: PositionCreateNestedOneWithoutUsersInput
    bookingsBooked?: BookingCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutIssueCommentsInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    positionId: number
    createdAt?: Date | string
    bookingsBooked?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingInvites?: BookingInviteUncheckedCreateNestedManyWithoutUserInput
    noteTakerAssigns?: BookingNoteTakerUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    noteTakerQueue?: NoteTakerQueueUncheckedCreateNestedOneWithoutUserInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedCreateNestedManyWithoutUserInput
    housekeepingTasks?: HousekeepingTaskUncheckedCreateNestedManyWithoutAssignedToInput
    reportedIssues?: IssueUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutIssueCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIssueCommentsInput, UserUncheckedCreateWithoutIssueCommentsInput>
  }

  export type IssueUpsertWithoutCommentsInput = {
    update: XOR<IssueUpdateWithoutCommentsInput, IssueUncheckedUpdateWithoutCommentsInput>
    create: XOR<IssueCreateWithoutCommentsInput, IssueUncheckedCreateWithoutCommentsInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutCommentsInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutCommentsInput, IssueUncheckedUpdateWithoutCommentsInput>
  }

  export type IssueUpdateWithoutCommentsInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedIssuesNestedInput
    meetingRoom?: MeetingRoomUpdateOneWithoutIssuesNestedInput
    attachments?: IssueAttachmentUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: IssueAttachmentUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type UserUpsertWithoutIssueCommentsInput = {
    update: XOR<UserUpdateWithoutIssueCommentsInput, UserUncheckedUpdateWithoutIssueCommentsInput>
    create: XOR<UserCreateWithoutIssueCommentsInput, UserUncheckedCreateWithoutIssueCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIssueCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIssueCommentsInput, UserUncheckedUpdateWithoutIssueCommentsInput>
  }

  export type UserUpdateWithoutIssueCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutUsersNestedInput
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutIssueCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type IssueCreateWithoutAttachmentsInput = {
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter: UserCreateNestedOneWithoutReportedIssuesInput
    meetingRoom?: MeetingRoomCreateNestedOneWithoutIssuesInput
    comments?: IssueCommentCreateNestedManyWithoutIssueInput
  }

  export type IssueUncheckedCreateWithoutAttachmentsInput = {
    id?: number
    reporterId: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: IssueCommentUncheckedCreateNestedManyWithoutIssueInput
  }

  export type IssueCreateOrConnectWithoutAttachmentsInput = {
    where: IssueWhereUniqueInput
    create: XOR<IssueCreateWithoutAttachmentsInput, IssueUncheckedCreateWithoutAttachmentsInput>
  }

  export type IssueUpsertWithoutAttachmentsInput = {
    update: XOR<IssueUpdateWithoutAttachmentsInput, IssueUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<IssueCreateWithoutAttachmentsInput, IssueUncheckedCreateWithoutAttachmentsInput>
    where?: IssueWhereInput
  }

  export type IssueUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: IssueWhereInput
    data: XOR<IssueUpdateWithoutAttachmentsInput, IssueUncheckedUpdateWithoutAttachmentsInput>
  }

  export type IssueUpdateWithoutAttachmentsInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedIssuesNestedInput
    meetingRoom?: MeetingRoomUpdateOneWithoutIssuesNestedInput
    comments?: IssueCommentUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutAttachmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: IssueCommentUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type PositionCreateManyDepartmentInput = {
    id?: number
    name: string
    isAdmin?: boolean
    isNoteManager?: boolean
    isNoteTaker?: boolean
    isHousekeeper?: boolean
    isHousekeepingLead?: boolean
    description?: string | null
  }

  export type ServiceCreateManyDepartmentInput = {
    id?: number
    name: string
    category: $Enums.ServiceCategory
    requiresApproval?: boolean
  }

  export type PositionUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateManyWithoutPositionNestedInput
    neededBy?: BookingRequiredPositionUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUncheckedUpdateManyWithoutPositionNestedInput
    neededBy?: BookingRequiredPositionUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isNoteManager?: BoolFieldUpdateOperationsInput | boolean
    isNoteTaker?: BoolFieldUpdateOperationsInput | boolean
    isHousekeeper?: BoolFieldUpdateOperationsInput | boolean
    isHousekeepingLead?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpdateWithoutDepartmentInput = {
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    bookingUsages?: BookingServiceUpdateManyWithoutServiceNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    bookingUsages?: BookingServiceUncheckedUpdateManyWithoutServiceNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyPositionInput = {
    id?: number
    username: string
    passwordHash: string
    fullName: string
    email?: string | null
    createdAt?: Date | string
  }

  export type BookingRequiredPositionCreateManyPositionInput = {
    id?: number
    bookingId: number
  }

  export type UserUpdateWithoutPositionInput = {
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingsBooked?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingInvites?: BookingInviteUncheckedUpdateManyWithoutUserNestedInput
    noteTakerAssigns?: BookingNoteTakerUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    noteTakerQueue?: NoteTakerQueueUncheckedUpdateOneWithoutUserNestedInput
    noteTakerLeaves?: NoteTakerLeaveUncheckedUpdateManyWithoutUserNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutAssignedToNestedInput
    reportedIssues?: IssueUncheckedUpdateManyWithoutReporterNestedInput
    issueComments?: IssueCommentUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRequiredPositionUpdateWithoutPositionInput = {
    booking?: BookingUpdateOneRequiredWithoutRequiredPositionsNestedInput
  }

  export type BookingRequiredPositionUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingRequiredPositionUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingCreateManyBookedByInput = {
    id?: number
    roomId: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
  }

  export type BookingInviteCreateManyUserInput = {
    id?: number
    bookingId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingNoteTakerCreateManyUserInput = {
    id?: number
    bookingId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: $Enums.NotifType
    title: string
    message: string
    refType?: $Enums.RefType | null
    refId?: number | null
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
  }

  export type NoteTakerLeaveCreateManyUserInput = {
    id?: number
    date: Date | string
    reason?: string | null
    createdAt?: Date | string
  }

  export type HousekeepingTaskCreateManyAssignedToInput = {
    id?: number
    bookingId: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IssueCreateManyReporterInput = {
    id?: number
    roomId?: number | null
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IssueCommentCreateManyAuthorInput = {
    id?: number
    issueId: number
    message: string
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutBookedByInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: MeetingRoomUpdateOneRequiredWithoutBookingsNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutBookedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingInviteUpdateWithoutUserInput = {
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type BookingInviteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingInviteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingNoteTakerUpdateWithoutUserInput = {
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
    booking?: BookingUpdateOneRequiredWithoutNoteTakersNestedInput
  }

  export type BookingNoteTakerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotifTypeFieldUpdateOperationsInput | $Enums.NotifType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    refType?: NullableEnumRefTypeFieldUpdateOperationsInput | $Enums.RefType | null
    refId?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoteTakerLeaveUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteTakerLeaveUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoteTakerLeaveUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskUpdateWithoutAssignedToInput = {
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutHousekeepingTasksNestedInput
    service?: ServiceUpdateOneRequiredWithoutHousekeepingTasksNestedInput
  }

  export type HousekeepingTaskUncheckedUpdateWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutAssignedToInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueUpdateWithoutReporterInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingRoom?: MeetingRoomUpdateOneWithoutIssuesNestedInput
    comments?: IssueCommentUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: IssueCommentUncheckedUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomId?: NullableIntFieldUpdateOperationsInput | number | null
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentUpdateWithoutAuthorInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    issue?: IssueUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type IssueCommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    issueId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyRoomInput = {
    id?: number
    bookedById: number
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.BookingStatus
    purpose?: string | null
    createdAt?: Date | string
  }

  export type IssueCreateManyMeetingRoomInput = {
    id?: number
    reporterId: number
    issueType: $Enums.IssueType
    subject: string
    description: string
    priority?: $Enums.IssuePriority
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutRoomInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: UserUpdateOneRequiredWithoutBookingsBookedNestedInput
    requiredPositions?: BookingRequiredPositionUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requiredPositions?: BookingRequiredPositionUncheckedUpdateManyWithoutBookingNestedInput
    invites?: BookingInviteUncheckedUpdateManyWithoutBookingNestedInput
    noteTakers?: BookingNoteTakerUncheckedUpdateManyWithoutBookingNestedInput
    services?: BookingServiceUncheckedUpdateManyWithoutBookingNestedInput
    housekeepingTasks?: HousekeepingTaskUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookedById?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    purpose?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueUpdateWithoutMeetingRoomInput = {
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneRequiredWithoutReportedIssuesNestedInput
    comments?: IssueCommentUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateWithoutMeetingRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: IssueCommentUncheckedUpdateManyWithoutIssueNestedInput
    attachments?: IssueAttachmentUncheckedUpdateManyWithoutIssueNestedInput
  }

  export type IssueUncheckedUpdateManyWithoutMeetingRoomInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumIssuePriorityFieldUpdateOperationsInput | $Enums.IssuePriority
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingRequiredPositionCreateManyBookingInput = {
    id?: number
    positionId: number
  }

  export type BookingInviteCreateManyBookingInput = {
    id?: number
    userId: number
    status?: $Enums.InviteStatus
    respondedAt?: Date | string | null
  }

  export type BookingNoteTakerCreateManyBookingInput = {
    id?: number
    userId: number
    roleIndex: number
    status?: $Enums.NoteQueueStatus
  }

  export type BookingServiceCreateManyBookingInput = {
    id?: number
    serviceId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type HousekeepingTaskCreateManyBookingInput = {
    id?: number
    serviceId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingRequiredPositionUpdateWithoutBookingInput = {
    position?: PositionUpdateOneRequiredWithoutNeededByNestedInput
  }

  export type BookingRequiredPositionUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    positionId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingRequiredPositionUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    positionId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingInviteUpdateWithoutBookingInput = {
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutBookingInvitesNestedInput
  }

  export type BookingInviteUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingInviteUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingNoteTakerUpdateWithoutBookingInput = {
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
    user?: UserUpdateOneRequiredWithoutNoteTakerAssignsNestedInput
  }

  export type BookingNoteTakerUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type BookingNoteTakerUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    roleIndex?: IntFieldUpdateOperationsInput | number
    status?: EnumNoteQueueStatusFieldUpdateOperationsInput | $Enums.NoteQueueStatus
  }

  export type BookingServiceUpdateWithoutBookingInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    service?: ServiceUpdateOneRequiredWithoutBookingUsagesNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type BookingServiceUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type HousekeepingTaskUpdateWithoutBookingInput = {
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutHousekeepingTasksNestedInput
    assignedTo?: UserUpdateOneWithoutHousekeepingTasksNestedInput
  }

  export type HousekeepingTaskUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingServiceCreateManyServiceInput = {
    id?: number
    bookingId: number
    quantity?: number | null
    status?: $Enums.ServiceStatus
  }

  export type HousekeepingTaskCreateManyServiceInput = {
    id?: number
    bookingId: number
    status?: $Enums.HousekeepingTaskStatus
    assignedToId?: number | null
    note?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingServiceUpdateWithoutServiceInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    booking?: BookingUpdateOneRequiredWithoutServicesNestedInput
  }

  export type BookingServiceUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type BookingServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
  }

  export type HousekeepingTaskUpdateWithoutServiceInput = {
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutHousekeepingTasksNestedInput
    assignedTo?: UserUpdateOneWithoutHousekeepingTasksNestedInput
  }

  export type HousekeepingTaskUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HousekeepingTaskUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    status?: EnumHousekeepingTaskStatusFieldUpdateOperationsInput | $Enums.HousekeepingTaskStatus
    assignedToId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentCreateManyIssueInput = {
    id?: number
    authorId: number
    message: string
    createdAt?: Date | string
  }

  export type IssueAttachmentCreateManyIssueInput = {
    id?: number
    filename: string
    url: string
    contentType?: string | null
    createdAt?: Date | string
  }

  export type IssueCommentUpdateWithoutIssueInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutIssueCommentsNestedInput
  }

  export type IssueCommentUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueCommentUncheckedUpdateManyWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentUpdateWithoutIssueInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentUncheckedUpdateWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IssueAttachmentUncheckedUpdateManyWithoutIssueInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}